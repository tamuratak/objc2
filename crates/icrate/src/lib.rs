#![feature(prelude_import)]
//  cargo expand --features=Foundation > src/lib.rs
//! # Bindings to Apple's frameworks
//!
//! `icrate` is an autogenerated interface to Apple's Objective-C frameworks
//! like AppKit, Foundation, Metal, WebKit, and so on.
//!
//! The bindings currently contain very little documentation, you should view
//! [Apple's developer documentation][apple-doc-index] for detailed
//! information about each API. (There are [plans][#309] for importing that
//! documentation here).
//!
//! This crate uses [`objc2`] to declare the external interface to the
//! Objective-C classes and protocols. It is highly recommended that you read
//! the documentation there for details on how the Objective-C interop works.
//!
//! It also uses [`block2::Block`] in the public API, check out the [`block2`]
//! crate for how to call such methods using a closure.
//!
//! A common mistake is to specify a different [`objc2`] or [`block2`] version
//! in your `Cargo.toml` than the one your version of `icrate` uses. The
//! versions that `icrate` currently uses is exported as `icrate::objc2` and
//! `icrate::block2` for convenience.
//!
//! [apple-doc-index]: https://developer.apple.com/documentation/technologies
//! [#309]: https://github.com/madsmtm/objc2/issues/309
//!
//!
//! ## Supported versions
//!
//! - macOS: `10.12-14.2`
//! - iOS/iPadOS: `10.0-17.2` (WIP)
//! - tvOS: `10.0-17.2` (WIP)
//! - watchOS: `5.0-10.2` (WIP)
//! - visionOS: Not currently supported
//!
//! These bindings are currently generated from the SDKs in Xcode 15.2.
//! The Xcode version will be periodically updated.
//!
//!
//! ## Use of `Deref`
//!
//! `icrate` uses the [`Deref`] trait in a bit special way: All objects deref
//! to their superclasses. For example, `NSMutableArray` derefs to `NSArray`,
//! which in turn derefs to `NSObject`.
//!
//! Note that this is explicitly recommended against in [the
//! documentation][`Deref`] and [the Rust Design patterns
//! book][anti-pattern-deref] (see those links for details).
//!
//! Due to Objective-C objects only ever being accessible behind pointers in
//! the first place, the problems stated there are less severe, and having the
//! implementation just means that everything is much nicer when you actually
//! want to use the objects!
//!
//! All objects also implement [`AsRef`] and [`AsMut`] to their superclass,
//! and can be used in [`Id::into_super`], so if you favour explicit
//! conversion, that is a possibility too.
//!
//! [`Deref`]: std::ops::Deref
//! [`ClassType`]: crate::objc2::ClassType
//! [anti-pattern-deref]: https://rust-unofficial.github.io/patterns/anti_patterns/deref.html
//! [`Id::into_super`]: objc2::rc::Id::into_super
//!
//!
//! ## Rust vs. Objective-C types
//!
//! A quick overview of some types you will encounter often in Objective-C,
//! and their approximate Rust equivalent.
//!
//! | Objective-C | (approximately) equivalent Rust |
//! | --- | --- |
//! | `NSData*` | `Arc<[u8]>` |
//! | `NSMutableData*` | `Vec<u8>` |
//! | `NSString*` | `Arc<str>` |
//! | `NSMutableString*` | `String` |
//! | `NSValue*` | `Arc<dyn Any>` |
//! | `NSNumber*` | `Arc<enum { I8(i8), U8(u8), I16(i16), U16(u16), I32(i32), U32(u32), I64(i64), U64(u64), F32(f32), F64(f64), CLong(ffi::c_long), CULong(ffi::c_ulong) }>` |
//! | `NSError*` | `Arc<dyn Error + Send + Sync>` |
//! | `NSException*` | `Arc<dyn Error + Send + Sync>` |
//! | `NSRange` | `ops::Range<usize>` |
//! | `NSComparisonResult` | `cmp::Ordering` |
//! | `NSArray<T>*` | `Arc<[T]>` |
//! | `NSMutableArray<T>*` | `Vec<T>` |
//! | `NSDictionary<K, V>*` | `Arc<HashMap<K, V>>` |
//! | `NSMutableDictionary<K, V>*` | `HashMap<K, V>` |
//! | `NSEnumerator<T>*` | `Box<dyn Iterator<T>>` |
//! | `NSCopying*` | `Box<dyn Clone>` |
//!
//!
//! ## Example
//!
//! ```console
//! $ cargo add icrate --features=Foundation,Foundation_all
//! ```
//!
//!```ignore
//! use icrate::Foundation::{ns_string, NSCopying, NSArray};
//!
//! let string = ns_string!("world");
//! println!("hello {string}");
//!
//! let array = NSArray::from_id_slice(&[string.copy()]);
//! println!("{array:?}");
//! ```
#![no_std]
#![warn(elided_lifetimes_in_paths)]
#![warn(missing_copy_implementations)]
#![warn(missing_debug_implementations)]
#![deny(non_ascii_idents)]
#![warn(unreachable_pub)]
#![deny(unsafe_op_in_unsafe_fn)]
#![warn(clippy::cargo)]
#![warn(clippy::ptr_as_ptr)]
#![doc(html_root_url = "https://docs.rs/icrate/0.1.0")]
#![recursion_limit = "512"]
#[prelude_import]
use core::prelude::rust_2021::*;
#[macro_use]
extern crate core;
extern crate compiler_builtins as _;
#[cfg(feature = "alloc")]
extern crate alloc;
#[cfg(feature = "std")]
extern crate std;
#[cfg(feature = "objc2")]
pub extern crate objc2;
#[cfg(feature = "block2")]
pub extern crate block2;
mod common {
    #![allow(unused_imports)]
    #![allow(dead_code)]
    pub(crate) use core::ffi::c_void;
    pub(crate) use core::marker::PhantomData;
    pub(crate) use core::ptr::NonNull;
    #[cfg(feature = "std")]
    pub(crate) use std::os::raw::{
        c_char, c_double, c_float, c_int, c_long, c_longlong, c_schar, c_short, c_uchar,
        c_uint, c_ulong, c_ulonglong, c_ushort,
    };
    #[cfg(feature = "objc2")]
    pub(crate) use objc2::ffi::{NSInteger, NSIntegerMax, NSUInteger, NSUIntegerMax, IMP};
    #[cfg(feature = "objc2")]
    pub(crate) use objc2::mutability::{
        Immutable, ImmutableWithMutableSubclass, InteriorMutable, IsIdCloneable,
        IsMainThreadOnly, MainThreadOnly, Mutable, MutableWithImmutableSuperclass,
    };
    #[cfg(feature = "objc2")]
    pub(crate) use objc2::rc::{Allocated, DefaultId, Id};
    #[cfg(feature = "objc2")]
    pub(crate) use objc2::runtime::{AnyClass, AnyObject, Bool, Sel};
    #[cfg(feature = "objc2")]
    pub(crate) use objc2::runtime::{NSObject, NSObjectProtocol, ProtocolObject};
    #[cfg(feature = "objc2")]
    pub(crate) use objc2::{
        __inner_extern_class, extern_category, extern_class, extern_methods,
        extern_protocol, ClassType, Message, ProtocolType,
    };
    #[cfg(feature = "block2")]
    pub(crate) use block2::Block;
    #[cfg(feature = "objc2")]
    pub(crate) type AnyProtocol = AnyObject;
    pub(crate) type TodoFunction = *const c_void;
    #[cfg(feature = "objc2")]
    pub(crate) type TodoClass = AnyObject;
    #[cfg(feature = "objc2")]
    pub(crate) type TodoProtocols = AnyObject;
}
#[macro_use]
mod macros {
    #![allow(unused_macros)]
}
mod additions {
    #![allow(non_snake_case)]
    #[cfg(feature = "Foundation")]
    pub mod Foundation {
        //! # Bindings to the `Foundation` framework
        //!
        //! This is the [`std`] equivalent for Objective-C, containing essential data
        //! types, collections, and operating-system services.
        //!
        //! See [Apple's documentation](https://developer.apple.com/documentation/foundation?language=objc).
        //!
        //!
        //! ## Examples
        //!
        //! Basic usage of a few Foundation types.
        //!
        //! ```ignore
        /*!use icrate::objc2::rc::autoreleasepool;
use icrate::Foundation::{ns_string, NSArray, NSDictionary, NSObject};

fn main() {
    // Create and compare NSObjects
    let obj = NSObject::new();
    #[allow(clippy::eq_op)]
    {
        println!("{obj:?} == {obj:?}? {:?}", obj == obj);
    }

    let obj2 = NSObject::new();
    println!("{obj:?} == {obj2:?}? {:?}", obj == obj2);

    // Create an NSArray from a Vec
    let objs = vec![obj, obj2];
    let array = NSArray::from_vec(objs);
    for obj in array.iter() {
        println!("{obj:?}");
    }
    println!("{}", array.len());

    // Turn the NSArray back into a Vec
    let mut objs = array.to_vec_retained();
    let obj = objs.pop().unwrap();

    // Create a static NSString
    let string = ns_string!("Hello, world!");
    // Use an autoreleasepool to get the `str` contents of the NSString
    autoreleasepool(|pool| {
        println!("{}", string.as_str(pool));
    });
    // Or use the `Display` implementation
    let _s = string.to_string(); // Using ToString
    println!("{string}"); // Or Display directly

    // Create a dictionary mapping strings to objects
    let keys = &[string];
    let objects = &[obj];
    let dict = NSDictionary::from_id_slice(keys, objects);
    println!("{:?}", dict.get(string));
    println!("{}", dict.len());
}
*/
        //! ```
        //!
        //! An example showing how to define your own interfaces to parts that may be missing in `icrate`.
        //!
        //! ```ignore
        /*!//! Speak synthethized text.
//!
//! This uses `NSSpeechSynthesizer` on macOS, and `AVSpeechSynthesizer` on
//! other Apple platforms. Note that `AVSpeechSynthesizer` _is_ available on
//! macOS, but only since 10.15!
//!
//! Works on macOS >= 10.7 and iOS > 7.0.
#![deny(unsafe_op_in_unsafe_fn)]

use std::thread;
use std::time::Duration;

use icrate::Foundation::{ns_string, NSObject, NSString};
use objc2::mutability::InteriorMutable;
use objc2::rc::Id;
use objc2::{extern_class, msg_send, msg_send_id, ClassType};

#[cfg(target_os = "macos")]
mod appkit {
    use icrate::Foundation::NSCopying;
    use std::cell::Cell;

    use super::*;

    #[link(name = "AppKit", kind = "framework")]
    extern "C" {}

    extern_class!(
        /// <https://developer.apple.com/documentation/appkit/nsspeechsynthesizer?language=objc>
        pub struct Synthesizer;

        unsafe impl ClassType for Synthesizer {
            type Super = NSObject;
            type Mutability = InteriorMutable;
            const NAME: &'static str = "NSSpeechSynthesizer";
        }
    );

    impl Synthesizer {
        // Uses default voice
        pub fn new() -> Id<Self> {
            unsafe { msg_send_id![Self::class(), new] }
        }

        fn set_rate(&self, rate: f32) {
            unsafe { msg_send![self, setRate: rate] }
        }

        fn set_volume(&self, volume: f32) {
            unsafe { msg_send![self, setVolume: volume] }
        }

        fn start_speaking(&self, s: &NSString) {
            let _: bool = unsafe { msg_send![self, startSpeakingString: s] };
        }

        pub fn speak(&self, utterance: &Utterance) {
            // Convert to the range 90-720 that `NSSpeechSynthesizer` seems to
            // support
            //
            // Note that you'd probably want a nonlinear conversion here to
            // make it match `AVSpeechSynthesizer`.
            self.set_rate(90.0 + (utterance.rate.get() * (360.0 - 90.0)));
            self.set_volume(utterance.volume.get());
            self.start_speaking(&utterance.string);
        }

        pub fn is_speaking(&self) -> bool {
            unsafe { msg_send![self, isSpeaking] }
        }
    }

    // Shim to make NSSpeechSynthesizer work similar to AVSpeechSynthesizer
    pub struct Utterance {
        rate: Cell<f32>,
        volume: Cell<f32>,
        string: Id<NSString>,
    }

    impl Utterance {
        pub fn new(string: &NSString) -> Self {
            Self {
                rate: Cell::new(0.5),
                volume: Cell::new(1.0),
                string: string.copy(),
            }
        }

        pub fn set_rate(&self, rate: f32) {
            self.rate.set(rate);
        }

        pub fn set_volume(&self, volume: f32) {
            self.volume.set(volume);
        }
    }
}

#[cfg(not(target_os = "macos"))]
mod avfaudio {
    use super::*;

    #[link(name = "AVFoundation", kind = "framework")]
    extern "C" {}

    extern_class!(
        /// <https://developer.apple.com/documentation/avfaudio/avspeechsynthesizer?language=objc>
        #[derive(Debug)]
        pub struct Synthesizer;

        unsafe impl ClassType for Synthesizer {
            type Super = NSObject;
            type Mutability = InteriorMutable;
            const NAME: &'static str = "AVSpeechSynthesizer";
        }
    );

    impl Synthesizer {
        pub fn new() -> Id<Self> {
            unsafe { msg_send_id![Self::class(), new] }
        }

        pub fn speak(&self, utterance: &Utterance) {
            unsafe { msg_send![self, speakUtterance: utterance] }
        }

        pub fn is_speaking(&self) -> bool {
            unsafe { msg_send![self, isSpeaking] }
        }
    }

    extern_class!(
        /// <https://developer.apple.com/documentation/avfaudio/avspeechutterance?language=objc>
        #[derive(Debug)]
        pub struct Utterance;

        unsafe impl ClassType for Utterance {
            type Super = NSObject;
            type Mutability = InteriorMutable;
            const NAME: &'static str = "AVSpeechUtterance";
        }
    );

    impl Utterance {
        pub fn new(string: &NSString) -> Id<Self> {
            unsafe { msg_send_id![Self::alloc(), initWithString: string] }
        }

        pub fn set_rate(&self, rate: f32) {
            unsafe { msg_send![self, setRate: rate] }
        }

        pub fn set_volume(&self, volume: f32) {
            unsafe { msg_send![self, setVolume: volume] }
        }
    }
}

#[cfg(target_os = "macos")]
use appkit::{Synthesizer, Utterance};
#[cfg(not(target_os = "macos"))]
use avfaudio::{Synthesizer, Utterance};

fn main() {
    let synthesizer = Synthesizer::new();
    let utterance = Utterance::new(ns_string!("Hello from Rust!"));
    utterance.set_rate(0.5);
    utterance.set_volume(0.5);
    synthesizer.speak(&utterance);

    // Wait until speech has properly started up
    thread::sleep(Duration::from_millis(1000));
    // Wait until finished speaking
    while synthesizer.is_speaking() {
        thread::sleep(Duration::from_millis(100));
    }
}
*/
        //! ```
        #![allow(non_snake_case)]
        #[doc(hidden)]
        pub mod __macro_helpers {
            mod cached {
                use core::mem::ManuallyDrop;
                use core::ptr;
                use core::sync::atomic::{AtomicPtr, Ordering};
                use objc2::rc::Id;
                use objc2::Message;
                /// Allows storing an `Id` in a static and lazily loading it.
                pub struct CachedId<T> {
                    ptr: AtomicPtr<T>,
                }
                #[automatically_derived]
                impl<T: ::core::fmt::Debug> ::core::fmt::Debug for CachedId<T> {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "CachedId",
                            "ptr",
                            &&self.ptr,
                        )
                    }
                }
                impl<T> CachedId<T> {
                    /// Constructs a new [`CachedId`].
                    pub const fn new() -> Self {
                        Self {
                            ptr: AtomicPtr::new(ptr::null_mut()),
                        }
                    }
                }
                impl<T: Message> CachedId<T> {
                    /// Returns the cached object. If no object is yet cached, creates one
                    /// from the given closure and stores it.
                    #[inline]
                    pub fn get(&self, f: impl FnOnce() -> Id<T>) -> &'static T {
                        let ptr = self.ptr.load(Ordering::SeqCst);
                        unsafe { ptr.as_ref() }
                            .unwrap_or_else(|| {
                                let s = ManuallyDrop::new(f());
                                let ptr = Id::as_ptr(&s);
                                self.ptr.store(ptr as *mut T, Ordering::SeqCst);
                                unsafe { ptr.as_ref().unwrap_unchecked() }
                            })
                    }
                }
            }
            #[cfg(feature = "Foundation_NSString")]
            mod ns_string {
                #![allow(missing_copy_implementations)]
                //! Macro for making a static NSString.
                //!
                //! This closely follows what clang does, see:
                //! - Apple: <https://github.com/llvm/llvm-project/blob/release/13.x/clang/lib/CodeGen/CodeGenModule.cpp#L5057-L5249>
                //! - GNUStep 2.0 (not yet supported): <https://github.com/llvm/llvm-project/blob/release/13.x/clang/lib/CodeGen/CGObjCGNU.cpp#L973-L1118>
                //! - Other (not yet supported): <https://github.com/llvm/llvm-project/blob/release/13.x/clang/lib/CodeGen/CGObjCGNU.cpp#L2471-L2507>
                //!
                //! Note that this uses the `CFString` static, while `clang` has support for
                //! generating a pure `NSString`. We don't support that yet (since I don't
                //! know the use-case), but we definitely could!
                //! See: <https://github.com/llvm/llvm-project/blob/release/13.x/clang/lib/CodeGen/CGObjCMac.cpp#L2007-L2068>
                //!
                //! See also the following crates that implement UTF-16 conversion:
                //! `utf16_lit`, `windows`, `const_utf16`, `wide-literals`, ...
                use core::ffi::c_void;
                use crate::Foundation::NSString;
                use objc2::runtime::AnyClass;
                extern "C" {
                    pub static __CFConstantStringClassReference: AnyClass;
                }
                /// Structure used to describe a constant `CFString`.
                ///
                /// This struct is the same as [`CF_CONST_STRING`], which contains
                /// [`CFRuntimeBase`]. While the documentation clearly says that the ABI of
                /// `CFRuntimeBase` should not be relied on, we can rely on it as long as we
                /// only do it with regards to `CFString` (because `clang` does this as well).
                ///
                /// [`CFRuntimeBase`]: <https://github.com/apple-oss-distributions/CF/blob/CF-1153.18/CFRuntime.h#L216-L228>
                /// [`CF_CONST_STRING`]: <https://github.com/apple-oss-distributions/CF/blob/CF-1153.18/CFInternal.h#L332-L336>
                #[repr(C)]
                pub struct CFConstString {
                    isa: &'static AnyClass,
                    cfinfo: u32,
                    #[cfg(target_pointer_width = "64")]
                    _rc: u32,
                    data: *const c_void,
                    len: usize,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for CFConstString {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field5_finish(
                            f,
                            "CFConstString",
                            "isa",
                            &self.isa,
                            "cfinfo",
                            &self.cfinfo,
                            "_rc",
                            &self._rc,
                            "data",
                            &self.data,
                            "len",
                            &&self.len,
                        )
                    }
                }
                unsafe impl Sync for CFConstString {}
                impl CFConstString {
                    const FLAGS_ASCII: u32 = 0x07_C8;
                    const FLAGS_UTF16: u32 = 0x07_D0;
                    pub const unsafe fn new_ascii(
                        isa: &'static AnyClass,
                        data: &'static [u8],
                    ) -> Self {
                        Self {
                            isa,
                            cfinfo: Self::FLAGS_ASCII,
                            #[cfg(target_pointer_width = "64")]
                            _rc: 0,
                            data: data.as_ptr().cast(),
                            len: data.len() - 1,
                        }
                    }
                    pub const unsafe fn new_utf16(
                        isa: &'static AnyClass,
                        data: &'static [u16],
                    ) -> Self {
                        Self {
                            isa,
                            cfinfo: Self::FLAGS_UTF16,
                            #[cfg(target_pointer_width = "64")]
                            _rc: 0,
                            data: data.as_ptr().cast(),
                            len: data.len() - 1,
                        }
                    }
                    #[inline]
                    pub const fn as_nsstring_const(&self) -> &NSString {
                        let ptr: *const Self = self;
                        unsafe { &*ptr.cast::<NSString>() }
                    }
                    #[inline]
                    pub fn as_nsstring(&self) -> &NSString {
                        self.as_nsstring_const()
                    }
                }
                /// Returns `true` if `bytes` is entirely ASCII with no interior NULs.
                pub const fn is_ascii_no_nul(bytes: &[u8]) -> bool {
                    let mut i = 0;
                    while i < bytes.len() {
                        let byte = bytes[i];
                        if !byte.is_ascii() || byte == b'\0' {
                            return false;
                        }
                        i += 1;
                    }
                    true
                }
                pub struct Utf16Char {
                    pub repr: [u16; 2],
                    pub len: usize,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Utf16Char {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "Utf16Char",
                            "repr",
                            &self.repr,
                            "len",
                            &&self.len,
                        )
                    }
                }
                impl Utf16Char {
                    const fn encode(ch: u32) -> Self {
                        if ch <= 0xffff {
                            Self {
                                repr: [ch as u16, 0],
                                len: 1,
                            }
                        } else {
                            let payload = ch - 0x10000;
                            let hi = (payload >> 10) | 0xd800;
                            let lo = (payload & 0x3ff) | 0xdc00;
                            Self {
                                repr: [hi as u16, lo as u16],
                                len: 2,
                            }
                        }
                    }
                }
                pub struct EncodeUtf16Iter {
                    str: &'static [u8],
                    index: usize,
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for EncodeUtf16Iter {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "EncodeUtf16Iter",
                            "str",
                            &self.str,
                            "index",
                            &&self.index,
                        )
                    }
                }
                impl EncodeUtf16Iter {
                    pub const fn new(str: &'static [u8]) -> Self {
                        Self { str, index: 0 }
                    }
                    pub const fn next(self) -> Option<(Self, Utf16Char)> {
                        if self.index >= self.str.len() {
                            None
                        } else {
                            let (index, ch) = decode_utf8(self.str, self.index);
                            Some((Self { index, ..self }, Utf16Char::encode(ch)))
                        }
                    }
                }
                const fn decode_utf8(s: &[u8], i: usize) -> (usize, u32) {
                    let b0 = s[i];
                    match b0 {
                        0b0000_0000..=0b0111_1111 => {
                            let decoded = b0 as u32;
                            (i + 1, decoded)
                        }
                        0b1100_0000..=0b1101_1111 => {
                            let decoded = ((b0 as u32 & 0x1f) << 6)
                                | (s[i + 1] as u32 & 0x3f);
                            (i + 2, decoded)
                        }
                        0b1110_0000..=0b1110_1111 => {
                            let decoded = ((b0 as u32 & 0x0f) << 12)
                                | ((s[i + 1] as u32 & 0x3f) << 6)
                                | (s[i + 2] as u32 & 0x3f);
                            (i + 3, decoded)
                        }
                        0b1111_0000..=0b1111_0111 => {
                            let decoded = ((b0 as u32 & 0x07) << 18)
                                | ((s[i + 1] as u32 & 0x3f) << 12)
                                | ((s[i + 2] as u32 & 0x3f) << 6)
                                | (s[i + 3] as u32 & 0x3f);
                            (i + 4, decoded)
                        }
                        0b1000_0000..=0b1011_1111 | 0b1111_1000..=0b1111_1111 => {
                            ::core::panicking::panic_fmt(
                                format_args!("Encountered invalid bytes"),
                            );
                        }
                    }
                }
            }
            pub use self::cached::CachedId;
            #[cfg(feature = "Foundation_NSString")]
            pub use self::ns_string::*;
        }
        #[macro_use]
        mod iter {
            #![allow(dead_code)]
            use core::ptr;
            use objc2::mutability::IsMutable;
            use super::util;
            use crate::common::*;
            use crate::Foundation::{NSFastEnumeration, NSFastEnumerationState};
            /// Swift and Objective-C both have a stack buffer size of 16, so we do that
            /// as well.
            ///
            /// TODO: Consider lowering this a bit, since the most common type of
            /// enumeration (e.g. NSArray) doesn't use the buffer:
            /// [CFArray's NSFastEnumeration implementation](https://github.com/apple-oss-distributions/CF/blob/dc54c6bb1c1e5e0b9486c1d26dd5bef110b20bf3/CFArray.c#L618-L642)
            const BUF_SIZE: usize = 16;
            /// Helper type for doing fast enumeration.
            ///
            /// See the following other implementations of this:
            /// - [Swift](https://github.com/apple/swift-corelibs-foundation/blob/2d23cf3dc07951ed2b988608d08d7a54cc53b26e/Darwin/Foundation-swiftoverlay/NSFastEnumeration.swift#L23)
            /// - [Clang](https://github.com/llvm/llvm-project/blob/28d85d207fc37b5593c17a25f687c91b7afda5b4/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp#L1653-L1850)
            struct FastEnumeratorHelper {
                state: NSFastEnumerationState,
                buf: [*mut AnyObject; BUF_SIZE],
                current_item: usize,
                items_count: usize,
                /// Track mutation mistakes when debug assertions are enabled (they should
                /// be made impossible by Rust at compile-time, so hence we don't need to
                /// track them in release mode).
                ///
                /// This is set to `None` initially, but later loaded to `Some(_)` after
                /// the first enumeration.
                #[cfg(debug_assertions)]
                mutations_state: Option<c_ulong>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for FastEnumeratorHelper {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "FastEnumeratorHelper",
                        "state",
                        &self.state,
                        "buf",
                        &self.buf,
                        "current_item",
                        &self.current_item,
                        "items_count",
                        &self.items_count,
                        "mutations_state",
                        &&self.mutations_state,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for FastEnumeratorHelper {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for FastEnumeratorHelper {
                #[inline]
                fn eq(&self, other: &FastEnumeratorHelper) -> bool {
                    self.state == other.state && self.buf == other.buf
                        && self.current_item == other.current_item
                        && self.items_count == other.items_count
                        && self.mutations_state == other.mutations_state
                }
            }
            unsafe impl Send for FastEnumeratorHelper {}
            unsafe impl Sync for FastEnumeratorHelper {}
            impl FastEnumeratorHelper {
                #[inline]
                fn new() -> Self {
                    Self {
                        state: NSFastEnumerationState {
                            state: 0,
                            itemsPtr: ptr::null_mut(),
                            mutationsPtr: ptr::null_mut(),
                            extra: [0; 5],
                        },
                        buf: [ptr::null_mut(); BUF_SIZE],
                        current_item: 0,
                        items_count: 0,
                        #[cfg(debug_assertions)]
                        mutations_state: None,
                    }
                }
                #[inline]
                const fn remaining_items_at_least(&self) -> usize {
                    self.items_count - self.current_item
                }
                /// Load the next array of items into the enumeration state.
                ///
                ///
                /// # Safety
                ///
                /// The collection must be the same on each call.
                #[inline]
                #[track_caller]
                unsafe fn load_next_items(
                    &mut self,
                    collection: &ProtocolObject<dyn NSFastEnumeration>,
                ) {
                    let buf_ptr = unsafe {
                        NonNull::new_unchecked(self.buf.as_mut_ptr())
                    };
                    self
                        .items_count = unsafe {
                        collection
                            .countByEnumeratingWithState_objects_count(
                                NonNull::from(&mut self.state),
                                buf_ptr,
                                self.buf.len(),
                            )
                    };
                    #[cfg(debug_assertions)]
                    {
                        if self.items_count > 0 && self.state.itemsPtr.is_null() {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!("`itemsPtr` was NULL"),
                                );
                            };
                        }
                    }
                    self.current_item = 0;
                }
                /// Get the next item from the given collection.
                ///
                /// We use a `ProtocolObject` instead of a generic, so that there is only
                /// one instance of this function in the compilation unit (should improve
                /// compilation speed).
                ///
                ///
                /// # Safety
                ///
                /// The collection must be the same on each call.
                #[inline]
                #[track_caller]
                unsafe fn next_from(
                    &mut self,
                    collection: &ProtocolObject<dyn NSFastEnumeration>,
                ) -> Option<NonNull<AnyObject>> {
                    if self.current_item >= self.items_count {
                        unsafe { self.load_next_items(collection) };
                        if self.items_count == 0 {
                            return None;
                        }
                    }
                    #[cfg(debug_assertions)]
                    {
                        if let Some(ptr) = NonNull::new(self.state.mutationsPtr) {
                            let new_state = unsafe { ptr.as_ptr().read_unaligned() };
                            match self.mutations_state {
                                None => {
                                    self.mutations_state = Some(new_state);
                                }
                                Some(current_state) => {
                                    if current_state != new_state {
                                        {
                                            ::core::panicking::panic_fmt(
                                                format_args!(
                                                    "mutation detected during enumeration. This is undefined behaviour, and must be avoided",
                                                ),
                                            );
                                        };
                                    }
                                }
                            }
                        }
                    }
                    let ptr = unsafe { self.state.itemsPtr.add(self.current_item) };
                    self.current_item += 1;
                    let obj = unsafe { ptr.read_unaligned() };
                    Some(unsafe { NonNull::new_unchecked(obj) })
                }
            }
            /// Internal helper trait to figure out the output type of something that
            /// implements `NSFastEnumeration`.
            ///
            ///
            /// # Safety
            ///
            /// The associated `Item` type must be the type that is used in Objective-C's
            /// `for (type elem in collection) { stmts; }` enumeration, and the collection
            /// itself must not contain any lifetime parameter.
            pub(crate) unsafe trait FastEnumerationHelper: Message + NSFastEnumeration {
                type Item: Message;
                fn maybe_len(&self) -> Option<usize>;
            }
            pub(crate) struct Iter<'a, C: ?Sized + 'a> {
                helper: FastEnumeratorHelper,
                /// 'a and C are covariant.
                collection: &'a C,
            }
            #[automatically_derived]
            impl<'a, C: ::core::fmt::Debug + ?Sized + 'a> ::core::fmt::Debug
            for Iter<'a, C> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Iter",
                        "helper",
                        &self.helper,
                        "collection",
                        &&self.collection,
                    )
                }
            }
            #[automatically_derived]
            impl<'a, C: ?Sized + 'a> ::core::marker::StructuralPartialEq
            for Iter<'a, C> {}
            #[automatically_derived]
            impl<'a, C: ::core::cmp::PartialEq + ?Sized + 'a> ::core::cmp::PartialEq
            for Iter<'a, C> {
                #[inline]
                fn eq(&self, other: &Iter<'a, C>) -> bool {
                    self.helper == other.helper && self.collection == other.collection
                }
            }
            impl<'a, C: ?Sized + FastEnumerationHelper> Iter<'a, C> {
                pub(crate) fn new(collection: &'a C) -> Self {
                    Self {
                        helper: FastEnumeratorHelper::new(),
                        collection,
                    }
                }
            }
            impl<'a, C: FastEnumerationHelper> Iterator for Iter<'a, C> {
                type Item = &'a C::Item;
                #[inline]
                #[track_caller]
                fn next(&mut self) -> Option<&'a C::Item> {
                    let obj = unsafe {
                        self.helper.next_from(ProtocolObject::from_ref(self.collection))?
                    };
                    Some(unsafe { obj.cast::<C::Item>().as_ref() })
                }
                #[inline]
                fn size_hint(&self) -> (usize, Option<usize>) {
                    (self.helper.remaining_items_at_least(), self.collection.maybe_len())
                }
            }
            pub(crate) struct IterMut<'a, C: ?Sized + 'a> {
                helper: FastEnumeratorHelper,
                /// 'a and C are covariant.
                collection: &'a mut C,
            }
            #[automatically_derived]
            impl<'a, C: ::core::fmt::Debug + ?Sized + 'a> ::core::fmt::Debug
            for IterMut<'a, C> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "IterMut",
                        "helper",
                        &self.helper,
                        "collection",
                        &&self.collection,
                    )
                }
            }
            #[automatically_derived]
            impl<'a, C: ?Sized + 'a> ::core::marker::StructuralPartialEq
            for IterMut<'a, C> {}
            #[automatically_derived]
            impl<'a, C: ::core::cmp::PartialEq + ?Sized + 'a> ::core::cmp::PartialEq
            for IterMut<'a, C> {
                #[inline]
                fn eq(&self, other: &IterMut<'a, C>) -> bool {
                    self.helper == other.helper && self.collection == other.collection
                }
            }
            impl<'a, C: ?Sized + FastEnumerationHelper> IterMut<'a, C>
            where
                C::Item: IsMutable,
            {
                pub(crate) fn new(collection: &'a mut C) -> Self {
                    Self {
                        helper: FastEnumeratorHelper::new(),
                        collection,
                    }
                }
            }
            impl<'a, C: FastEnumerationHelper> Iterator for IterMut<'a, C>
            where
                C::Item: IsMutable,
            {
                type Item = &'a mut C::Item;
                #[inline]
                #[track_caller]
                fn next(&mut self) -> Option<&'a mut C::Item> {
                    let obj = unsafe {
                        self.helper.next_from(ProtocolObject::from_mut(self.collection))?
                    };
                    Some(unsafe { obj.cast::<C::Item>().as_mut() })
                }
                #[inline]
                fn size_hint(&self) -> (usize, Option<usize>) {
                    (self.helper.remaining_items_at_least(), self.collection.maybe_len())
                }
            }
            pub(crate) struct IterRetained<'a, C: ?Sized + 'a> {
                inner: Iter<'a, C>,
            }
            #[automatically_derived]
            impl<'a, C: ::core::fmt::Debug + ?Sized + 'a> ::core::fmt::Debug
            for IterRetained<'a, C> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "IterRetained",
                        "inner",
                        &&self.inner,
                    )
                }
            }
            #[automatically_derived]
            impl<'a, C: ?Sized + 'a> ::core::marker::StructuralPartialEq
            for IterRetained<'a, C> {}
            #[automatically_derived]
            impl<'a, C: ::core::cmp::PartialEq + ?Sized + 'a> ::core::cmp::PartialEq
            for IterRetained<'a, C> {
                #[inline]
                fn eq(&self, other: &IterRetained<'a, C>) -> bool {
                    self.inner == other.inner
                }
            }
            impl<'a, C: ?Sized + FastEnumerationHelper> IterRetained<'a, C>
            where
                C::Item: IsIdCloneable,
            {
                pub(crate) fn new(collection: &'a C) -> Self {
                    Self {
                        inner: Iter::new(collection),
                    }
                }
            }
            impl<'a, C: FastEnumerationHelper> Iterator for IterRetained<'a, C>
            where
                C::Item: IsIdCloneable,
            {
                type Item = Id<C::Item>;
                #[inline]
                #[track_caller]
                fn next(&mut self) -> Option<Id<C::Item>> {
                    let obj = self.inner.next()?;
                    Some(unsafe { util::collection_retain_id(obj) })
                }
                #[inline]
                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.inner.size_hint()
                }
            }
            pub(crate) struct IntoIter<C: ?Sized> {
                helper: FastEnumeratorHelper,
                /// C is covariant.
                collection: Id<C>,
            }
            #[automatically_derived]
            impl<C: ::core::fmt::Debug + ?Sized> ::core::fmt::Debug for IntoIter<C> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "IntoIter",
                        "helper",
                        &self.helper,
                        "collection",
                        &&self.collection,
                    )
                }
            }
            #[automatically_derived]
            impl<C: ?Sized> ::core::marker::StructuralPartialEq for IntoIter<C> {}
            #[automatically_derived]
            impl<C: ::core::cmp::PartialEq + ?Sized> ::core::cmp::PartialEq
            for IntoIter<C> {
                #[inline]
                fn eq(&self, other: &IntoIter<C>) -> bool {
                    self.helper == other.helper && self.collection == other.collection
                }
            }
            impl<C: FastEnumerationHelper> IntoIter<C> {
                pub(crate) fn new_immutable(collection: Id<C>) -> Self
                where
                    C: IsIdCloneable,
                    C::Item: IsIdCloneable,
                {
                    Self {
                        helper: FastEnumeratorHelper::new(),
                        collection,
                    }
                }
                pub(crate) fn new_mutable<T: ClassType<Super = C> + IsMutable>(
                    collection: Id<T>,
                ) -> Self
                where
                    C: IsIdCloneable,
                {
                    Self {
                        helper: FastEnumeratorHelper::new(),
                        collection: unsafe { Id::cast(collection) },
                    }
                }
                pub(crate) fn new(collection: Id<C>) -> Self
                where
                    C: IsMutable,
                {
                    Self {
                        helper: FastEnumeratorHelper::new(),
                        collection,
                    }
                }
            }
            impl<C: FastEnumerationHelper> Iterator for IntoIter<C> {
                type Item = Id<C::Item>;
                #[inline]
                #[track_caller]
                fn next(&mut self) -> Option<Id<C::Item>> {
                    let collection = ProtocolObject::from_ref(&*self.collection);
                    let obj = unsafe { self.helper.next_from(collection)? };
                    let obj = unsafe { Id::retain(obj.cast::<C::Item>().as_ptr()) };
                    Some(unsafe { obj.unwrap_unchecked() })
                }
                #[inline]
                fn size_hint(&self) -> (usize, Option<usize>) {
                    (self.helper.remaining_items_at_least(), self.collection.maybe_len())
                }
            }
            pub(crate) struct IterWithBackingEnum<'a, C: ?Sized + 'a, E: ?Sized + 'a> {
                helper: FastEnumeratorHelper,
                /// 'a and C are covariant.
                collection: &'a C,
                /// E is covariant.
                enumerator: Id<E>,
            }
            #[automatically_derived]
            impl<
                'a,
                C: ::core::fmt::Debug + ?Sized + 'a,
                E: ::core::fmt::Debug + ?Sized + 'a,
            > ::core::fmt::Debug for IterWithBackingEnum<'a, C, E> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "IterWithBackingEnum",
                        "helper",
                        &self.helper,
                        "collection",
                        &self.collection,
                        "enumerator",
                        &&self.enumerator,
                    )
                }
            }
            #[automatically_derived]
            impl<'a, C: ?Sized + 'a, E: ?Sized + 'a> ::core::marker::StructuralPartialEq
            for IterWithBackingEnum<'a, C, E> {}
            #[automatically_derived]
            impl<
                'a,
                C: ::core::cmp::PartialEq + ?Sized + 'a,
                E: ::core::cmp::PartialEq + ?Sized + 'a,
            > ::core::cmp::PartialEq for IterWithBackingEnum<'a, C, E> {
                #[inline]
                fn eq(&self, other: &IterWithBackingEnum<'a, C, E>) -> bool {
                    self.helper == other.helper && self.collection == other.collection
                        && self.enumerator == other.enumerator
                }
            }
            impl<'a, C, E> IterWithBackingEnum<'a, C, E>
            where
                C: ?Sized + FastEnumerationHelper,
                E: ?Sized + FastEnumerationHelper,
            {
                pub(crate) unsafe fn new(collection: &'a C, enumerator: Id<E>) -> Self {
                    Self {
                        helper: FastEnumeratorHelper::new(),
                        collection,
                        enumerator,
                    }
                }
            }
            impl<'a, C, E> Iterator for IterWithBackingEnum<'a, C, E>
            where
                C: ?Sized + FastEnumerationHelper,
                E: FastEnumerationHelper,
            {
                type Item = &'a E::Item;
                #[inline]
                #[track_caller]
                fn next(&mut self) -> Option<&'a E::Item> {
                    let obj = unsafe {
                        self.helper
                            .next_from(ProtocolObject::from_ref(&*self.enumerator))?
                    };
                    Some(unsafe { obj.cast::<E::Item>().as_ref() })
                }
                #[inline]
                fn size_hint(&self) -> (usize, Option<usize>) {
                    (self.helper.remaining_items_at_least(), self.collection.maybe_len())
                }
            }
            pub(crate) struct IterMutWithBackingEnum<
                'a,
                C: ?Sized + 'a,
                E: ?Sized + 'a,
            > {
                helper: FastEnumeratorHelper,
                /// 'a and C are covariant.
                collection: &'a mut C,
                /// E is covariant.
                enumerator: Id<E>,
            }
            #[automatically_derived]
            impl<
                'a,
                C: ::core::fmt::Debug + ?Sized + 'a,
                E: ::core::fmt::Debug + ?Sized + 'a,
            > ::core::fmt::Debug for IterMutWithBackingEnum<'a, C, E> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "IterMutWithBackingEnum",
                        "helper",
                        &self.helper,
                        "collection",
                        &self.collection,
                        "enumerator",
                        &&self.enumerator,
                    )
                }
            }
            #[automatically_derived]
            impl<'a, C: ?Sized + 'a, E: ?Sized + 'a> ::core::marker::StructuralPartialEq
            for IterMutWithBackingEnum<'a, C, E> {}
            #[automatically_derived]
            impl<
                'a,
                C: ::core::cmp::PartialEq + ?Sized + 'a,
                E: ::core::cmp::PartialEq + ?Sized + 'a,
            > ::core::cmp::PartialEq for IterMutWithBackingEnum<'a, C, E> {
                #[inline]
                fn eq(&self, other: &IterMutWithBackingEnum<'a, C, E>) -> bool {
                    self.helper == other.helper && self.collection == other.collection
                        && self.enumerator == other.enumerator
                }
            }
            impl<'a, C, E> IterMutWithBackingEnum<'a, C, E>
            where
                C: ?Sized + FastEnumerationHelper,
                E: ?Sized + FastEnumerationHelper + IsMutable,
                E::Item: IsMutable,
            {
                pub(crate) unsafe fn new(
                    collection: &'a mut C,
                    enumerator: Id<E>,
                ) -> Self {
                    Self {
                        helper: FastEnumeratorHelper::new(),
                        collection,
                        enumerator,
                    }
                }
            }
            impl<'a, C, E> Iterator for IterMutWithBackingEnum<'a, C, E>
            where
                C: ?Sized + FastEnumerationHelper,
                E: FastEnumerationHelper + IsMutable,
                E::Item: IsMutable,
            {
                type Item = &'a mut E::Item;
                #[inline]
                #[track_caller]
                fn next(&mut self) -> Option<&'a mut E::Item> {
                    let obj = unsafe {
                        self.helper
                            .next_from(ProtocolObject::from_mut(&mut *self.enumerator))?
                    };
                    Some(unsafe { obj.cast::<E::Item>().as_mut() })
                }
                #[inline]
                fn size_hint(&self) -> (usize, Option<usize>) {
                    (self.helper.remaining_items_at_least(), self.collection.maybe_len())
                }
            }
            pub(crate) struct IterRetainedWithBackingEnum<
                'a,
                C: ?Sized + 'a,
                E: ?Sized + 'a,
            > {
                inner: IterWithBackingEnum<'a, C, E>,
            }
            #[automatically_derived]
            impl<
                'a,
                C: ::core::fmt::Debug + ?Sized + 'a,
                E: ::core::fmt::Debug + ?Sized + 'a,
            > ::core::fmt::Debug for IterRetainedWithBackingEnum<'a, C, E> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "IterRetainedWithBackingEnum",
                        "inner",
                        &&self.inner,
                    )
                }
            }
            #[automatically_derived]
            impl<'a, C: ?Sized + 'a, E: ?Sized + 'a> ::core::marker::StructuralPartialEq
            for IterRetainedWithBackingEnum<'a, C, E> {}
            #[automatically_derived]
            impl<
                'a,
                C: ::core::cmp::PartialEq + ?Sized + 'a,
                E: ::core::cmp::PartialEq + ?Sized + 'a,
            > ::core::cmp::PartialEq for IterRetainedWithBackingEnum<'a, C, E> {
                #[inline]
                fn eq(&self, other: &IterRetainedWithBackingEnum<'a, C, E>) -> bool {
                    self.inner == other.inner
                }
            }
            impl<'a, C, E> IterRetainedWithBackingEnum<'a, C, E>
            where
                C: ?Sized + FastEnumerationHelper,
                E: ?Sized + FastEnumerationHelper,
                E::Item: IsIdCloneable,
            {
                pub(crate) unsafe fn new(collection: &'a C, enumerator: Id<E>) -> Self {
                    let inner = unsafe {
                        IterWithBackingEnum::new(collection, enumerator)
                    };
                    Self { inner }
                }
            }
            impl<'a, C, E> Iterator for IterRetainedWithBackingEnum<'a, C, E>
            where
                C: ?Sized + FastEnumerationHelper,
                E: FastEnumerationHelper,
                E::Item: IsIdCloneable,
            {
                type Item = Id<E::Item>;
                #[inline]
                #[track_caller]
                fn next(&mut self) -> Option<Id<E::Item>> {
                    let obj = self.inner.next()?;
                    Some(unsafe { util::collection_retain_id(obj) })
                }
                #[inline]
                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.inner.size_hint()
                }
            }
            pub(crate) struct IntoIterWithBackingEnum<C: ?Sized, E: ?Sized> {
                helper: FastEnumeratorHelper,
                /// C is covariant.
                collection: Id<C>,
                /// E is covariant.
                enumerator: Id<E>,
            }
            #[automatically_derived]
            impl<
                C: ::core::fmt::Debug + ?Sized,
                E: ::core::fmt::Debug + ?Sized,
            > ::core::fmt::Debug for IntoIterWithBackingEnum<C, E> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "IntoIterWithBackingEnum",
                        "helper",
                        &self.helper,
                        "collection",
                        &self.collection,
                        "enumerator",
                        &&self.enumerator,
                    )
                }
            }
            #[automatically_derived]
            impl<C: ?Sized, E: ?Sized> ::core::marker::StructuralPartialEq
            for IntoIterWithBackingEnum<C, E> {}
            #[automatically_derived]
            impl<
                C: ::core::cmp::PartialEq + ?Sized,
                E: ::core::cmp::PartialEq + ?Sized,
            > ::core::cmp::PartialEq for IntoIterWithBackingEnum<C, E> {
                #[inline]
                fn eq(&self, other: &IntoIterWithBackingEnum<C, E>) -> bool {
                    self.helper == other.helper && self.collection == other.collection
                        && self.enumerator == other.enumerator
                }
            }
            impl<C, E> IntoIterWithBackingEnum<C, E>
            where
                C: FastEnumerationHelper,
                E: ?Sized + FastEnumerationHelper,
            {
                pub(crate) unsafe fn new_immutable(
                    collection: Id<C>,
                    enumerator: Id<E>,
                ) -> Self
                where
                    C: IsIdCloneable,
                    E::Item: IsIdCloneable,
                {
                    Self {
                        helper: FastEnumeratorHelper::new(),
                        collection,
                        enumerator,
                    }
                }
                pub(crate) unsafe fn new_mutable<T: ClassType<Super = C> + IsMutable>(
                    collection: Id<T>,
                    enumerator: Id<E>,
                ) -> Self
                where
                    C: IsIdCloneable,
                {
                    Self {
                        collection: unsafe { Id::cast(collection) },
                        enumerator,
                        helper: FastEnumeratorHelper::new(),
                    }
                }
            }
            impl<C, E> Iterator for IntoIterWithBackingEnum<C, E>
            where
                C: ?Sized + FastEnumerationHelper,
                E: FastEnumerationHelper,
            {
                type Item = Id<E::Item>;
                #[inline]
                #[track_caller]
                fn next(&mut self) -> Option<Id<E::Item>> {
                    let enumerator = ProtocolObject::from_ref(&*self.enumerator);
                    let obj = unsafe { self.helper.next_from(enumerator)? };
                    let obj = unsafe { Id::retain(obj.cast::<E::Item>().as_ptr()) };
                    Some(unsafe { obj.unwrap_unchecked() })
                }
                #[inline]
                fn size_hint(&self) -> (usize, Option<usize>) {
                    (self.helper.remaining_items_at_least(), self.collection.maybe_len())
                }
            }
        }
        mod comparison_result {
            use core::cmp::Ordering;
            use objc2::encode::{Encode, Encoding, RefEncode};
            /// Constants that indicate sort order.
            ///
            /// See [Apple's documentation](https://developer.apple.com/documentation/foundation/nscomparisonresult?language=objc).
            #[repr(isize)]
            pub enum NSComparisonResult {
                /// The left operand is smaller than the right operand.
                Ascending = -1,
                /// The two operands are equal.
                Same = 0,
                /// The left operand is greater than the right operand.
                Descending = 1,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for NSComparisonResult {
                #[inline]
                fn clone(&self) -> NSComparisonResult {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSComparisonResult {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSComparisonResult {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            NSComparisonResult::Ascending => "Ascending",
                            NSComparisonResult::Same => "Same",
                            NSComparisonResult::Descending => "Descending",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSComparisonResult {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSComparisonResult {
                #[inline]
                fn eq(&self, other: &NSComparisonResult) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSComparisonResult {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSComparisonResult {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSComparisonResult {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSComparisonResult {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSComparisonResult,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSComparisonResult {
                #[inline]
                fn cmp(&self, other: &NSComparisonResult) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
                }
            }
            impl Default for NSComparisonResult {
                #[inline]
                fn default() -> Self {
                    Self::Same
                }
            }
            unsafe impl Encode for NSComparisonResult {
                const ENCODING: Encoding = isize::ENCODING;
            }
            unsafe impl RefEncode for NSComparisonResult {
                const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
            }
            impl From<Ordering> for NSComparisonResult {
                #[inline]
                fn from(order: Ordering) -> Self {
                    match order {
                        Ordering::Less => Self::Ascending,
                        Ordering::Equal => Self::Same,
                        Ordering::Greater => Self::Descending,
                    }
                }
            }
            impl From<NSComparisonResult> for Ordering {
                #[inline]
                fn from(comparison_result: NSComparisonResult) -> Self {
                    match comparison_result {
                        NSComparisonResult::Ascending => Self::Less,
                        NSComparisonResult::Same => Self::Equal,
                        NSComparisonResult::Descending => Self::Greater,
                    }
                }
            }
        }
        mod copying {
            use objc2::mutability::CounterpartOrSelf;
            use objc2::rc::Id;
            use objc2::runtime::NSZone;
            use objc2::{extern_protocol, ProtocolType};
            /// A protocol to provide functional copies of objects.
            ///
            /// This is similar to Rust's [`Clone`] trait, along with sharing a few
            /// similarities to the [`std::borrow::ToOwned`] trait with regards to the
            /// output type.
            ///
            /// See [Apple's documentation][apple-doc] for details.
            ///
            /// [apple-doc]: https://developer.apple.com/documentation/foundation/nscopying
            #[allow(clippy::missing_safety_doc)]
            pub unsafe trait NSCopying {
                /// Returns a new instance that's a copy of the receiver.
                ///
                /// The output type is the immutable counterpart of the object, which is
                /// usually `Self`, but e.g. `NSMutableString` returns `NSString`.
                fn copy(&self) -> Id<Self::Immutable>
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                    Self: CounterpartOrSelf,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            const __SELECTOR_DATA: &::objc2::__macro_helpers::str = "copy\u{0}";
                            let result;
                            result = <::objc2::__macro_helpers::RetainSemantics<
                                {
                                    ::objc2::__macro_helpers::retain_semantics(__SELECTOR_DATA)
                                },
                            > as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                    #[allow(unused_unsafe)]
                                    unsafe { CACHED_SEL.get(__SELECTOR_DATA) }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                /// Returns a new instance that's a copy of the receiver.
                ///
                /// This is only used when implementing `NSCopying`, use
                /// [`copy`][NSCopying::copy] instead.
                ///
                ///
                /// # Safety
                ///
                /// The zone pointer must be valid or NULL.
                unsafe fn copyWithZone(&self, zone: *mut NSZone) -> Id<Self::Immutable>
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                    Self: CounterpartOrSelf,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            const __SELECTOR_DATA: &::objc2::__macro_helpers::str = "copyWithZone:\u{0}";
                            let result;
                            result = <::objc2::__macro_helpers::RetainSemantics<
                                {
                                    ::objc2::__macro_helpers::retain_semantics(__SELECTOR_DATA)
                                },
                            > as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                    #[allow(unused_unsafe)]
                                    unsafe { CACHED_SEL.get(__SELECTOR_DATA) }
                                },
                                (zone,),
                            );
                            result
                        }
                    }
                }
            }
            unsafe impl<T> NSCopying for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSCopying,
            {}
            unsafe impl ProtocolType for dyn NSCopying {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSCopying";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T> for dyn NSCopying
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message + NSCopying,
            {
                const __INNER: () = ();
            }
            /// A protocol to provide mutable copies of objects.
            ///
            /// Only classes that have an “immutable vs. mutable” distinction should adopt
            /// this protocol.
            ///
            /// See [Apple's documentation][apple-doc] for details.
            ///
            /// [apple-doc]: https://developer.apple.com/documentation/foundation/nsmutablecopying
            #[allow(clippy::missing_safety_doc)]
            pub unsafe trait NSMutableCopying {
                /// Returns a new instance that's a mutable copy of the receiver.
                ///
                /// The output type is the mutable counterpart of the object. E.g. both
                /// `NSString` and `NSMutableString` return `NSMutableString`.
                fn mutableCopy(&self) -> Id<Self::Mutable>
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                    Self: CounterpartOrSelf,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            const __SELECTOR_DATA: &::objc2::__macro_helpers::str = "mutableCopy\u{0}";
                            let result;
                            result = <::objc2::__macro_helpers::RetainSemantics<
                                {
                                    ::objc2::__macro_helpers::retain_semantics(__SELECTOR_DATA)
                                },
                            > as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                    #[allow(unused_unsafe)]
                                    unsafe { CACHED_SEL.get(__SELECTOR_DATA) }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                /// Returns a new instance that's a mutable copy of the receiver.
                ///
                /// This is only used when implementing `NSMutableCopying`, use
                /// [`mutableCopy`][NSMutableCopying::mutableCopy] instead.
                ///
                ///
                /// # Safety
                ///
                /// The zone pointer must be valid or NULL.
                unsafe fn mutableCopyWithZone(
                    &self,
                    zone: *mut NSZone,
                ) -> Id<Self::Mutable>
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                    Self: CounterpartOrSelf,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            const __SELECTOR_DATA: &::objc2::__macro_helpers::str = "mutableCopyWithZone:\u{0}";
                            let result;
                            result = <::objc2::__macro_helpers::RetainSemantics<
                                {
                                    ::objc2::__macro_helpers::retain_semantics(__SELECTOR_DATA)
                                },
                            > as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                    #[allow(unused_unsafe)]
                                    unsafe { CACHED_SEL.get(__SELECTOR_DATA) }
                                },
                                (zone,),
                            );
                            result
                        }
                    }
                }
            }
            unsafe impl<T> NSMutableCopying for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSMutableCopying,
            {}
            unsafe impl ProtocolType for dyn NSMutableCopying {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSMutableCopying";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T> for dyn NSMutableCopying
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSMutableCopying,
            {
                const __INNER: () = ();
            }
        }
        mod debug {
            #![allow(unused_imports)]
            use core::fmt;
            use crate::common::*;
            use crate::Foundation;
        }
        mod decimal {
            use crate::common::*;
            #[repr(C)]
            pub struct NSDecimal {
                _inner: i32,
                _mantissa: [c_ushort; 8],
            }
            #[automatically_derived]
            impl ::core::clone::Clone for NSDecimal {
                #[inline]
                fn clone(&self) -> NSDecimal {
                    let _: ::core::clone::AssertParamIsClone<i32>;
                    let _: ::core::clone::AssertParamIsClone<[c_ushort; 8]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSDecimal {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSDecimal {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "NSDecimal",
                        "_inner",
                        &self._inner,
                        "_mantissa",
                        &&self._mantissa,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSDecimal {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSDecimal {
                #[inline]
                fn eq(&self, other: &NSDecimal) -> bool {
                    self._inner == other._inner && self._mantissa == other._mantissa
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSDecimal {
                const ENCODING: objc2::Encoding = objc2::Encoding::Struct(
                    "NSDecimal",
                    &[
                        <i32 as objc2::Encode>::ENCODING,
                        <[c_ushort; 8] as objc2::Encode>::ENCODING,
                    ],
                );
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSDecimal {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
        }
        pub mod dictionary {
            //! Utilities for the `NSDictionary` and `NSMutableDictionary` classes.
            #![cfg(feature = "Foundation_NSDictionary")]
            use alloc::vec::Vec;
            use core::cmp::min;
            use core::fmt;
            use core::hash::Hash;
            use core::mem;
            use core::ops::{Index, IndexMut};
            use core::ptr::{self, NonNull};
            use objc2::mutability::{
                CounterpartOrSelf, HasStableHash, IsIdCloneable, IsMutable, IsRetainable,
            };
            use super::iter;
            use super::util;
            use crate::common::*;
            use crate::Foundation::{NSCopying, NSDictionary};
            fn keys_to_ptr<Q>(keys: &[&Q]) -> *mut NonNull<ProtocolObject<dyn NSCopying>>
            where
                Q: Message + NSCopying,
            {
                let keys: *mut NonNull<Q> = util::ref_ptr_cast_const(keys.as_ptr());
                let keys: *mut NonNull<ProtocolObject<dyn NSCopying>> = keys.cast();
                keys
            }
            impl<K: Message + Eq + Hash + HasStableHash, V: Message> NSDictionary<K, V> {
                pub fn from_vec<Q>(keys: &[&Q], mut objects: Vec<Id<V>>) -> Id<Self>
                where
                    Q: Message + NSCopying + CounterpartOrSelf<Immutable = K>,
                {
                    let count = min(keys.len(), objects.len());
                    let keys = keys_to_ptr(keys);
                    let objects = util::id_ptr_cast(objects.as_mut_ptr());
                    unsafe {
                        Self::initWithObjects_forKeys_count(
                            Self::alloc(),
                            objects,
                            keys,
                            count,
                        )
                    }
                }
                pub fn from_id_slice<Q>(keys: &[&Q], objects: &[Id<V>]) -> Id<Self>
                where
                    Q: Message + NSCopying + CounterpartOrSelf<Immutable = K>,
                    V: IsIdCloneable,
                {
                    let count = min(keys.len(), objects.len());
                    let keys = keys_to_ptr(keys);
                    let objects = util::id_ptr_cast_const(objects.as_ptr());
                    unsafe {
                        Self::initWithObjects_forKeys_count(
                            Self::alloc(),
                            objects,
                            keys,
                            count,
                        )
                    }
                }
                pub fn from_slice<Q>(keys: &[&Q], objects: &[&V]) -> Id<Self>
                where
                    Q: Message + NSCopying + CounterpartOrSelf<Immutable = K>,
                    V: IsRetainable,
                {
                    let count = min(keys.len(), objects.len());
                    let keys = keys_to_ptr(keys);
                    let objects = util::ref_ptr_cast_const(objects.as_ptr());
                    unsafe {
                        Self::initWithObjects_forKeys_count(
                            Self::alloc(),
                            objects,
                            keys,
                            count,
                        )
                    }
                }
            }
            impl<K: Message + Eq + Hash, V: Message> NSDictionary<K, V> {
                #[doc(alias = "objectForKey:")]
                pub fn get(&self, key: &K) -> Option<&V> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("objectForKey:\u{0}") }
                                    }
                                },
                                (key,),
                            );
                            result
                        }
                    }
                }
                #[doc(alias = "objectForKey:")]
                pub fn get_retained(&self, key: &K) -> Option<Id<V>>
                where
                    V: IsIdCloneable,
                {
                    self.get(key).map(|obj| unsafe { util::collection_retain_id(obj) })
                }
                /// Returns a mutable reference to the value corresponding to the key.
                ///
                /// # Examples
                ///
                ///```ignore
                /// use icrate::Foundation::{ns_string, NSMutableDictionary, NSMutableString, NSString};
                ///
                /// let mut dict = NSMutableDictionary::new();
                /// dict.insert_id(ns_string!("one"), NSMutableString::new());
                /// println!("{:?}", dict.get_mut(ns_string!("one")));
                /// ```
                #[doc(alias = "objectForKey:")]
                pub fn get_mut(&mut self, key: &K) -> Option<&mut V>
                where
                    V: IsMutable,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("objectForKey:\u{0}") }
                                    }
                                },
                                (key,),
                            );
                            result
                        }
                    }
                }
            }
            impl<K: Message, V: Message> NSDictionary<K, V> {
                pub fn len(&self) -> usize {
                    self.count()
                }
                pub fn is_empty(&self) -> bool {
                    self.len() == 0
                }
                #[doc(alias = "getObjects:andKeys:")]
                pub fn keys_vec(&self) -> Vec<&K> {
                    let len = self.len();
                    let mut keys: Vec<NonNull<K>> = Vec::with_capacity(len);
                    unsafe {
                        #[allow(deprecated)]
                        self.getObjects_andKeys(ptr::null_mut(), keys.as_mut_ptr());
                        keys.set_len(len);
                        mem::transmute(keys)
                    }
                }
                #[doc(alias = "getObjects:andKeys:")]
                pub fn values_vec(&self) -> Vec<&V> {
                    let len = self.len();
                    let mut vals: Vec<NonNull<V>> = Vec::with_capacity(len);
                    unsafe {
                        #[allow(deprecated)]
                        self.getObjects_andKeys(vals.as_mut_ptr(), ptr::null_mut());
                        vals.set_len(len);
                        mem::transmute(vals)
                    }
                }
                /// Returns a vector of mutable references to the values in the dictionary.
                ///
                /// # Examples
                ///
                ///```ignore
                /// use icrate::Foundation::{ns_string, NSMutableDictionary, NSMutableString, NSString};
                ///
                /// let mut dict = NSMutableDictionary::new();
                /// dict.insert_id(ns_string!("one"), NSMutableString::from_str("two"));
                /// for val in dict.values_mut() {
                ///     println!("{:?}", val);
                /// }
                /// ```
                #[doc(alias = "getObjects:andKeys:")]
                pub fn values_vec_mut(&mut self) -> Vec<&mut V>
                where
                    V: IsMutable,
                {
                    let len = self.len();
                    let mut vals: Vec<NonNull<V>> = Vec::with_capacity(len);
                    unsafe {
                        #[allow(deprecated)]
                        self.getObjects_andKeys(vals.as_mut_ptr(), ptr::null_mut());
                        vals.set_len(len);
                        mem::transmute(vals)
                    }
                }
                #[doc(alias = "getObjects:andKeys:")]
                pub fn to_vecs(&self) -> (Vec<&K>, Vec<&V>) {
                    let len = self.len();
                    let mut keys: Vec<NonNull<K>> = Vec::with_capacity(len);
                    let mut objs: Vec<NonNull<V>> = Vec::with_capacity(len);
                    unsafe {
                        #[allow(deprecated)]
                        self.getObjects_andKeys(objs.as_mut_ptr(), keys.as_mut_ptr());
                        keys.set_len(len);
                        objs.set_len(len);
                        (mem::transmute(keys), mem::transmute(objs))
                    }
                }
            }
            impl<K: Message, V: Message> NSDictionary<K, V> {
                #[doc(alias = "keyEnumerator")]
                #[cfg(feature = "Foundation_NSEnumerator")]
                pub fn keys(&self) -> Keys<'_, K, V> {
                    Keys(iter::Iter::new(self))
                }
                #[doc(alias = "keyEnumerator")]
                #[cfg(feature = "Foundation_NSEnumerator")]
                pub fn keys_retained(&self) -> KeysRetained<'_, K, V>
                where
                    K: IsIdCloneable,
                {
                    KeysRetained(iter::IterRetained::new(self))
                }
                #[doc(alias = "objectEnumerator")]
                #[cfg(feature = "Foundation_NSEnumerator")]
                pub fn values(&self) -> Values<'_, K, V> {
                    let enumerator = unsafe { self.objectEnumerator() };
                    Values(unsafe { iter::IterWithBackingEnum::new(self, enumerator) })
                }
                #[doc(alias = "objectEnumerator")]
                #[cfg(feature = "Foundation_NSEnumerator")]
                pub fn values_mut(&mut self) -> ValuesMut<'_, K, V>
                where
                    V: IsMutable,
                {
                    let enumerator = unsafe { self.objectEnumerator() };
                    ValuesMut(unsafe {
                        iter::IterMutWithBackingEnum::new(self, enumerator)
                    })
                }
                #[doc(alias = "objectEnumerator")]
                #[cfg(feature = "Foundation_NSEnumerator")]
                pub fn values_retained(&self) -> ValuesRetained<'_, K, V>
                where
                    V: IsIdCloneable,
                {
                    let enumerator = unsafe { self.objectEnumerator() };
                    ValuesRetained(unsafe {
                        iter::IterRetainedWithBackingEnum::new(self, enumerator)
                    })
                }
                #[doc(alias = "objectEnumerator")]
                #[cfg(feature = "Foundation_NSEnumerator")]
                pub fn into_values(this: Id<Self>) -> IntoValues<K, V>
                where
                    V: IsIdCloneable,
                {
                    let enumerator = unsafe { this.objectEnumerator() };
                    IntoValues(unsafe {
                        iter::IntoIterWithBackingEnum::new_immutable(this, enumerator)
                    })
                }
            }
            unsafe impl<K: Message, V: Message> iter::FastEnumerationHelper
            for NSDictionary<K, V> {
                type Item = K;
                #[inline]
                fn maybe_len(&self) -> Option<usize> {
                    Some(self.len())
                }
            }
            #[cfg(feature = "Foundation_NSEnumerator")]
            mod iter_helpers {
                use super::*;
                use crate::Foundation::NSEnumerator;
                /// An iterator over the keys of a `NSDictionary`.
                pub struct Keys<'a, K: Message, V: Message>(
                    pub(super) iter::Iter<'a, NSDictionary<K, V>>,
                );
                #[automatically_derived]
                impl<
                    'a,
                    K: ::core::fmt::Debug + Message,
                    V: ::core::fmt::Debug + Message,
                > ::core::fmt::Debug for Keys<'a, K, V> {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Keys",
                            &&self.0,
                        )
                    }
                }
                impl<'a, K: Message, V: Message> Iterator for Keys<'a, K, V> {
                    type Item = &'a K;
                    #[inline]
                    #[track_caller]
                    fn next(&mut self) -> Option<Self::Item> {
                        self.0.next()
                    }
                    #[inline]
                    fn size_hint(&self) -> (usize, Option<usize>) {
                        self.0.size_hint()
                    }
                }
                /// An iterator that retains the keys of a `NSDictionary`.
                pub struct KeysRetained<'a, K: Message, V: Message>(
                    pub(super) iter::IterRetained<'a, NSDictionary<K, V>>,
                );
                #[automatically_derived]
                impl<
                    'a,
                    K: ::core::fmt::Debug + Message,
                    V: ::core::fmt::Debug + Message,
                > ::core::fmt::Debug for KeysRetained<'a, K, V> {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "KeysRetained",
                            &&self.0,
                        )
                    }
                }
                impl<'a, K: Message + IsIdCloneable, V: Message> Iterator
                for KeysRetained<'a, K, V> {
                    type Item = Id<K>;
                    #[inline]
                    #[track_caller]
                    fn next(&mut self) -> Option<Self::Item> {
                        self.0.next()
                    }
                    #[inline]
                    fn size_hint(&self) -> (usize, Option<usize>) {
                        self.0.size_hint()
                    }
                }
                /// An iterator over the values of a `NSDictionary`.
                pub struct Values<'a, K: Message, V: Message>(
                    pub(super) iter::IterWithBackingEnum<
                        'a,
                        NSDictionary<K, V>,
                        NSEnumerator<V>,
                    >,
                );
                #[automatically_derived]
                impl<
                    'a,
                    K: ::core::fmt::Debug + Message,
                    V: ::core::fmt::Debug + Message,
                > ::core::fmt::Debug for Values<'a, K, V> {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Values",
                            &&self.0,
                        )
                    }
                }
                impl<'a, K: Message, V: Message> Iterator for Values<'a, K, V> {
                    type Item = &'a V;
                    #[inline]
                    #[track_caller]
                    fn next(&mut self) -> Option<Self::Item> {
                        self.0.next()
                    }
                    #[inline]
                    fn size_hint(&self) -> (usize, Option<usize>) {
                        self.0.size_hint()
                    }
                }
                /// A mutable iterator over the values of a `NSDictionary`.
                pub struct ValuesMut<'a, K: Message, V: Message>(
                    pub(super) iter::IterMutWithBackingEnum<
                        'a,
                        NSDictionary<K, V>,
                        NSEnumerator<V>,
                    >,
                );
                #[automatically_derived]
                impl<
                    'a,
                    K: ::core::fmt::Debug + Message,
                    V: ::core::fmt::Debug + Message,
                > ::core::fmt::Debug for ValuesMut<'a, K, V> {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "ValuesMut",
                            &&self.0,
                        )
                    }
                }
                impl<'a, K: Message, V: Message + IsMutable> Iterator
                for ValuesMut<'a, K, V> {
                    type Item = &'a mut V;
                    #[inline]
                    #[track_caller]
                    fn next(&mut self) -> Option<Self::Item> {
                        self.0.next()
                    }
                    #[inline]
                    fn size_hint(&self) -> (usize, Option<usize>) {
                        self.0.size_hint()
                    }
                }
                /// A iterator that retains the values of a `NSDictionary`.
                pub struct ValuesRetained<'a, K: Message, V: Message>(
                    pub(super) iter::IterRetainedWithBackingEnum<
                        'a,
                        NSDictionary<K, V>,
                        NSEnumerator<V>,
                    >,
                );
                #[automatically_derived]
                impl<
                    'a,
                    K: ::core::fmt::Debug + Message,
                    V: ::core::fmt::Debug + Message,
                > ::core::fmt::Debug for ValuesRetained<'a, K, V> {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "ValuesRetained",
                            &&self.0,
                        )
                    }
                }
                impl<'a, K: Message, V: Message + IsIdCloneable> Iterator
                for ValuesRetained<'a, K, V> {
                    type Item = Id<V>;
                    #[inline]
                    #[track_caller]
                    fn next(&mut self) -> Option<Self::Item> {
                        self.0.next()
                    }
                    #[inline]
                    fn size_hint(&self) -> (usize, Option<usize>) {
                        self.0.size_hint()
                    }
                }
                /// A consuming iterator over the values of a `NSDictionary`.
                pub struct IntoValues<K: Message, V: Message>(
                    pub(super) iter::IntoIterWithBackingEnum<
                        NSDictionary<K, V>,
                        NSEnumerator<V>,
                    >,
                );
                #[automatically_derived]
                impl<
                    K: ::core::fmt::Debug + Message,
                    V: ::core::fmt::Debug + Message,
                > ::core::fmt::Debug for IntoValues<K, V> {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "IntoValues",
                            &&self.0,
                        )
                    }
                }
                impl<K: Message, V: Message> Iterator for IntoValues<K, V> {
                    type Item = Id<V>;
                    #[inline]
                    #[track_caller]
                    fn next(&mut self) -> Option<Self::Item> {
                        self.0.next()
                    }
                    #[inline]
                    fn size_hint(&self) -> (usize, Option<usize>) {
                        self.0.size_hint()
                    }
                }
            }
            #[cfg(feature = "Foundation_NSEnumerator")]
            pub use self::iter_helpers::*;
            impl<'a, K: Message + Eq + Hash, V: Message> Index<&'a K>
            for NSDictionary<K, V> {
                type Output = V;
                fn index<'s>(&'s self, index: &'a K) -> &'s V {
                    self.get(index).unwrap()
                }
            }
            impl<'a, K: Message + Eq + Hash, V: Message + IsMutable> IndexMut<&'a K>
            for NSDictionary<K, V> {
                fn index_mut<'s>(&'s mut self, index: &'a K) -> &'s mut V {
                    self.get_mut(index).unwrap()
                }
            }
            impl<K: fmt::Debug + Message, V: fmt::Debug + Message> fmt::Debug
            for NSDictionary<K, V> {
                #[inline]
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    let (keys, values) = self.to_vecs();
                    let iter = keys.into_iter().zip(values);
                    f.debug_map().entries(iter).finish()
                }
            }
        }
        pub mod enumerator {
            //! Utilities for the `NSEnumerator` class.
            #![cfg(feature = "Foundation_NSEnumerator")]
            use super::iter;
            use crate::common::*;
            use crate::Foundation::NSEnumerator;
            unsafe impl<T: Message> iter::FastEnumerationHelper for NSEnumerator<T> {
                type Item = T;
                #[inline]
                fn maybe_len(&self) -> Option<usize> {
                    None
                }
            }
            /// A consuming iterator over the items of a `NSEnumerator`.
            pub struct IntoIter<T: Message>(iter::IntoIter<NSEnumerator<T>>);
            #[automatically_derived]
            impl<T: ::core::fmt::Debug + Message> ::core::fmt::Debug for IntoIter<T> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "IntoIter",
                        &&self.0,
                    )
                }
            }
            impl<'a, T: Message> Iterator for IntoIter<T> {
                type Item = Id<T>;
                #[inline]
                #[track_caller]
                fn next(&mut self) -> Option<Self::Item> {
                    self.0.next()
                }
                #[inline]
                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.0.size_hint()
                }
            }
            impl<T: Message> objc2::rc::IdIntoIterator for NSEnumerator<T> {
                type Item = Id<T>;
                type IntoIter = IntoIter<T>;
                #[inline]
                fn id_into_iter(this: Id<Self>) -> Self::IntoIter {
                    IntoIter(super::iter::IntoIter::new(this))
                }
            }
        }
        mod fast_enumeration_state {
            use objc2::encode::Encoding;
            use crate::common::*;
            #[repr(C)]
            pub struct NSFastEnumerationState {
                pub state: c_ulong,
                pub itemsPtr: *mut *mut AnyObject,
                pub mutationsPtr: *mut c_ulong,
                pub extra: [c_ulong; 5],
            }
            #[automatically_derived]
            impl ::core::clone::Clone for NSFastEnumerationState {
                #[inline]
                fn clone(&self) -> NSFastEnumerationState {
                    let _: ::core::clone::AssertParamIsClone<c_ulong>;
                    let _: ::core::clone::AssertParamIsClone<*mut *mut AnyObject>;
                    let _: ::core::clone::AssertParamIsClone<*mut c_ulong>;
                    let _: ::core::clone::AssertParamIsClone<[c_ulong; 5]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSFastEnumerationState {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSFastEnumerationState {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "NSFastEnumerationState",
                        "state",
                        &self.state,
                        "itemsPtr",
                        &self.itemsPtr,
                        "mutationsPtr",
                        &self.mutationsPtr,
                        "extra",
                        &&self.extra,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSFastEnumerationState {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSFastEnumerationState {
                #[inline]
                fn eq(&self, other: &NSFastEnumerationState) -> bool {
                    self.state == other.state && self.itemsPtr == other.itemsPtr
                        && self.mutationsPtr == other.mutationsPtr
                        && self.extra == other.extra
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSFastEnumerationState {
                const ENCODING: objc2::Encoding = Encoding::Struct(
                    "?",
                    &[
                        Encoding::C_ULONG,
                        Encoding::Pointer(&Encoding::Object),
                        Encoding::Pointer(&Encoding::C_ULONG),
                        Encoding::Array(5, &Encoding::C_ULONG),
                    ],
                );
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSFastEnumerationState {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
        }
        mod generics {
            #![allow(dead_code)]
            use core::panic::{RefUnwindSafe, UnwindSafe};
            use crate::common::*;
            #[repr(transparent)]
            struct UnsafeIgnoreAutoTraits<T: ?Sized>(T);
            #[automatically_derived]
            impl<T: ?Sized> ::core::marker::StructuralPartialEq
            for UnsafeIgnoreAutoTraits<T> {}
            #[automatically_derived]
            impl<T: ::core::cmp::PartialEq + ?Sized> ::core::cmp::PartialEq
            for UnsafeIgnoreAutoTraits<T> {
                #[inline]
                fn eq(&self, other: &UnsafeIgnoreAutoTraits<T>) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl<T: ?Sized> ::core::marker::StructuralEq for UnsafeIgnoreAutoTraits<T> {}
            #[automatically_derived]
            impl<T: ::core::cmp::Eq + ?Sized> ::core::cmp::Eq
            for UnsafeIgnoreAutoTraits<T> {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<T>;
                }
            }
            #[automatically_derived]
            impl<T: ::core::hash::Hash + ?Sized> ::core::hash::Hash
            for UnsafeIgnoreAutoTraits<T> {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl<T: ::core::cmp::PartialOrd + ?Sized> ::core::cmp::PartialOrd
            for UnsafeIgnoreAutoTraits<T> {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &UnsafeIgnoreAutoTraits<T>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl<T: ::core::cmp::Ord + ?Sized> ::core::cmp::Ord
            for UnsafeIgnoreAutoTraits<T> {
                #[inline]
                fn cmp(
                    &self,
                    other: &UnsafeIgnoreAutoTraits<T>,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl<T: ::core::clone::Clone + ?Sized> ::core::clone::Clone
            for UnsafeIgnoreAutoTraits<T> {
                #[inline]
                fn clone(&self) -> UnsafeIgnoreAutoTraits<T> {
                    UnsafeIgnoreAutoTraits(::core::clone::Clone::clone(&self.0))
                }
            }
            #[automatically_derived]
            impl<T: ::core::marker::Copy + ?Sized> ::core::marker::Copy
            for UnsafeIgnoreAutoTraits<T> {}
            #[automatically_derived]
            impl<T: ::core::fmt::Debug + ?Sized> ::core::fmt::Debug
            for UnsafeIgnoreAutoTraits<T> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "UnsafeIgnoreAutoTraits",
                        &&self.0,
                    )
                }
            }
            unsafe impl<T: ?Sized> Send for UnsafeIgnoreAutoTraits<T> {}
            unsafe impl<T: ?Sized> Sync for UnsafeIgnoreAutoTraits<T> {}
            impl<T: ?Sized> RefUnwindSafe for UnsafeIgnoreAutoTraits<T> {}
            impl<T: ?Sized> UnwindSafe for UnsafeIgnoreAutoTraits<T> {}
            #[cfg(feature = "Foundation_NSDictionary")]
            #[repr(C)]
            pub struct NSDictionary<
                KeyType: ?Sized = AnyObject,
                ObjectType: ?Sized = AnyObject,
            > {
                __superclass: UnsafeIgnoreAutoTraits<NSObject>,
                __inner: PhantomData<(Id<KeyType>, Id<ObjectType>)>,
            }
            #[automatically_derived]
            impl<KeyType: ?Sized, ObjectType: ?Sized> ::core::marker::StructuralPartialEq
            for NSDictionary<KeyType, ObjectType> {}
            #[automatically_derived]
            impl<
                KeyType: ::core::cmp::PartialEq + ?Sized,
                ObjectType: ::core::cmp::PartialEq + ?Sized,
            > ::core::cmp::PartialEq for NSDictionary<KeyType, ObjectType> {
                #[inline]
                fn eq(&self, other: &NSDictionary<KeyType, ObjectType>) -> bool {
                    self.__superclass == other.__superclass
                        && self.__inner == other.__inner
                }
            }
            #[automatically_derived]
            impl<KeyType: ?Sized, ObjectType: ?Sized> ::core::marker::StructuralEq
            for NSDictionary<KeyType, ObjectType> {}
            #[automatically_derived]
            impl<
                KeyType: ::core::cmp::Eq + ?Sized,
                ObjectType: ::core::cmp::Eq + ?Sized,
            > ::core::cmp::Eq for NSDictionary<KeyType, ObjectType> {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<
                        UnsafeIgnoreAutoTraits<NSObject>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        PhantomData<(Id<KeyType>, Id<ObjectType>)>,
                    >;
                }
            }
            #[automatically_derived]
            impl<
                KeyType: ::core::hash::Hash + ?Sized,
                ObjectType: ::core::hash::Hash + ?Sized,
            > ::core::hash::Hash for NSDictionary<KeyType, ObjectType> {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.__superclass, state);
                    ::core::hash::Hash::hash(&self.__inner, state)
                }
            }
            #[cfg(feature = "Foundation_NSDictionary")]
            unsafe impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::RefEncode for NSDictionary<KeyType, ObjectType> {
                const ENCODING_REF: ::objc2::Encoding = <NSObject as ::objc2::RefEncode>::ENCODING_REF;
            }
            #[cfg(feature = "Foundation_NSDictionary")]
            unsafe impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::Message for NSDictionary<KeyType, ObjectType> {}
            #[cfg(feature = "Foundation_NSDictionary")]
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::Deref for NSDictionary<KeyType, ObjectType> {
                type Target = NSObject;
                #[inline]
                fn deref(&self) -> &Self::Target {
                    &self.__superclass.0
                }
            }
            #[cfg(feature = "Foundation_NSDictionary")]
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::DerefMut for NSDictionary<KeyType, ObjectType> {
                #[inline]
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.__superclass.0
                }
            }
            #[cfg(feature = "Foundation_NSDictionary")]
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::AsRef<Self>
            for NSDictionary<KeyType, ObjectType> {
                #[inline]
                fn as_ref(&self) -> &Self {
                    self
                }
            }
            #[cfg(feature = "Foundation_NSDictionary")]
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::AsMut<Self>
            for NSDictionary<KeyType, ObjectType> {
                #[inline]
                fn as_mut(&mut self) -> &mut Self {
                    self
                }
            }
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::AsRef<NSObject>
            for NSDictionary<KeyType, ObjectType> {
                #[inline]
                fn as_ref(&self) -> &NSObject {
                    &*self
                }
            }
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::AsMut<NSObject>
            for NSDictionary<KeyType, ObjectType> {
                #[inline]
                fn as_mut(&mut self) -> &mut NSObject {
                    &mut *self
                }
            }
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::Borrow<NSObject>
            for NSDictionary<KeyType, ObjectType> {
                #[inline]
                fn borrow(&self) -> &NSObject {
                    &*self
                }
            }
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::BorrowMut<NSObject>
            for NSDictionary<KeyType, ObjectType> {
                #[inline]
                fn borrow_mut(&mut self) -> &mut NSObject {
                    &mut *self
                }
            }
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::AsRef<::objc2::runtime::AnyObject>
            for NSDictionary<KeyType, ObjectType> {
                #[inline]
                fn as_ref(&self) -> &::objc2::runtime::AnyObject {
                    &*self
                }
            }
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::AsMut<::objc2::runtime::AnyObject>
            for NSDictionary<KeyType, ObjectType> {
                #[inline]
                fn as_mut(&mut self) -> &mut ::objc2::runtime::AnyObject {
                    &mut *self
                }
            }
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::Borrow<::objc2::runtime::AnyObject>
            for NSDictionary<KeyType, ObjectType> {
                #[inline]
                fn borrow(&self) -> &::objc2::runtime::AnyObject {
                    &*self
                }
            }
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::BorrowMut<::objc2::runtime::AnyObject>
            for NSDictionary<KeyType, ObjectType> {
                #[inline]
                fn borrow_mut(&mut self) -> &mut ::objc2::runtime::AnyObject {
                    &mut *self
                }
            }
            #[cfg(feature = "Foundation_NSDictionary")]
            unsafe impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ClassType for NSDictionary<KeyType, ObjectType> {
                type Super = NSObject;
                type Mutability = ImmutableWithMutableSubclass<
                    NSMutableDictionary<KeyType, ObjectType>,
                >;
                const NAME: &'static ::objc2::__macro_helpers::str = "NSDictionary";
                #[inline]
                fn class() -> &'static ::objc2::runtime::AnyClass {
                    ::objc2::__macro_helpers::assert_mutability_matches_superclass_mutability::<
                        Self,
                    >();
                    {
                        static CACHED_CLASS: ::objc2::__macro_helpers::CachedClass = ::objc2::__macro_helpers::CachedClass::new();
                        #[allow(unused_unsafe)]
                        unsafe { CACHED_CLASS.get("NSDictionary\u{0}") }
                    }
                }
                #[inline]
                fn as_super(&self) -> &Self::Super {
                    &self.__superclass.0
                }
                #[inline]
                fn as_super_mut(&mut self) -> &mut Self::Super {
                    &mut self.__superclass.0
                }
            }
            #[cfg(feature = "Foundation_NSDictionary")]
            #[repr(C)]
            pub struct NSMutableDictionary<
                KeyType: ?Sized = AnyObject,
                ObjectType: ?Sized = AnyObject,
            > {
                __superclass: NSDictionary<KeyType, ObjectType>,
            }
            #[automatically_derived]
            impl<KeyType: ?Sized, ObjectType: ?Sized> ::core::marker::StructuralPartialEq
            for NSMutableDictionary<KeyType, ObjectType> {}
            #[automatically_derived]
            impl<
                KeyType: ::core::cmp::PartialEq + ?Sized,
                ObjectType: ::core::cmp::PartialEq + ?Sized,
            > ::core::cmp::PartialEq for NSMutableDictionary<KeyType, ObjectType> {
                #[inline]
                fn eq(&self, other: &NSMutableDictionary<KeyType, ObjectType>) -> bool {
                    self.__superclass == other.__superclass
                }
            }
            #[automatically_derived]
            impl<KeyType: ?Sized, ObjectType: ?Sized> ::core::marker::StructuralEq
            for NSMutableDictionary<KeyType, ObjectType> {}
            #[automatically_derived]
            impl<
                KeyType: ::core::cmp::Eq + ?Sized,
                ObjectType: ::core::cmp::Eq + ?Sized,
            > ::core::cmp::Eq for NSMutableDictionary<KeyType, ObjectType> {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<
                        NSDictionary<KeyType, ObjectType>,
                    >;
                }
            }
            #[automatically_derived]
            impl<
                KeyType: ::core::hash::Hash + ?Sized,
                ObjectType: ::core::hash::Hash + ?Sized,
            > ::core::hash::Hash for NSMutableDictionary<KeyType, ObjectType> {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.__superclass, state)
                }
            }
            #[cfg(feature = "Foundation_NSDictionary")]
            unsafe impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::RefEncode for NSMutableDictionary<KeyType, ObjectType> {
                const ENCODING_REF: ::objc2::Encoding = <NSDictionary<
                    KeyType,
                    ObjectType,
                > as ::objc2::RefEncode>::ENCODING_REF;
            }
            #[cfg(feature = "Foundation_NSDictionary")]
            unsafe impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::Message for NSMutableDictionary<KeyType, ObjectType> {}
            #[cfg(feature = "Foundation_NSDictionary")]
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::Deref
            for NSMutableDictionary<KeyType, ObjectType> {
                type Target = NSDictionary<KeyType, ObjectType>;
                #[inline]
                fn deref(&self) -> &Self::Target {
                    &self.__superclass
                }
            }
            #[cfg(feature = "Foundation_NSDictionary")]
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::DerefMut
            for NSMutableDictionary<KeyType, ObjectType> {
                #[inline]
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.__superclass
                }
            }
            #[cfg(feature = "Foundation_NSDictionary")]
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::AsRef<Self>
            for NSMutableDictionary<KeyType, ObjectType> {
                #[inline]
                fn as_ref(&self) -> &Self {
                    self
                }
            }
            #[cfg(feature = "Foundation_NSDictionary")]
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::AsMut<Self>
            for NSMutableDictionary<KeyType, ObjectType> {
                #[inline]
                fn as_mut(&mut self) -> &mut Self {
                    self
                }
            }
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::AsRef<NSDictionary<KeyType, ObjectType>>
            for NSMutableDictionary<KeyType, ObjectType> {
                #[inline]
                fn as_ref(&self) -> &NSDictionary<KeyType, ObjectType> {
                    &*self
                }
            }
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::AsMut<NSDictionary<KeyType, ObjectType>>
            for NSMutableDictionary<KeyType, ObjectType> {
                #[inline]
                fn as_mut(&mut self) -> &mut NSDictionary<KeyType, ObjectType> {
                    &mut *self
                }
            }
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::Borrow<NSDictionary<KeyType, ObjectType>>
            for NSMutableDictionary<KeyType, ObjectType> {
                #[inline]
                fn borrow(&self) -> &NSDictionary<KeyType, ObjectType> {
                    &*self
                }
            }
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::BorrowMut<NSDictionary<KeyType, ObjectType>>
            for NSMutableDictionary<KeyType, ObjectType> {
                #[inline]
                fn borrow_mut(&mut self) -> &mut NSDictionary<KeyType, ObjectType> {
                    &mut *self
                }
            }
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::AsRef<NSObject>
            for NSMutableDictionary<KeyType, ObjectType> {
                #[inline]
                fn as_ref(&self) -> &NSObject {
                    &*self
                }
            }
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::AsMut<NSObject>
            for NSMutableDictionary<KeyType, ObjectType> {
                #[inline]
                fn as_mut(&mut self) -> &mut NSObject {
                    &mut *self
                }
            }
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::Borrow<NSObject>
            for NSMutableDictionary<KeyType, ObjectType> {
                #[inline]
                fn borrow(&self) -> &NSObject {
                    &*self
                }
            }
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::BorrowMut<NSObject>
            for NSMutableDictionary<KeyType, ObjectType> {
                #[inline]
                fn borrow_mut(&mut self) -> &mut NSObject {
                    &mut *self
                }
            }
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::AsRef<::objc2::runtime::AnyObject>
            for NSMutableDictionary<KeyType, ObjectType> {
                #[inline]
                fn as_ref(&self) -> &::objc2::runtime::AnyObject {
                    &*self
                }
            }
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::AsMut<::objc2::runtime::AnyObject>
            for NSMutableDictionary<KeyType, ObjectType> {
                #[inline]
                fn as_mut(&mut self) -> &mut ::objc2::runtime::AnyObject {
                    &mut *self
                }
            }
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::Borrow<::objc2::runtime::AnyObject>
            for NSMutableDictionary<KeyType, ObjectType> {
                #[inline]
                fn borrow(&self) -> &::objc2::runtime::AnyObject {
                    &*self
                }
            }
            impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::BorrowMut<::objc2::runtime::AnyObject>
            for NSMutableDictionary<KeyType, ObjectType> {
                #[inline]
                fn borrow_mut(&mut self) -> &mut ::objc2::runtime::AnyObject {
                    &mut *self
                }
            }
            #[cfg(feature = "Foundation_NSDictionary")]
            unsafe impl<
                KeyType: ?Sized + Message,
                ObjectType: ?Sized + Message,
            > ClassType for NSMutableDictionary<KeyType, ObjectType> {
                type Super = NSDictionary<KeyType, ObjectType>;
                type Mutability = MutableWithImmutableSuperclass<
                    NSDictionary<KeyType, ObjectType>,
                >;
                const NAME: &'static ::objc2::__macro_helpers::str = "NSMutableDictionary";
                #[inline]
                fn class() -> &'static ::objc2::runtime::AnyClass {
                    ::objc2::__macro_helpers::assert_mutability_matches_superclass_mutability::<
                        Self,
                    >();
                    {
                        static CACHED_CLASS: ::objc2::__macro_helpers::CachedClass = ::objc2::__macro_helpers::CachedClass::new();
                        #[allow(unused_unsafe)]
                        unsafe { CACHED_CLASS.get("NSMutableDictionary\u{0}") }
                    }
                }
                #[inline]
                fn as_super(&self) -> &Self::Super {
                    &self.__superclass
                }
                #[inline]
                fn as_super_mut(&mut self) -> &mut Self::Super {
                    &mut self.__superclass
                }
            }
            #[cfg(feature = "Foundation_NSEnumerator")]
            #[repr(C)]
            pub struct NSEnumerator<ObjectType: ?Sized = AnyObject> {
                __superclass: UnsafeIgnoreAutoTraits<NSObject>,
                __inner: PhantomData<Id<ObjectType>>,
            }
            #[automatically_derived]
            impl<ObjectType: ::core::fmt::Debug + ?Sized> ::core::fmt::Debug
            for NSEnumerator<ObjectType> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "NSEnumerator",
                        "__superclass",
                        &self.__superclass,
                        "__inner",
                        &&self.__inner,
                    )
                }
            }
            #[automatically_derived]
            impl<ObjectType: ?Sized> ::core::marker::StructuralPartialEq
            for NSEnumerator<ObjectType> {}
            #[automatically_derived]
            impl<ObjectType: ::core::cmp::PartialEq + ?Sized> ::core::cmp::PartialEq
            for NSEnumerator<ObjectType> {
                #[inline]
                fn eq(&self, other: &NSEnumerator<ObjectType>) -> bool {
                    self.__superclass == other.__superclass
                        && self.__inner == other.__inner
                }
            }
            #[automatically_derived]
            impl<ObjectType: ?Sized> ::core::marker::StructuralEq
            for NSEnumerator<ObjectType> {}
            #[automatically_derived]
            impl<ObjectType: ::core::cmp::Eq + ?Sized> ::core::cmp::Eq
            for NSEnumerator<ObjectType> {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<
                        UnsafeIgnoreAutoTraits<NSObject>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<PhantomData<Id<ObjectType>>>;
                }
            }
            #[automatically_derived]
            impl<ObjectType: ::core::hash::Hash + ?Sized> ::core::hash::Hash
            for NSEnumerator<ObjectType> {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.__superclass, state);
                    ::core::hash::Hash::hash(&self.__inner, state)
                }
            }
            #[cfg(feature = "Foundation_NSEnumerator")]
            unsafe impl<ObjectType: ?Sized + Message> ::objc2::RefEncode
            for NSEnumerator<ObjectType> {
                const ENCODING_REF: ::objc2::Encoding = <NSObject as ::objc2::RefEncode>::ENCODING_REF;
            }
            #[cfg(feature = "Foundation_NSEnumerator")]
            unsafe impl<ObjectType: ?Sized + Message> ::objc2::Message
            for NSEnumerator<ObjectType> {}
            #[cfg(feature = "Foundation_NSEnumerator")]
            impl<ObjectType: ?Sized + Message> ::objc2::__macro_helpers::Deref
            for NSEnumerator<ObjectType> {
                type Target = NSObject;
                #[inline]
                fn deref(&self) -> &Self::Target {
                    &self.__superclass.0
                }
            }
            #[cfg(feature = "Foundation_NSEnumerator")]
            impl<ObjectType: ?Sized + Message> ::objc2::__macro_helpers::DerefMut
            for NSEnumerator<ObjectType> {
                #[inline]
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.__superclass.0
                }
            }
            #[cfg(feature = "Foundation_NSEnumerator")]
            impl<ObjectType: ?Sized + Message> ::objc2::__macro_helpers::AsRef<Self>
            for NSEnumerator<ObjectType> {
                #[inline]
                fn as_ref(&self) -> &Self {
                    self
                }
            }
            #[cfg(feature = "Foundation_NSEnumerator")]
            impl<ObjectType: ?Sized + Message> ::objc2::__macro_helpers::AsMut<Self>
            for NSEnumerator<ObjectType> {
                #[inline]
                fn as_mut(&mut self) -> &mut Self {
                    self
                }
            }
            impl<ObjectType: ?Sized + Message> ::objc2::__macro_helpers::AsRef<NSObject>
            for NSEnumerator<ObjectType> {
                #[inline]
                fn as_ref(&self) -> &NSObject {
                    &*self
                }
            }
            impl<ObjectType: ?Sized + Message> ::objc2::__macro_helpers::AsMut<NSObject>
            for NSEnumerator<ObjectType> {
                #[inline]
                fn as_mut(&mut self) -> &mut NSObject {
                    &mut *self
                }
            }
            impl<ObjectType: ?Sized + Message> ::objc2::__macro_helpers::Borrow<NSObject>
            for NSEnumerator<ObjectType> {
                #[inline]
                fn borrow(&self) -> &NSObject {
                    &*self
                }
            }
            impl<
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::BorrowMut<NSObject>
            for NSEnumerator<ObjectType> {
                #[inline]
                fn borrow_mut(&mut self) -> &mut NSObject {
                    &mut *self
                }
            }
            impl<
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::AsRef<::objc2::runtime::AnyObject>
            for NSEnumerator<ObjectType> {
                #[inline]
                fn as_ref(&self) -> &::objc2::runtime::AnyObject {
                    &*self
                }
            }
            impl<
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::AsMut<::objc2::runtime::AnyObject>
            for NSEnumerator<ObjectType> {
                #[inline]
                fn as_mut(&mut self) -> &mut ::objc2::runtime::AnyObject {
                    &mut *self
                }
            }
            impl<
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::Borrow<::objc2::runtime::AnyObject>
            for NSEnumerator<ObjectType> {
                #[inline]
                fn borrow(&self) -> &::objc2::runtime::AnyObject {
                    &*self
                }
            }
            impl<
                ObjectType: ?Sized + Message,
            > ::objc2::__macro_helpers::BorrowMut<::objc2::runtime::AnyObject>
            for NSEnumerator<ObjectType> {
                #[inline]
                fn borrow_mut(&mut self) -> &mut ::objc2::runtime::AnyObject {
                    &mut *self
                }
            }
            #[cfg(feature = "Foundation_NSEnumerator")]
            unsafe impl<ObjectType: ?Sized + Message> ClassType
            for NSEnumerator<ObjectType> {
                type Super = NSObject;
                type Mutability = Mutable;
                const NAME: &'static ::objc2::__macro_helpers::str = "NSEnumerator";
                #[inline]
                fn class() -> &'static ::objc2::runtime::AnyClass {
                    ::objc2::__macro_helpers::assert_mutability_matches_superclass_mutability::<
                        Self,
                    >();
                    {
                        static CACHED_CLASS: ::objc2::__macro_helpers::CachedClass = ::objc2::__macro_helpers::CachedClass::new();
                        #[allow(unused_unsafe)]
                        unsafe { CACHED_CLASS.get("NSEnumerator\u{0}") }
                    }
                }
                #[inline]
                fn as_super(&self) -> &Self::Super {
                    &self.__superclass.0
                }
                #[inline]
                fn as_super_mut(&mut self) -> &mut Self::Super {
                    &mut self.__superclass.0
                }
            }
        }
        mod geometry {
            use crate::common::*;
            use objc2::encode::{Encode, Encoding, RefEncode};
            #[cfg(target_pointer_width = "64")]
            type InnerFloat = f64;
            /// The basic type for all floating-point values.
            ///
            /// This is [`f32`] on 32-bit platforms and [`f64`] on 64-bit platforms.
            ///
            /// This technically belongs to the `CoreGraphics` framework, but we define it
            /// here for convenience.
            ///
            /// See [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgfloat?language=objc).
            pub type CGFloat = InnerFloat;
            #[cfg(
                all(
                    feature = "apple",
                    not(all(target_os = "macos", target_pointer_width = "32"))
                )
            )]
            mod names {
                pub(super) const POINT: &str = "CGPoint";
                pub(super) const SIZE: &str = "CGSize";
                pub(super) const RECT: &str = "CGRect";
            }
            /// A point in a two-dimensional coordinate system.
            ///
            /// This technically belongs to the `CoreGraphics` framework, but we define it
            /// here for convenience.
            ///
            /// See [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cgpoint?language=objc).
            #[repr(C)]
            pub struct CGPoint {
                /// The x-coordinate of the point.
                pub x: CGFloat,
                /// The y-coordinate of the point.
                pub y: CGFloat,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for CGPoint {
                #[inline]
                fn clone(&self) -> CGPoint {
                    let _: ::core::clone::AssertParamIsClone<CGFloat>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for CGPoint {}
            #[automatically_derived]
            impl ::core::fmt::Debug for CGPoint {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "CGPoint",
                        "x",
                        &self.x,
                        "y",
                        &&self.y,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for CGPoint {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for CGPoint {
                #[inline]
                fn eq(&self, other: &CGPoint) -> bool {
                    self.x == other.x && self.y == other.y
                }
            }
            #[automatically_derived]
            impl ::core::default::Default for CGPoint {
                #[inline]
                fn default() -> CGPoint {
                    CGPoint {
                        x: ::core::default::Default::default(),
                        y: ::core::default::Default::default(),
                    }
                }
            }
            unsafe impl Encode for CGPoint {
                const ENCODING: Encoding = Encoding::Struct(
                    names::POINT,
                    &[CGFloat::ENCODING, CGFloat::ENCODING],
                );
            }
            unsafe impl RefEncode for CGPoint {
                const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
            }
            impl CGPoint {
                /// Create a new point with the given coordinates.
                ///
                ///
                /// # Examples
                ///
                /// ```
                /// use icrate::Foundation::CGPoint;
                /// assert_eq!(CGPoint::new(10.0, -2.3), CGPoint { x: 10.0, y: -2.3 });
                /// ```
                #[inline]
                #[doc(alias = "NSMakePoint")]
                #[doc(alias = "CGPointMake")]
                pub const fn new(x: CGFloat, y: CGFloat) -> Self {
                    Self { x, y }
                }
                /// A point with both coordinates set to `0.0`.
                ///
                ///
                /// # Examples
                ///
                /// ```
                /// use icrate::Foundation::CGPoint;
                /// assert_eq!(CGPoint::ZERO, CGPoint { x: 0.0, y: 0.0 });
                /// ```
                #[doc(alias = "NSZeroPoint")]
                #[doc(alias = "CGPointZero")]
                #[doc(alias = "ORIGIN")]
                pub const ZERO: Self = Self::new(0.0, 0.0);
            }
            /// A two-dimensional size.
            ///
            /// As this is sometimes used to represent a distance vector, rather than a
            /// physical size, the width and height are _not_ guaranteed to be
            /// non-negative! Methods that expect that must use one of [`CGSize::abs`] or
            /// [`CGRect::standardize`].
            ///
            /// This technically belongs to the `CoreGraphics` framework, but we define it
            /// here for convenience.
            ///
            /// See [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cgsize?language=objc).
            #[repr(C)]
            pub struct CGSize {
                /// The dimensions along the x-axis.
                pub width: CGFloat,
                /// The dimensions along the y-axis.
                pub height: CGFloat,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for CGSize {
                #[inline]
                fn clone(&self) -> CGSize {
                    let _: ::core::clone::AssertParamIsClone<CGFloat>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for CGSize {}
            #[automatically_derived]
            impl ::core::fmt::Debug for CGSize {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "CGSize",
                        "width",
                        &self.width,
                        "height",
                        &&self.height,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for CGSize {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for CGSize {
                #[inline]
                fn eq(&self, other: &CGSize) -> bool {
                    self.width == other.width && self.height == other.height
                }
            }
            #[automatically_derived]
            impl ::core::default::Default for CGSize {
                #[inline]
                fn default() -> CGSize {
                    CGSize {
                        width: ::core::default::Default::default(),
                        height: ::core::default::Default::default(),
                    }
                }
            }
            unsafe impl Encode for CGSize {
                const ENCODING: Encoding = Encoding::Struct(
                    names::SIZE,
                    &[CGFloat::ENCODING, CGFloat::ENCODING],
                );
            }
            unsafe impl RefEncode for CGSize {
                const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
            }
            impl CGSize {
                /// Create a new size with the given dimensions.
                ///
                ///
                /// # Examples
                ///
                /// ```
                /// use icrate::Foundation::CGSize;
                /// let size = CGSize::new(10.0, 2.3);
                /// assert_eq!(size.width, 10.0);
                /// assert_eq!(size.height, 2.3);
                /// ```
                ///
                /// Negative values are allowed (though often undesired).
                ///
                /// ```
                /// use icrate::Foundation::CGSize;
                /// let size = CGSize::new(-1.0, 0.0);
                /// assert_eq!(size.width, -1.0);
                /// ```
                #[inline]
                #[doc(alias = "NSMakeSize")]
                #[doc(alias = "CGSizeMake")]
                pub const fn new(width: CGFloat, height: CGFloat) -> Self {
                    Self { width, height }
                }
                /// Convert the size to a non-negative size.
                ///
                /// This can be used to convert the size to a safe value.
                ///
                ///
                /// # Examples
                ///
                /// ```
                /// use icrate::Foundation::CGSize;
                /// assert_eq!(CGSize::new(-1.0, 1.0).abs(), CGSize::new(1.0, 1.0));
                /// ```
                #[inline]
                pub fn abs(self) -> Self {
                    Self::new(self.width.abs(), self.height.abs())
                }
                /// A size that is 0.0 in both dimensions.
                ///
                ///
                /// # Examples
                ///
                /// ```
                /// use icrate::Foundation::CGSize;
                /// assert_eq!(CGSize::ZERO, CGSize { width: 0.0, height: 0.0 });
                /// ```
                #[doc(alias = "NSZeroSize")]
                #[doc(alias = "CGSizeZero")]
                pub const ZERO: Self = Self::new(0.0, 0.0);
            }
            /// The location and dimensions of a rectangle.
            ///
            /// In the default Core Graphics coordinate space (macOS), the origin is
            /// located in the lower-left corner of the rectangle and the rectangle
            /// extends towards the upper-right corner.
            ///
            /// If the context has a flipped coordinate space (iOS, tvOS, watchOS) the
            /// origin is in the upper-left corner and the rectangle extends towards the
            /// lower-right corner.
            ///
            /// This technically belongs to the `CoreGraphics` framework, but we define it
            /// here for convenience.
            ///
            /// See [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cgrect?language=objc).
            #[repr(C)]
            pub struct CGRect {
                /// The coordinates of the rectangle’s origin.
                pub origin: CGPoint,
                /// The dimensions of the rectangle.
                pub size: CGSize,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for CGRect {
                #[inline]
                fn clone(&self) -> CGRect {
                    let _: ::core::clone::AssertParamIsClone<CGPoint>;
                    let _: ::core::clone::AssertParamIsClone<CGSize>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for CGRect {}
            #[automatically_derived]
            impl ::core::fmt::Debug for CGRect {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "CGRect",
                        "origin",
                        &self.origin,
                        "size",
                        &&self.size,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for CGRect {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for CGRect {
                #[inline]
                fn eq(&self, other: &CGRect) -> bool {
                    self.origin == other.origin && self.size == other.size
                }
            }
            #[automatically_derived]
            impl ::core::default::Default for CGRect {
                #[inline]
                fn default() -> CGRect {
                    CGRect {
                        origin: ::core::default::Default::default(),
                        size: ::core::default::Default::default(),
                    }
                }
            }
            unsafe impl Encode for CGRect {
                const ENCODING: Encoding = Encoding::Struct(
                    names::RECT,
                    &[CGPoint::ENCODING, CGSize::ENCODING],
                );
            }
            unsafe impl RefEncode for CGRect {
                const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
            }
            impl CGRect {
                /// Create a new rectangle with the given origin and dimensions.
                ///
                ///
                /// # Examples
                ///
                /// ```
                /// use icrate::Foundation::{CGPoint, CGRect, CGSize};
                /// let origin = CGPoint::new(10.0, -2.3);
                /// let size = CGSize::new(5.0, 0.0);
                /// let rect = CGRect::new(origin, size);
                /// ```
                #[inline]
                #[doc(alias = "NSMakeRect")]
                #[doc(alias = "CGRectMake")]
                pub const fn new(origin: CGPoint, size: CGSize) -> Self {
                    Self { origin, size }
                }
                /// A rectangle with origin (0.0, 0.0) and zero width and height.
                #[doc(alias = "NSZeroRect")]
                #[doc(alias = "CGRectZero")]
                pub const ZERO: Self = Self::new(CGPoint::ZERO, CGSize::ZERO);
                /// Returns a rectangle with a positive width and height.
                ///
                /// This is often useful
                ///
                ///
                /// # Examples
                ///
                /// ```
                /// use icrate::Foundation::{CGPoint, CGRect, CGSize};
                /// let origin = CGPoint::new(1.0, 1.0);
                /// let size = CGSize::new(-5.0, -2.0);
                /// let rect = CGRect::new(origin, size);
                /// assert_eq!(rect.standardize().size, CGSize::new(5.0, 2.0));
                /// ```
                #[inline]
                #[doc(alias = "CGRectStandardize")]
                pub fn standardize(self) -> Self {
                    Self::new(self.origin, self.size.abs())
                }
                /// The smallest coordinate of the rectangle.
                #[inline]
                #[doc(alias = "CGRectGetMinX")]
                #[doc(alias = "CGRectGetMinY")]
                #[doc(alias = "NSMinX")]
                #[doc(alias = "NSMinY")]
                pub fn min(self) -> CGPoint {
                    self.origin
                }
                /// The center point of the rectangle.
                #[inline]
                #[doc(alias = "CGRectGetMidX")]
                #[doc(alias = "CGRectGetMidY")]
                #[doc(alias = "NSMidX")]
                #[doc(alias = "NSMidY")]
                pub fn mid(self) -> CGPoint {
                    CGPoint::new(
                        self.origin.x + (self.size.width * 0.5),
                        self.origin.y + (self.size.height * 0.5),
                    )
                }
                /// The largest coordinate of the rectangle.
                #[inline]
                #[doc(alias = "CGRectGetMaxX")]
                #[doc(alias = "CGRectGetMaxY")]
                #[doc(alias = "NSMaxX")]
                #[doc(alias = "NSMaxY")]
                pub fn max(self) -> CGPoint {
                    CGPoint::new(
                        self.origin.x + self.size.width,
                        self.origin.y + self.size.height,
                    )
                }
                /// Returns whether a rectangle has zero width or height.
                ///
                ///
                /// # Examples
                ///
                /// ```
                /// use icrate::Foundation::{CGPoint, CGRect, CGSize};
                /// assert!(CGRect::ZERO.is_empty());
                /// let point = CGPoint::new(1.0, 2.0);
                /// assert!(CGRect::new(point, CGSize::ZERO).is_empty());
                /// assert!(!CGRect::new(point, CGSize::new(1.0, 1.0)).is_empty());
                /// ```
                #[inline]
                #[doc(alias = "CGRectIsEmpty")]
                pub fn is_empty(self) -> bool {
                    !(self.size.width > 0.0 && self.size.height > 0.0)
                }
            }
            /// A point in a Cartesian coordinate system.
            ///
            /// This is a convenience alias for [`CGPoint`]. For ease of use, it is
            /// available on all platforms, though in practice it is only useful on macOS.
            ///
            /// See [Apple's documentation](https://developer.apple.com/documentation/foundation/nspoint?language=objc).
            pub type NSPoint = CGPoint;
            /// A two-dimensional size.
            ///
            /// This is a convenience alias for [`CGSize`]. For ease of use, it is
            /// available on all platforms, though in practice it is only useful on macOS.
            ///
            /// See [Apple's documentation](https://developer.apple.com/documentation/foundation/nssize?language=objc).
            pub type NSSize = CGSize;
            /// A rectangle.
            ///
            /// This is a convenience alias for [`CGRect`]. For ease of use, it is
            /// available on all platforms, though in practice it is only useful on macOS.
            ///
            /// See [Apple's documentation](https://developer.apple.com/documentation/foundation/nsrect?language=objc).
            pub type NSRect = CGRect;
            #[repr(transparent)]
            pub struct NSRectEdge(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSRectEdge {
                #[inline]
                fn clone(&self) -> NSRectEdge {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSRectEdge {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSRectEdge {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSRectEdge",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSRectEdge {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSRectEdge {
                #[inline]
                fn eq(&self, other: &NSRectEdge) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSRectEdge {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSRectEdge {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSRectEdge {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSRectEdge {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSRectEdge,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSRectEdge {
                #[inline]
                fn cmp(&self, other: &NSRectEdge) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSRectEdge {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSRectEdge {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSRectEdge {
                #[doc(alias = "NSRectEdgeMinX")]
                #[allow(non_upper_case_globals)]
                pub const MinX: Self = Self(0);
                #[doc(alias = "NSRectEdgeMinY")]
                #[allow(non_upper_case_globals)]
                pub const MinY: Self = Self(1);
                #[doc(alias = "NSRectEdgeMaxX")]
                #[allow(non_upper_case_globals)]
                pub const MaxX: Self = Self(2);
                #[doc(alias = "NSRectEdgeMaxY")]
                #[allow(non_upper_case_globals)]
                pub const MaxY: Self = Self(3);
                #[allow(non_upper_case_globals)]
                pub const NSMinXEdge: Self = Self(NSRectEdge::MinX.0);
                #[allow(non_upper_case_globals)]
                pub const NSMinYEdge: Self = Self(NSRectEdge::MinY.0);
                #[allow(non_upper_case_globals)]
                pub const NSMaxXEdge: Self = Self(NSRectEdge::MaxX.0);
                #[allow(non_upper_case_globals)]
                pub const NSMaxYEdge: Self = Self(NSRectEdge::MaxY.0);
            }
        }
        mod macros {
            #[cfg(feature = "Foundation_NSString")]
            mod ns_string {}
        }
        mod ns_consumed {
            extern "C" {}
        }
        mod range {
            use core::ops::Range;
            use objc2::encode::{Encode, Encoding, RefEncode};
            use crate::Foundation::NSUInteger;
            /// TODO.
            ///
            /// See [Apple's documentation](https://developer.apple.com/documentation/foundation/nsrange?language=objc).
            #[repr(C)]
            pub struct NSRange {
                /// The lower bound of the range (inclusive).
                pub location: NSUInteger,
                /// The number of items in the range, starting from `location`.
                pub length: NSUInteger,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for NSRange {
                #[inline]
                fn clone(&self) -> NSRange {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSRange {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSRange {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "NSRange",
                        "location",
                        &self.location,
                        "length",
                        &&self.length,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::default::Default for NSRange {
                #[inline]
                fn default() -> NSRange {
                    NSRange {
                        location: ::core::default::Default::default(),
                        length: ::core::default::Default::default(),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSRange {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSRange {
                #[inline]
                fn eq(&self, other: &NSRange) -> bool {
                    self.location == other.location && self.length == other.length
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSRange {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSRange {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSRange {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.location, state);
                    ::core::hash::Hash::hash(&self.length, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSRange {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSRange,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.location,
                        &other.location,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(
                                &self.length,
                                &other.length,
                            )
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSRange {
                #[inline]
                fn cmp(&self, other: &NSRange) -> ::core::cmp::Ordering {
                    match ::core::cmp::Ord::cmp(&self.location, &other.location) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.length, &other.length)
                        }
                        cmp => cmp,
                    }
                }
            }
            impl NSRange {
                /// Create a new range with the given values.
                ///
                /// # Examples
                ///
                /// ```
                /// use icrate::Foundation::NSRange;
                /// assert_eq!(NSRange::new(3, 2), NSRange::from(3..5));
                /// ```
                #[inline]
                #[doc(alias = "NSMakeRange")]
                pub const fn new(location: usize, length: usize) -> Self {
                    Self { location, length }
                }
                /// Returns `true` if the range contains no items.
                ///
                /// # Examples
                ///
                /// ```
                /// use icrate::Foundation::NSRange;
                ///
                /// assert!(!NSRange::from(3..5).is_empty());
                /// assert!( NSRange::from(3..3).is_empty());
                /// ```
                #[inline]
                pub fn is_empty(&self) -> bool {
                    self.length == 0
                }
                /// Returns `true` if the index is within the range.
                ///
                /// # Examples
                ///
                /// ```
                /// use icrate::Foundation::NSRange;
                ///
                /// assert!(!NSRange::from(3..5).contains(2));
                /// assert!( NSRange::from(3..5).contains(3));
                /// assert!( NSRange::from(3..5).contains(4));
                /// assert!(!NSRange::from(3..5).contains(5));
                ///
                /// assert!(!NSRange::from(3..3).contains(3));
                /// ```
                #[inline]
                #[doc(alias = "NSLocationInRange")]
                pub fn contains(&self, index: usize) -> bool {
                    if let Some(len) = index.checked_sub(self.location) {
                        len < self.length
                    } else {
                        false
                    }
                }
                /// Returns the upper bound of the range (exclusive).
                #[inline]
                #[doc(alias = "NSMaxRange")]
                pub fn end(&self) -> usize {
                    self.location.checked_add(self.length).expect("NSRange too large")
                }
            }
            impl From<Range<usize>> for NSRange {
                fn from(range: Range<usize>) -> Self {
                    let length = range
                        .end
                        .checked_sub(range.start)
                        .expect("Range end < start");
                    Self {
                        location: range.start,
                        length,
                    }
                }
            }
            impl From<NSRange> for Range<usize> {
                #[inline]
                fn from(nsrange: NSRange) -> Self {
                    Self {
                        start: nsrange.location,
                        end: nsrange.end(),
                    }
                }
            }
            unsafe impl Encode for NSRange {
                const ENCODING: Encoding = Encoding::Struct(
                    "_NSRange",
                    &[usize::ENCODING, usize::ENCODING],
                );
            }
            unsafe impl RefEncode for NSRange {
                const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
            }
        }
        mod string {
            #![cfg(feature = "Foundation_NSString")]
            use core::cmp;
            use core::ffi::c_void;
            use core::fmt;
            use core::panic::RefUnwindSafe;
            use core::panic::UnwindSafe;
            #[cfg(feature = "apple")]
            use core::ptr::NonNull;
            #[cfg(feature = "apple")]
            use core::slice;
            use core::str;
            #[cfg(feature = "apple")]
            use std::os::raw::c_char;
            use objc2::msg_send_id;
            use objc2::rc::{autoreleasepool_leaking, AutoreleasePool};
            use objc2::runtime::__nsstring::{
                nsstring_len, nsstring_to_str, UTF8_ENCODING,
            };
            use crate::common::*;
            use crate::Foundation::NSString;
            unsafe impl Sync for NSString {}
            unsafe impl Send for NSString {}
            impl UnwindSafe for NSString {}
            impl RefUnwindSafe for NSString {}
            impl NSString {
                /// The number of UTF-8 code units in `self`.
                #[doc(alias = "lengthOfBytesUsingEncoding")]
                #[doc(alias = "lengthOfBytesUsingEncoding:")]
                pub fn len(&self) -> usize {
                    unsafe { nsstring_len(self) }
                }
                /// The number of UTF-16 code units in the string.
                ///
                /// See also [`NSString::len`].
                #[doc(alias = "length")]
                pub fn len_utf16(&self) -> usize {
                    self.length()
                }
                pub fn is_empty(&self) -> bool {
                    self.len() == 0
                }
                /// Get the [`str`](`prim@str`) representation of this string if it can be
                /// done efficiently.
                ///
                /// Returns [`None`] if the internal storage does not allow this to be
                /// done efficiently. Use [`NSString::as_str`] or `NSString::to_string`
                /// if performance is not an issue.
                #[doc(alias = "CFStringGetCStringPtr")]
                #[allow(unused)]
                #[cfg(feature = "apple")]
                fn as_str_wip(&self) -> Option<&str> {
                    type CFStringEncoding = u32;
                    #[allow(non_upper_case_globals)]
                    const kCFStringEncodingUTF8: CFStringEncoding = 0x08000100;
                    extern "C" {
                        fn CFStringGetCStringPtr(
                            s: &NSString,
                            encoding: CFStringEncoding,
                        ) -> *const c_char;
                    }
                    let bytes = unsafe {
                        CFStringGetCStringPtr(self, kCFStringEncodingUTF8)
                    };
                    NonNull::new(bytes as *mut u8)
                        .map(|bytes| {
                            let len = self.len();
                            let bytes: &[u8] = unsafe {
                                slice::from_raw_parts(bytes.as_ptr(), len)
                            };
                            str::from_utf8(bytes).unwrap()
                        })
                }
                /// Get an [UTF-16] string slice if it can be done efficiently.
                ///
                /// Returns [`None`] if the internal storage of `self` does not allow this
                /// to be returned efficiently.
                ///
                /// See [`as_str`](Self::as_str) for the UTF-8 equivalent.
                ///
                /// [UTF-16]: https://en.wikipedia.org/wiki/UTF-16
                #[allow(unused)]
                #[cfg(feature = "apple")]
                fn as_utf16(&self) -> Option<&[u16]> {
                    extern "C" {
                        fn CFStringGetCharactersPtr(s: &NSString) -> *const u16;
                    }
                    let ptr = unsafe { CFStringGetCharactersPtr(self) };
                    NonNull::new(ptr as *mut u16)
                        .map(|ptr| unsafe {
                            slice::from_raw_parts(ptr.as_ptr(), self.len_utf16())
                        })
                }
                /// Get the [`str`](`prim@str`) representation of this.
                ///
                /// TODO: Further explain this.
                #[doc(alias = "UTF8String")]
                pub fn as_str<'r, 's: 'r, 'p: 'r>(
                    &'s self,
                    pool: AutoreleasePool<'p>,
                ) -> &'r str {
                    unsafe { nsstring_to_str(self, pool) }
                }
                /// Creates an immutable `NSString` by copying the given string slice.
                ///
                /// Prefer using the [`ns_string!`] macro when possible.
                ///
                /// [`ns_string!`]: crate::Foundation::ns_string
                #[doc(alias = "initWithBytes")]
                #[doc(alias = "initWithBytes:length:encoding:")]
                #[allow(clippy::should_implement_trait)]
                pub fn from_str(string: &str) -> Id<Self> {
                    unsafe { init_with_str(Self::alloc(), string) }
                }
            }
            unsafe fn init_with_str<T: Message>(
                obj: Allocated<T>,
                string: &str,
            ) -> Id<T> {
                let bytes: *const c_void = string.as_ptr().cast();
                unsafe {
                    {
                        {
                            const __SELECTOR_DATA: &::objc2::__macro_helpers::str = "initWithBytes:length:encoding:\u{0}";
                            let result;
                            result = <::objc2::__macro_helpers::RetainSemantics<
                                {
                                    ::objc2::__macro_helpers::retain_semantics(__SELECTOR_DATA)
                                },
                            > as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                obj,
                                {
                                    static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                    #[allow(unused_unsafe)]
                                    unsafe { CACHED_SEL.get(__SELECTOR_DATA) }
                                },
                                (bytes, string.len(), UTF8_ENCODING),
                            );
                            result
                        }
                    }
                }
            }
            impl PartialOrd for NSString {
                #[inline]
                fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {
                    Some(self.cmp(other))
                }
            }
            impl Ord for NSString {
                fn cmp(&self, other: &Self) -> cmp::Ordering {
                    self.compare(other).into()
                }
            }
            impl fmt::Display for NSString {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    autoreleasepool_leaking(|pool| fmt::Display::fmt(
                        self.as_str(pool),
                        f,
                    ))
                }
            }
            impl fmt::Debug for NSString {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    autoreleasepool_leaking(|pool| fmt::Debug::fmt(self.as_str(pool), f))
                }
            }
        }
        mod thread {
            use core::fmt;
            use core::marker::PhantomData;
            use crate::common::*;
            use objc2::msg_send_id;
            use objc2::mutability::IsMainThreadOnly;
            /// A marker type taken by functions that can only be executed on the main
            /// thread.
            ///
            /// By design, this is neither [`Send`] nor [`Sync`], and can only be created
            /// on the main thread, meaning that if you're holding this, you know you're
            /// running on the main thread.
            ///
            /// See the following links for more information on main-thread-only APIs:
            /// - [Main Thread Only APIs on OS X](https://www.dribin.org/dave/blog/archives/2009/02/01/main_thread_apis/)
            /// - [Thread Safety Summary](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-SW1)
            /// - [Are the Cocoa Frameworks Thread Safe?](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaFundamentals/AddingBehaviortoaCocoaProgram/AddingBehaviorCocoa.html#//apple_ref/doc/uid/TP40002974-CH5-SW47)
            /// - [Technical Note TN2028 - Threading Architectures](https://developer.apple.com/library/archive/technotes/tn/tn2028.html#//apple_ref/doc/uid/DTS10003065)
            /// - [Thread Management](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html)
            /// - [Mike Ash' article on thread safety](https://www.mikeash.com/pyblog/friday-qa-2009-01-09.html)
            ///
            ///
            /// # Main Thread Checker
            ///
            /// Xcode provides a tool called the ["Main Thread Checker"][mtc] which
            /// verifies that UI APIs are being used from the correct thread. This is not
            /// as principled as `MainThreadMarker`, but is helpful for catching mistakes.
            ///
            /// You can use this tool on macOS by loading `libMainThreadChecker.dylib`
            /// into your process using `DYLD_INSERT_LIBRARIES`:
            ///
            /// ```console
            /// DYLD_INSERT_LIBRARIES=/Applications/Xcode.app/Contents/Developer/usr/lib/libMainThreadChecker.dylib MTC_RESET_INSERT_LIBRARIES=0 cargo run
            /// ```
            ///
            /// If you're not running your binary through Cargo, you can omit
            /// [`MTC_RESET_INSERT_LIBRARIES`][mtc-reset].
            ///
            /// ```console
            /// DYLD_INSERT_LIBRARIES=/Applications/Xcode.app/Contents/Developer/usr/lib/libMainThreadChecker.dylib target/debug/myapp
            /// ```
            ///
            /// If you're developing for iOS, you probably better off enabling the tool in
            /// Xcode's own UI.
            ///
            /// See [this excellent blog post][mtc-cfg] for details on further
            /// configuration options.
            ///
            /// [mtc]: https://developer.apple.com/documentation/xcode/diagnosing-memory-thread-and-crash-issues-early#Detect-improper-UI-updates-on-background-threads
            /// [mtc-reset]: https://bryce.co/main-thread-checker-configuration/#mtc_reset_insert_libraries
            /// [mtc-cfg]: https://bryce.co/main-thread-checker-configuration/
            ///
            ///
            /// # Examples
            ///
            /// Use when designing APIs that are only safe to use on the main thread:
            ///
            /// ```no_run
            /// use icrate::Foundation::{MainThreadMarker, NSObject};
            /// use icrate::objc2::msg_send;
            /// # let obj = 0 as *const NSObject;
            ///
            /// // This action requires the main thread, so we take a marker as parameter.
            /// // It signals clearly to users "this requires the main thread".
            /// unsafe fn do_thing(obj: *const NSObject, _mtm: MainThreadMarker) {
            ///     msg_send![obj, someActionThatRequiresTheMainThread]
            /// }
            ///
            /// // Usage
            ///
            /// // Create a new marker. This requires the `"Foundation_NSThread"` feature.
            /// // If that is not available, create the marker unsafely with
            /// // `new_unchecked`, after having checked that the thread is the main one
            /// // through other means.
            /// #[cfg(feature = "Foundation_NSThread")]
            /// let mtm = MainThreadMarker::new().expect("must be on the main thread");
            /// #[cfg(not(feature = "Foundation_NSThread"))]
            /// let mtm = unsafe { MainThreadMarker::new_unchecked() };
            /// unsafe { do_thing(obj, mtm) }
            /// ```
            pub struct MainThreadMarker {
                _priv: PhantomData<*mut ()>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for MainThreadMarker {
                #[inline]
                fn clone(&self) -> MainThreadMarker {
                    let _: ::core::clone::AssertParamIsClone<PhantomData<*mut ()>>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for MainThreadMarker {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for MainThreadMarker {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for MainThreadMarker {
                #[inline]
                fn eq(&self, other: &MainThreadMarker) -> bool {
                    self._priv == other._priv
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for MainThreadMarker {}
            #[automatically_derived]
            impl ::core::cmp::Eq for MainThreadMarker {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<PhantomData<*mut ()>>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for MainThreadMarker {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self._priv, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for MainThreadMarker {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &MainThreadMarker,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self._priv, &other._priv)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for MainThreadMarker {
                #[inline]
                fn cmp(&self, other: &MainThreadMarker) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self._priv, &other._priv)
                }
            }
            impl MainThreadMarker {
                /// Construct a new [`MainThreadMarker`] without first checking whether
                /// the current thread is the main one.
                ///
                ///
                /// # Safety
                ///
                /// The current thread must be the main thread.
                ///
                /// Alternatively, you may create this briefly if you know that a an API
                /// is safe in a specific case, but is not marked so. If you do that, you
                /// must ensure that any use of the marker is actually safe to do from
                /// another thread than the main one.
                #[inline]
                pub unsafe fn new_unchecked() -> Self {
                    Self { _priv: PhantomData }
                }
                /// Allocate a new instance of the specified class on the main thread.
                ///
                /// This is essentially the same as [`ClassType::alloc`], the difference
                /// being that it is also callable with classes that can only be used on
                /// the main thread.
                ///
                ///
                /// # Example
                ///
                /// Create an object on the main thread.
                ///
                /// ```
                /// use icrate::Foundation::MainThreadMarker;
                /// # use icrate::Foundation::NSObject as SomeClass;
                /// # #[cfg(for_example)]
                /// use icrate::SomeFramework::SomeClass;
                /// use objc2::rc::Id;
                /// use objc2::msg_send_id;
                ///
                /// # let mtm = unsafe { MainThreadMarker::new_unchecked() };
                /// # #[cfg(doctests_not_always_run_on_main_thread)]
                /// let mtm = MainThreadMarker::new().expect("must be on the main thread");
                ///
                /// // _All_ objects are safe to allocate on the main thread!
                /// let obj = mtm.alloc::<SomeClass>();
                ///
                /// // Though more knowledge is required for safe initialization
                /// let obj: Id<SomeClass> = unsafe { msg_send_id![obj, init] };
                /// ```
                #[inline]
                pub fn alloc<T: ClassType>(self) -> Allocated<T> {
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::Alloc::send_message_id_alloc(
                                T::class(),
                            );
                            result
                        }
                    }
                }
            }
            /// Get a [`MainThreadMarker`] from a main-thread-only object.
            ///
            /// This function exists purely in the type-system, and will always
            /// succeed at runtime.
            impl<T: ?Sized + IsMainThreadOnly> From<&T> for MainThreadMarker {
                #[inline]
                fn from(_obj: &T) -> Self {
                    unsafe { Self::new_unchecked() }
                }
            }
            impl fmt::Debug for MainThreadMarker {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.debug_tuple("MainThreadMarker").finish()
                }
            }
        }
        mod to_owned {
            #![allow(unused_imports)]
            use alloc::borrow::ToOwned;
            use crate::common::*;
            use crate::Foundation::{self, NSCopying, NSMutableCopying};
            #[cfg(feature = "Foundation_NSString")]
            impl ToOwned for Foundation::NSString {
                type Owned = Id<Self>;
                fn to_owned(&self) -> Self::Owned {
                    self.copy()
                }
            }
        }
        mod util {
            #![allow(dead_code)]
            use core::ptr::NonNull;
            use objc2::mutability::IsIdCloneable;
            use objc2::rc::Id;
            use objc2::Message;
            pub(crate) fn id_ptr_cast<T: ?Sized>(
                objects: *mut Id<T>,
            ) -> *mut NonNull<T> {
                objects.cast()
            }
            fn ref_ptr_cast<T: ?Sized>(objects: *mut &T) -> *mut NonNull<T> {
                objects.cast()
            }
            pub(crate) fn ref_ptr_cast_const<T: ?Sized>(
                objects: *const &T,
            ) -> *mut NonNull<T> {
                ref_ptr_cast(objects as _)
            }
            pub(crate) fn id_ptr_cast_const<T: ?Sized>(
                objects: *const Id<T>,
            ) -> *mut NonNull<T> {
                id_ptr_cast(objects as _)
            }
            /// We should be able to access `&Id<T>` from `&self` in collection types,
            /// though that is not directly possible since we don't have raw access to the
            /// internal allocation; so instead we use this helper function to allow
            /// roughly the same functionality.
            ///
            ///
            /// # Safety
            ///
            /// The object must be stored inside a collection.
            #[inline]
            pub(crate) unsafe fn collection_retain_id<T>(obj: &T) -> Id<T>
            where
                T: Message + IsIdCloneable,
            {
                unsafe { Id::retain(obj as *const T as *mut T).unwrap_unchecked() }
            }
            /// The mutable variants give us the extra benefit that we may get `Id<T>`
            /// out, provided we've removed it from the collection first.
            ///
            ///
            /// # Safety
            ///
            /// The object must have just been removed from the mutable collection, or the
            /// collection must be consumed right after this.
            #[inline]
            pub(crate) unsafe fn mutable_collection_retain_removed_id<T>(
                obj: &T,
            ) -> Id<T>
            where
                T: Message,
            {
                unsafe { Id::retain(obj as *const T as *mut T).unwrap_unchecked() }
            }
        }
        pub use crate::generated::Foundation::*;
        pub use self::comparison_result::NSComparisonResult;
        pub use self::copying::{NSCopying, NSMutableCopying};
        pub use self::decimal::NSDecimal;
        pub use self::fast_enumeration_state::NSFastEnumerationState;
        pub use self::generics::*;
        pub use self::geometry::{
            CGFloat, CGPoint, CGRect, CGSize, NSPoint, NSRect, NSRectEdge, NSSize,
        };
        pub use self::range::NSRange;
        pub use self::thread::MainThreadMarker;
        #[cfg(feature = "Foundation_NSString")]
        #[doc(inline)]
        pub use crate::__ns_string as ns_string;
        pub use objc2::ffi::{NSInteger, NSUInteger};
        pub use objc2::runtime::{NSObject, NSObjectProtocol, NSZone};
        #[allow(unused)]
        pub(crate) type Boolean = u8;
        #[allow(unused)]
        pub(crate) type FourCharCode = u32;
        #[allow(unused)]
        pub(crate) type OSType = FourCharCode;
        #[allow(unused)]
        pub(crate) type UTF32Char = u32;
        extern "C" {}
    }
}
#[allow(unreachable_pub)]
mod generated {
    #[cfg(feature = "Foundation")]
    pub mod Foundation {
        //! # Bindings to the `Foundation` framework
        #![allow(unused_imports)]
        #![allow(deprecated)]
        #![allow(non_snake_case)]
        #![allow(non_camel_case_types)]
        #![allow(non_upper_case_globals)]
        #![allow(missing_docs)]
        #![allow(clippy::too_many_arguments)]
        #![allow(clippy::type_complexity)]
        #![allow(clippy::upper_case_acronyms)]
        #![allow(clippy::identity_op)]
        #![allow(clippy::missing_safety_doc)]
        #[link(name = "Foundation", kind = "framework")]
        extern "C" {}
        #[path = "FoundationErrors.rs"]
        mod __FoundationErrors {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub const NSFileNoSuchFileError: NSInteger = 4;
            pub const NSFileLockingError: NSInteger = 255;
            pub const NSFileReadUnknownError: NSInteger = 256;
            pub const NSFileReadNoPermissionError: NSInteger = 257;
            pub const NSFileReadInvalidFileNameError: NSInteger = 258;
            pub const NSFileReadCorruptFileError: NSInteger = 259;
            pub const NSFileReadNoSuchFileError: NSInteger = 260;
            pub const NSFileReadInapplicableStringEncodingError: NSInteger = 261;
            pub const NSFileReadUnsupportedSchemeError: NSInteger = 262;
            pub const NSFileReadTooLargeError: NSInteger = 263;
            pub const NSFileReadUnknownStringEncodingError: NSInteger = 264;
            pub const NSFileWriteUnknownError: NSInteger = 512;
            pub const NSFileWriteNoPermissionError: NSInteger = 513;
            pub const NSFileWriteInvalidFileNameError: NSInteger = 514;
            pub const NSFileWriteFileExistsError: NSInteger = 516;
            pub const NSFileWriteInapplicableStringEncodingError: NSInteger = 517;
            pub const NSFileWriteUnsupportedSchemeError: NSInteger = 518;
            pub const NSFileWriteOutOfSpaceError: NSInteger = 640;
            pub const NSFileWriteVolumeReadOnlyError: NSInteger = 642;
            pub const NSFileManagerUnmountUnknownError: NSInteger = 768;
            pub const NSFileManagerUnmountBusyError: NSInteger = 769;
            pub const NSKeyValueValidationError: NSInteger = 1024;
            pub const NSFormattingError: NSInteger = 2048;
            pub const NSUserCancelledError: NSInteger = 3072;
            pub const NSFeatureUnsupportedError: NSInteger = 3328;
            pub const NSExecutableNotLoadableError: NSInteger = 3584;
            pub const NSExecutableArchitectureMismatchError: NSInteger = 3585;
            pub const NSExecutableRuntimeMismatchError: NSInteger = 3586;
            pub const NSExecutableLoadError: NSInteger = 3587;
            pub const NSExecutableLinkError: NSInteger = 3588;
            pub const NSFileErrorMinimum: NSInteger = 0;
            pub const NSFileErrorMaximum: NSInteger = 1023;
            pub const NSValidationErrorMinimum: NSInteger = 1024;
            pub const NSValidationErrorMaximum: NSInteger = 2047;
            pub const NSExecutableErrorMinimum: NSInteger = 3584;
            pub const NSExecutableErrorMaximum: NSInteger = 3839;
            pub const NSFormattingErrorMinimum: NSInteger = 2048;
            pub const NSFormattingErrorMaximum: NSInteger = 2559;
            pub const NSPropertyListReadCorruptError: NSInteger = 3840;
            pub const NSPropertyListReadUnknownVersionError: NSInteger = 3841;
            pub const NSPropertyListReadStreamError: NSInteger = 3842;
            pub const NSPropertyListWriteStreamError: NSInteger = 3851;
            pub const NSPropertyListWriteInvalidError: NSInteger = 3852;
            pub const NSPropertyListErrorMinimum: NSInteger = 3840;
            pub const NSPropertyListErrorMaximum: NSInteger = 4095;
            pub const NSXPCConnectionInterrupted: NSInteger = 4097;
            pub const NSXPCConnectionInvalid: NSInteger = 4099;
            pub const NSXPCConnectionReplyInvalid: NSInteger = 4101;
            pub const NSXPCConnectionCodeSigningRequirementFailure: NSInteger = 4102;
            pub const NSXPCConnectionErrorMinimum: NSInteger = 4096;
            pub const NSXPCConnectionErrorMaximum: NSInteger = 4224;
            pub const NSUbiquitousFileUnavailableError: NSInteger = 4353;
            pub const NSUbiquitousFileNotUploadedDueToQuotaError: NSInteger = 4354;
            pub const NSUbiquitousFileUbiquityServerNotAvailable: NSInteger = 4355;
            pub const NSUbiquitousFileErrorMinimum: NSInteger = 4352;
            pub const NSUbiquitousFileErrorMaximum: NSInteger = 4607;
            pub const NSUserActivityHandoffFailedError: NSInteger = 4608;
            pub const NSUserActivityConnectionUnavailableError: NSInteger = 4609;
            pub const NSUserActivityRemoteApplicationTimedOutError: NSInteger = 4610;
            pub const NSUserActivityHandoffUserInfoTooLargeError: NSInteger = 4611;
            pub const NSUserActivityErrorMinimum: NSInteger = 4608;
            pub const NSUserActivityErrorMaximum: NSInteger = 4863;
            pub const NSCoderReadCorruptError: NSInteger = 4864;
            pub const NSCoderValueNotFoundError: NSInteger = 4865;
            pub const NSCoderInvalidValueError: NSInteger = 4866;
            pub const NSCoderErrorMinimum: NSInteger = 4864;
            pub const NSCoderErrorMaximum: NSInteger = 4991;
            pub const NSBundleErrorMinimum: NSInteger = 4992;
            pub const NSBundleErrorMaximum: NSInteger = 5119;
            pub const NSBundleOnDemandResourceOutOfSpaceError: NSInteger = 4992;
            pub const NSBundleOnDemandResourceExceededMaximumSizeError: NSInteger = 4993;
            pub const NSBundleOnDemandResourceInvalidTagError: NSInteger = 4994;
            pub const NSCloudSharingNetworkFailureError: NSInteger = 5120;
            pub const NSCloudSharingQuotaExceededError: NSInteger = 5121;
            pub const NSCloudSharingTooManyParticipantsError: NSInteger = 5122;
            pub const NSCloudSharingConflictError: NSInteger = 5123;
            pub const NSCloudSharingNoPermissionError: NSInteger = 5124;
            pub const NSCloudSharingOtherError: NSInteger = 5375;
            pub const NSCloudSharingErrorMinimum: NSInteger = 5120;
            pub const NSCloudSharingErrorMaximum: NSInteger = 5375;
            pub const NSCompressionFailedError: NSInteger = 5376;
            pub const NSDecompressionFailedError: NSInteger = 5377;
            pub const NSCompressionErrorMinimum: NSInteger = 5376;
            pub const NSCompressionErrorMaximum: NSInteger = 5503;
        }
        #[path = "FoundationLegacySwiftCompatibility.rs"]
        mod __FoundationLegacySwiftCompatibility {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSAffineTransform.rs"]
        mod __NSAffineTransform {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(C)]
            pub struct NSAffineTransformStruct {
                pub m11: CGFloat,
                pub m12: CGFloat,
                pub m21: CGFloat,
                pub m22: CGFloat,
                pub tX: CGFloat,
                pub tY: CGFloat,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for NSAffineTransformStruct {
                #[inline]
                fn clone(&self) -> NSAffineTransformStruct {
                    let _: ::core::clone::AssertParamIsClone<CGFloat>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSAffineTransformStruct {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSAffineTransformStruct {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["m11", "m12", "m21", "m22", "tX", "tY"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.m11,
                        &self.m12,
                        &self.m21,
                        &self.m22,
                        &self.tX,
                        &&self.tY,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "NSAffineTransformStruct",
                        names,
                        values,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSAffineTransformStruct {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSAffineTransformStruct {
                #[inline]
                fn eq(&self, other: &NSAffineTransformStruct) -> bool {
                    self.m11 == other.m11 && self.m12 == other.m12
                        && self.m21 == other.m21 && self.m22 == other.m22
                        && self.tX == other.tX && self.tY == other.tY
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSAffineTransformStruct {
                const ENCODING: objc2::Encoding = objc2::Encoding::Struct(
                    "?",
                    &[
                        <CGFloat as objc2::Encode>::ENCODING,
                        <CGFloat as objc2::Encode>::ENCODING,
                        <CGFloat as objc2::Encode>::ENCODING,
                        <CGFloat as objc2::Encode>::ENCODING,
                        <CGFloat as objc2::Encode>::ENCODING,
                        <CGFloat as objc2::Encode>::ENCODING,
                    ],
                );
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSAffineTransformStruct {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            unsafe impl Send for NSAffineTransformStruct {}
            unsafe impl Sync for NSAffineTransformStruct {}
        }
        #[path = "NSAppleEventDescriptor.rs"]
        mod __NSAppleEventDescriptor {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSAppleEventSendOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSAppleEventSendOptions {
                #[inline]
                fn clone(&self) -> NSAppleEventSendOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSAppleEventSendOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSAppleEventSendOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSAppleEventSendOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSAppleEventSendOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSAppleEventSendOptions {
                #[inline]
                fn eq(&self, other: &NSAppleEventSendOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSAppleEventSendOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSAppleEventSendOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSAppleEventSendOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSAppleEventSendOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSAppleEventSendOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSAppleEventSendOptions {
                #[inline]
                fn cmp(&self, other: &NSAppleEventSendOptions) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSAppleEventSendOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSAppleEventSendOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSAppleEventSendOptions {
                #[allow(non_upper_case_globals)]
                pub const NSAppleEventSendNoReply: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSAppleEventSendQueueReply: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSAppleEventSendWaitForReply: Self = Self(3);
                #[allow(non_upper_case_globals)]
                pub const NSAppleEventSendNeverInteract: Self = Self(16);
                #[allow(non_upper_case_globals)]
                pub const NSAppleEventSendCanInteract: Self = Self(32);
                #[allow(non_upper_case_globals)]
                pub const NSAppleEventSendAlwaysInteract: Self = Self(48);
                #[allow(non_upper_case_globals)]
                pub const NSAppleEventSendCanSwitchLayer: Self = Self(64);
                #[allow(non_upper_case_globals)]
                pub const NSAppleEventSendDontRecord: Self = Self(4096);
                #[allow(non_upper_case_globals)]
                pub const NSAppleEventSendDontExecute: Self = Self(8192);
                #[allow(non_upper_case_globals)]
                pub const NSAppleEventSendDontAnnotate: Self = Self(65536);
                #[allow(non_upper_case_globals)]
                pub const NSAppleEventSendDefaultOptions: Self = Self(35);
            }
        }
        #[path = "NSAppleEventManager.rs"]
        mod __NSAppleEventManager {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub type NSAppleEventManagerSuspensionID = *mut c_void;
            extern "C" {
                pub static NSAppleEventTimeOutDefault: c_double;
            }
            extern "C" {
                pub static NSAppleEventTimeOutNone: c_double;
            }
            extern "C" {
                pub static NSAppleEventManagerWillProcessFirstEventNotification: &'static NSNotificationName;
            }
        }
        #[path = "NSAppleScript.rs"]
        mod __NSAppleScript {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSAppleScriptErrorMessage: &'static NSString;
            }
            extern "C" {
                pub static NSAppleScriptErrorNumber: &'static NSString;
            }
            extern "C" {
                pub static NSAppleScriptErrorAppName: &'static NSString;
            }
            extern "C" {
                pub static NSAppleScriptErrorBriefMessage: &'static NSString;
            }
            extern "C" {
                pub static NSAppleScriptErrorRange: &'static NSString;
            }
        }
        #[path = "NSArchiver.rs"]
        mod __NSArchiver {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            /// Category "NSArchiverCallback" on [`NSObject`].
            #[doc(alias = "NSArchiverCallback")]
            pub unsafe trait NSObjectNSArchiverCallback: ClassType {
                unsafe fn classForArchiver(&self) -> Option<&'static AnyClass>
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("classForArchiver\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                #[doc(hidden)]
                const __UNSAFE_INNER: ();
            }
            unsafe impl NSObjectNSArchiverCallback for NSObject {
                const __UNSAFE_INNER: () = ();
            }
        }
        #[path = "NSArray.rs"]
        mod __NSArray {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSBinarySearchingOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSBinarySearchingOptions {
                #[inline]
                fn clone(&self) -> NSBinarySearchingOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSBinarySearchingOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSBinarySearchingOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSBinarySearchingOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSBinarySearchingOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSBinarySearchingOptions {
                #[inline]
                fn eq(&self, other: &NSBinarySearchingOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSBinarySearchingOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSBinarySearchingOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSBinarySearchingOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSBinarySearchingOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSBinarySearchingOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSBinarySearchingOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSBinarySearchingOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSBinarySearchingOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSBinarySearchingOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSBinarySearchingOptions {
                #[allow(non_upper_case_globals)]
                pub const NSBinarySearchingFirstEqual: Self = Self(1 << 8);
                #[allow(non_upper_case_globals)]
                pub const NSBinarySearchingLastEqual: Self = Self(1 << 9);
                #[allow(non_upper_case_globals)]
                pub const NSBinarySearchingInsertionIndex: Self = Self(1 << 10);
            }
        }
        #[path = "NSAttributedString.rs"]
        mod __NSAttributedString {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub type NSAttributedStringKey = NSString;
            pub type NSAttributedStringFormattingContextKey = NSString;
            extern "C" {
                pub static NSInflectionConceptsKey: &'static NSAttributedStringFormattingContextKey;
            }
            #[repr(transparent)]
            pub struct NSAttributedStringEnumerationOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSAttributedStringEnumerationOptions {
                #[inline]
                fn clone(&self) -> NSAttributedStringEnumerationOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSAttributedStringEnumerationOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSAttributedStringEnumerationOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSAttributedStringEnumerationOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSAttributedStringEnumerationOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSAttributedStringEnumerationOptions {
                #[inline]
                fn eq(&self, other: &NSAttributedStringEnumerationOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSAttributedStringEnumerationOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSAttributedStringEnumerationOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSAttributedStringEnumerationOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSAttributedStringEnumerationOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSAttributedStringEnumerationOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSAttributedStringEnumerationOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSAttributedStringEnumerationOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSAttributedStringEnumerationOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSAttributedStringEnumerationOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSAttributedStringEnumerationOptions {
                #[allow(non_upper_case_globals)]
                pub const NSAttributedStringEnumerationReverse: Self = Self(1 << 1);
                #[allow(non_upper_case_globals)]
                pub const NSAttributedStringEnumerationLongestEffectiveRangeNotRequired: Self = Self(
                    1 << 20,
                );
            }
            #[repr(transparent)]
            pub struct NSInlinePresentationIntent(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSInlinePresentationIntent {
                #[inline]
                fn clone(&self) -> NSInlinePresentationIntent {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSInlinePresentationIntent {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSInlinePresentationIntent {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSInlinePresentationIntent",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSInlinePresentationIntent {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSInlinePresentationIntent {
                #[inline]
                fn eq(&self, other: &NSInlinePresentationIntent) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSInlinePresentationIntent {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSInlinePresentationIntent {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSInlinePresentationIntent {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSInlinePresentationIntent {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSInlinePresentationIntent,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSInlinePresentationIntent {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSInlinePresentationIntent,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSInlinePresentationIntent {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSInlinePresentationIntent {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSInlinePresentationIntent {
                #[doc(alias = "NSInlinePresentationIntentEmphasized")]
                #[allow(non_upper_case_globals)]
                pub const Emphasized: Self = Self(1 << 0);
                #[doc(alias = "NSInlinePresentationIntentStronglyEmphasized")]
                #[allow(non_upper_case_globals)]
                pub const StronglyEmphasized: Self = Self(1 << 1);
                #[doc(alias = "NSInlinePresentationIntentCode")]
                #[allow(non_upper_case_globals)]
                pub const Code: Self = Self(1 << 2);
                #[doc(alias = "NSInlinePresentationIntentStrikethrough")]
                #[allow(non_upper_case_globals)]
                pub const Strikethrough: Self = Self(1 << 5);
                #[doc(alias = "NSInlinePresentationIntentSoftBreak")]
                #[allow(non_upper_case_globals)]
                pub const SoftBreak: Self = Self(1 << 6);
                #[doc(alias = "NSInlinePresentationIntentLineBreak")]
                #[allow(non_upper_case_globals)]
                pub const LineBreak: Self = Self(1 << 7);
                #[doc(alias = "NSInlinePresentationIntentInlineHTML")]
                #[allow(non_upper_case_globals)]
                pub const InlineHTML: Self = Self(1 << 8);
                #[doc(alias = "NSInlinePresentationIntentBlockHTML")]
                #[allow(non_upper_case_globals)]
                pub const BlockHTML: Self = Self(1 << 9);
            }
            extern "C" {
                pub static NSInlinePresentationIntentAttributeName: &'static NSAttributedStringKey;
            }
            extern "C" {
                pub static NSAlternateDescriptionAttributeName: &'static NSAttributedStringKey;
            }
            extern "C" {
                pub static NSImageURLAttributeName: &'static NSAttributedStringKey;
            }
            extern "C" {
                pub static NSLanguageIdentifierAttributeName: &'static NSAttributedStringKey;
            }
            extern "C" {
                pub static NSMarkdownSourcePositionAttributeName: &'static NSAttributedStringKey;
            }
            #[repr(transparent)]
            pub struct NSAttributedStringMarkdownParsingFailurePolicy(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone
            for NSAttributedStringMarkdownParsingFailurePolicy {
                #[inline]
                fn clone(&self) -> NSAttributedStringMarkdownParsingFailurePolicy {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy
            for NSAttributedStringMarkdownParsingFailurePolicy {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSAttributedStringMarkdownParsingFailurePolicy {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSAttributedStringMarkdownParsingFailurePolicy",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSAttributedStringMarkdownParsingFailurePolicy {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq
            for NSAttributedStringMarkdownParsingFailurePolicy {
                #[inline]
                fn eq(
                    &self,
                    other: &NSAttributedStringMarkdownParsingFailurePolicy,
                ) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq
            for NSAttributedStringMarkdownParsingFailurePolicy {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSAttributedStringMarkdownParsingFailurePolicy {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSAttributedStringMarkdownParsingFailurePolicy {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd
            for NSAttributedStringMarkdownParsingFailurePolicy {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSAttributedStringMarkdownParsingFailurePolicy,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSAttributedStringMarkdownParsingFailurePolicy {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSAttributedStringMarkdownParsingFailurePolicy,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode
            for NSAttributedStringMarkdownParsingFailurePolicy {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode
            for NSAttributedStringMarkdownParsingFailurePolicy {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSAttributedStringMarkdownParsingFailurePolicy {
                #[allow(non_upper_case_globals)]
                pub const NSAttributedStringMarkdownParsingFailureReturnError: Self = Self(
                    0,
                );
                #[allow(non_upper_case_globals)]
                pub const NSAttributedStringMarkdownParsingFailureReturnPartiallyParsedIfPossible: Self = Self(
                    1,
                );
            }
            #[repr(transparent)]
            pub struct NSAttributedStringMarkdownInterpretedSyntax(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSAttributedStringMarkdownInterpretedSyntax {
                #[inline]
                fn clone(&self) -> NSAttributedStringMarkdownInterpretedSyntax {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSAttributedStringMarkdownInterpretedSyntax {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSAttributedStringMarkdownInterpretedSyntax {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSAttributedStringMarkdownInterpretedSyntax",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSAttributedStringMarkdownInterpretedSyntax {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSAttributedStringMarkdownInterpretedSyntax {
                #[inline]
                fn eq(
                    &self,
                    other: &NSAttributedStringMarkdownInterpretedSyntax,
                ) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq
            for NSAttributedStringMarkdownInterpretedSyntax {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSAttributedStringMarkdownInterpretedSyntax {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSAttributedStringMarkdownInterpretedSyntax {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd
            for NSAttributedStringMarkdownInterpretedSyntax {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSAttributedStringMarkdownInterpretedSyntax,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSAttributedStringMarkdownInterpretedSyntax {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSAttributedStringMarkdownInterpretedSyntax,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSAttributedStringMarkdownInterpretedSyntax {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode
            for NSAttributedStringMarkdownInterpretedSyntax {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSAttributedStringMarkdownInterpretedSyntax {
                #[doc(alias = "NSAttributedStringMarkdownInterpretedSyntaxFull")]
                #[allow(non_upper_case_globals)]
                pub const Full: Self = Self(0);
                #[doc(alias = "NSAttributedStringMarkdownInterpretedSyntaxInlineOnly")]
                #[allow(non_upper_case_globals)]
                pub const InlineOnly: Self = Self(1);
                #[doc(
                    alias = "NSAttributedStringMarkdownInterpretedSyntaxInlineOnlyPreservingWhitespace"
                )]
                #[allow(non_upper_case_globals)]
                pub const InlineOnlyPreservingWhitespace: Self = Self(2);
            }
            #[repr(transparent)]
            pub struct NSAttributedStringFormattingOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSAttributedStringFormattingOptions {
                #[inline]
                fn clone(&self) -> NSAttributedStringFormattingOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSAttributedStringFormattingOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSAttributedStringFormattingOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSAttributedStringFormattingOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSAttributedStringFormattingOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSAttributedStringFormattingOptions {
                #[inline]
                fn eq(&self, other: &NSAttributedStringFormattingOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSAttributedStringFormattingOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSAttributedStringFormattingOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSAttributedStringFormattingOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSAttributedStringFormattingOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSAttributedStringFormattingOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSAttributedStringFormattingOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSAttributedStringFormattingOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSAttributedStringFormattingOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSAttributedStringFormattingOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSAttributedStringFormattingOptions {
                #[allow(non_upper_case_globals)]
                pub const NSAttributedStringFormattingInsertArgumentAttributesWithoutMerging: Self = Self(
                    1 << 0,
                );
                #[allow(non_upper_case_globals)]
                pub const NSAttributedStringFormattingApplyReplacementIndexAttribute: Self = Self(
                    1 << 1,
                );
            }
            extern "C" {
                pub static NSReplacementIndexAttributeName: &'static NSAttributedStringKey;
            }
            extern "C" {
                pub static NSMorphologyAttributeName: &'static NSAttributedStringKey;
            }
            extern "C" {
                pub static NSInflectionRuleAttributeName: &'static NSAttributedStringKey;
            }
            extern "C" {
                pub static NSInflectionAgreementArgumentAttributeName: &'static NSAttributedStringKey;
            }
            extern "C" {
                pub static NSInflectionAgreementConceptAttributeName: &'static NSAttributedStringKey;
            }
            extern "C" {
                pub static NSInflectionReferentConceptAttributeName: &'static NSAttributedStringKey;
            }
            extern "C" {
                pub static NSInflectionAlternativeAttributeName: &'static NSAttributedStringKey;
            }
            extern "C" {
                pub static NSPresentationIntentAttributeName: &'static NSAttributedStringKey;
            }
            #[repr(transparent)]
            pub struct NSPresentationIntentKind(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSPresentationIntentKind {
                #[inline]
                fn clone(&self) -> NSPresentationIntentKind {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSPresentationIntentKind {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSPresentationIntentKind {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSPresentationIntentKind",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSPresentationIntentKind {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSPresentationIntentKind {
                #[inline]
                fn eq(&self, other: &NSPresentationIntentKind) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSPresentationIntentKind {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSPresentationIntentKind {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSPresentationIntentKind {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSPresentationIntentKind {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSPresentationIntentKind,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSPresentationIntentKind {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSPresentationIntentKind,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSPresentationIntentKind {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSPresentationIntentKind {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSPresentationIntentKind {
                #[doc(alias = "NSPresentationIntentKindParagraph")]
                #[allow(non_upper_case_globals)]
                pub const Paragraph: Self = Self(0);
                #[doc(alias = "NSPresentationIntentKindHeader")]
                #[allow(non_upper_case_globals)]
                pub const Header: Self = Self(1);
                #[doc(alias = "NSPresentationIntentKindOrderedList")]
                #[allow(non_upper_case_globals)]
                pub const OrderedList: Self = Self(2);
                #[doc(alias = "NSPresentationIntentKindUnorderedList")]
                #[allow(non_upper_case_globals)]
                pub const UnorderedList: Self = Self(3);
                #[doc(alias = "NSPresentationIntentKindListItem")]
                #[allow(non_upper_case_globals)]
                pub const ListItem: Self = Self(4);
                #[doc(alias = "NSPresentationIntentKindCodeBlock")]
                #[allow(non_upper_case_globals)]
                pub const CodeBlock: Self = Self(5);
                #[doc(alias = "NSPresentationIntentKindBlockQuote")]
                #[allow(non_upper_case_globals)]
                pub const BlockQuote: Self = Self(6);
                #[doc(alias = "NSPresentationIntentKindThematicBreak")]
                #[allow(non_upper_case_globals)]
                pub const ThematicBreak: Self = Self(7);
                #[doc(alias = "NSPresentationIntentKindTable")]
                #[allow(non_upper_case_globals)]
                pub const Table: Self = Self(8);
                #[doc(alias = "NSPresentationIntentKindTableHeaderRow")]
                #[allow(non_upper_case_globals)]
                pub const TableHeaderRow: Self = Self(9);
                #[doc(alias = "NSPresentationIntentKindTableRow")]
                #[allow(non_upper_case_globals)]
                pub const TableRow: Self = Self(10);
                #[doc(alias = "NSPresentationIntentKindTableCell")]
                #[allow(non_upper_case_globals)]
                pub const TableCell: Self = Self(11);
            }
            #[repr(transparent)]
            pub struct NSPresentationIntentTableColumnAlignment(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSPresentationIntentTableColumnAlignment {
                #[inline]
                fn clone(&self) -> NSPresentationIntentTableColumnAlignment {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSPresentationIntentTableColumnAlignment {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSPresentationIntentTableColumnAlignment {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSPresentationIntentTableColumnAlignment",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSPresentationIntentTableColumnAlignment {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSPresentationIntentTableColumnAlignment {
                #[inline]
                fn eq(&self, other: &NSPresentationIntentTableColumnAlignment) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq
            for NSPresentationIntentTableColumnAlignment {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSPresentationIntentTableColumnAlignment {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSPresentationIntentTableColumnAlignment {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSPresentationIntentTableColumnAlignment {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSPresentationIntentTableColumnAlignment,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSPresentationIntentTableColumnAlignment {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSPresentationIntentTableColumnAlignment,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSPresentationIntentTableColumnAlignment {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSPresentationIntentTableColumnAlignment {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSPresentationIntentTableColumnAlignment {
                #[doc(alias = "NSPresentationIntentTableColumnAlignmentLeft")]
                #[allow(non_upper_case_globals)]
                pub const Left: Self = Self(0);
                #[doc(alias = "NSPresentationIntentTableColumnAlignmentCenter")]
                #[allow(non_upper_case_globals)]
                pub const Center: Self = Self(1);
                #[doc(alias = "NSPresentationIntentTableColumnAlignmentRight")]
                #[allow(non_upper_case_globals)]
                pub const Right: Self = Self(2);
            }
        }
        #[path = "NSAutoreleasePool.rs"]
        mod __NSAutoreleasePool {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSBackgroundActivityScheduler.rs"]
        mod __NSBackgroundActivityScheduler {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSBackgroundActivityResult(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSBackgroundActivityResult {
                #[inline]
                fn clone(&self) -> NSBackgroundActivityResult {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSBackgroundActivityResult {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSBackgroundActivityResult {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSBackgroundActivityResult",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSBackgroundActivityResult {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSBackgroundActivityResult {
                #[inline]
                fn eq(&self, other: &NSBackgroundActivityResult) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSBackgroundActivityResult {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSBackgroundActivityResult {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSBackgroundActivityResult {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSBackgroundActivityResult {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSBackgroundActivityResult,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSBackgroundActivityResult {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSBackgroundActivityResult,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSBackgroundActivityResult {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSBackgroundActivityResult {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSBackgroundActivityResult {
                #[doc(alias = "NSBackgroundActivityResultFinished")]
                #[allow(non_upper_case_globals)]
                pub const Finished: Self = Self(1);
                #[doc(alias = "NSBackgroundActivityResultDeferred")]
                #[allow(non_upper_case_globals)]
                pub const Deferred: Self = Self(2);
            }
            pub type NSBackgroundActivityCompletionHandler = *mut Block<
                dyn Fn(NSBackgroundActivityResult),
            >;
        }
        #[path = "NSBundle.rs"]
        mod __NSBundle {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub const NSBundleExecutableArchitectureI386: c_uint = 0x00000007;
            pub const NSBundleExecutableArchitecturePPC: c_uint = 0x00000012;
            pub const NSBundleExecutableArchitectureX86_64: c_uint = 0x01000007;
            pub const NSBundleExecutableArchitecturePPC64: c_uint = 0x01000012;
            pub const NSBundleExecutableArchitectureARM64: c_uint = 0x0100000c;
            /// NSBundleExtensionMethods
            #[cfg(feature = "Foundation_NSString")]
            impl NSString {
                pub unsafe fn variantFittingPresentationWidth(
                    &self,
                    width: NSInteger,
                ) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("variantFittingPresentationWidth:\u{0}")
                                        }
                                    }
                                },
                                (width,),
                            )
                        }
                    }
                }
            }
            extern "C" {
                pub static NSBundleDidLoadNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSLoadedClasses: &'static NSString;
            }
            extern "C" {
                pub static NSBundleResourceRequestLowDiskSpaceNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSBundleResourceRequestLoadingPriorityUrgent: c_double;
            }
        }
        #[path = "NSByteCountFormatter.rs"]
        mod __NSByteCountFormatter {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSByteCountFormatterUnits(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSByteCountFormatterUnits {
                #[inline]
                fn clone(&self) -> NSByteCountFormatterUnits {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSByteCountFormatterUnits {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSByteCountFormatterUnits {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSByteCountFormatterUnits",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSByteCountFormatterUnits {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSByteCountFormatterUnits {
                #[inline]
                fn eq(&self, other: &NSByteCountFormatterUnits) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSByteCountFormatterUnits {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSByteCountFormatterUnits {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSByteCountFormatterUnits {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSByteCountFormatterUnits {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSByteCountFormatterUnits,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSByteCountFormatterUnits {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSByteCountFormatterUnits,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSByteCountFormatterUnits {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSByteCountFormatterUnits {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSByteCountFormatterUnits {
                #[allow(non_upper_case_globals)]
                pub const NSByteCountFormatterUseDefault: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSByteCountFormatterUseBytes: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSByteCountFormatterUseKB: Self = Self(1 << 1);
                #[allow(non_upper_case_globals)]
                pub const NSByteCountFormatterUseMB: Self = Self(1 << 2);
                #[allow(non_upper_case_globals)]
                pub const NSByteCountFormatterUseGB: Self = Self(1 << 3);
                #[allow(non_upper_case_globals)]
                pub const NSByteCountFormatterUseTB: Self = Self(1 << 4);
                #[allow(non_upper_case_globals)]
                pub const NSByteCountFormatterUsePB: Self = Self(1 << 5);
                #[allow(non_upper_case_globals)]
                pub const NSByteCountFormatterUseEB: Self = Self(1 << 6);
                #[allow(non_upper_case_globals)]
                pub const NSByteCountFormatterUseZB: Self = Self(1 << 7);
                #[allow(non_upper_case_globals)]
                pub const NSByteCountFormatterUseYBOrHigher: Self = Self(0x0FF << 8);
                #[allow(non_upper_case_globals)]
                pub const NSByteCountFormatterUseAll: Self = Self(0x0FFFF);
            }
            #[repr(transparent)]
            pub struct NSByteCountFormatterCountStyle(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSByteCountFormatterCountStyle {
                #[inline]
                fn clone(&self) -> NSByteCountFormatterCountStyle {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSByteCountFormatterCountStyle {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSByteCountFormatterCountStyle {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSByteCountFormatterCountStyle",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSByteCountFormatterCountStyle {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSByteCountFormatterCountStyle {
                #[inline]
                fn eq(&self, other: &NSByteCountFormatterCountStyle) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSByteCountFormatterCountStyle {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSByteCountFormatterCountStyle {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSByteCountFormatterCountStyle {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSByteCountFormatterCountStyle {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSByteCountFormatterCountStyle,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSByteCountFormatterCountStyle {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSByteCountFormatterCountStyle,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSByteCountFormatterCountStyle {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSByteCountFormatterCountStyle {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSByteCountFormatterCountStyle {
                #[doc(alias = "NSByteCountFormatterCountStyleFile")]
                #[allow(non_upper_case_globals)]
                pub const File: Self = Self(0);
                #[doc(alias = "NSByteCountFormatterCountStyleMemory")]
                #[allow(non_upper_case_globals)]
                pub const Memory: Self = Self(1);
                #[doc(alias = "NSByteCountFormatterCountStyleDecimal")]
                #[allow(non_upper_case_globals)]
                pub const Decimal: Self = Self(2);
                #[doc(alias = "NSByteCountFormatterCountStyleBinary")]
                #[allow(non_upper_case_globals)]
                pub const Binary: Self = Self(3);
            }
        }
        #[path = "NSByteOrder.rs"]
        mod __NSByteOrder {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(C)]
            pub struct NSSwappedFloat {
                pub v: c_uint,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for NSSwappedFloat {
                #[inline]
                fn clone(&self) -> NSSwappedFloat {
                    let _: ::core::clone::AssertParamIsClone<c_uint>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSSwappedFloat {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSSwappedFloat {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "NSSwappedFloat",
                        "v",
                        &&self.v,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSSwappedFloat {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSSwappedFloat {
                #[inline]
                fn eq(&self, other: &NSSwappedFloat) -> bool {
                    self.v == other.v
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSSwappedFloat {
                const ENCODING: objc2::Encoding = objc2::Encoding::Struct(
                    "?",
                    &[<c_uint as objc2::Encode>::ENCODING],
                );
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSSwappedFloat {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            unsafe impl Send for NSSwappedFloat {}
            unsafe impl Sync for NSSwappedFloat {}
            #[repr(C)]
            pub struct NSSwappedDouble {
                pub v: c_ulonglong,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for NSSwappedDouble {
                #[inline]
                fn clone(&self) -> NSSwappedDouble {
                    let _: ::core::clone::AssertParamIsClone<c_ulonglong>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSSwappedDouble {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSSwappedDouble {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "NSSwappedDouble",
                        "v",
                        &&self.v,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSSwappedDouble {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSSwappedDouble {
                #[inline]
                fn eq(&self, other: &NSSwappedDouble) -> bool {
                    self.v == other.v
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSSwappedDouble {
                const ENCODING: objc2::Encoding = objc2::Encoding::Struct(
                    "?",
                    &[<c_ulonglong as objc2::Encode>::ENCODING],
                );
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSSwappedDouble {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            unsafe impl Send for NSSwappedDouble {}
            unsafe impl Sync for NSSwappedDouble {}
        }
        #[path = "NSCache.rs"]
        mod __NSCache {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub unsafe trait NSCacheDelegate: NSObjectProtocol {}
            unsafe impl<T> NSCacheDelegate for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSCacheDelegate,
            {}
            unsafe impl ProtocolType for dyn NSCacheDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSCacheDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T> for dyn NSCacheDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message + NSCacheDelegate,
            {
                const __INNER: () = ();
            }
        }
        #[path = "NSCalendar.rs"]
        mod __NSCalendar {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub type NSCalendarIdentifier = NSString;
            extern "C" {
                pub static NSCalendarIdentifierGregorian: &'static NSCalendarIdentifier;
            }
            extern "C" {
                pub static NSCalendarIdentifierBuddhist: &'static NSCalendarIdentifier;
            }
            extern "C" {
                pub static NSCalendarIdentifierChinese: &'static NSCalendarIdentifier;
            }
            extern "C" {
                pub static NSCalendarIdentifierCoptic: &'static NSCalendarIdentifier;
            }
            extern "C" {
                pub static NSCalendarIdentifierEthiopicAmeteMihret: &'static NSCalendarIdentifier;
            }
            extern "C" {
                pub static NSCalendarIdentifierEthiopicAmeteAlem: &'static NSCalendarIdentifier;
            }
            extern "C" {
                pub static NSCalendarIdentifierHebrew: &'static NSCalendarIdentifier;
            }
            extern "C" {
                pub static NSCalendarIdentifierISO8601: &'static NSCalendarIdentifier;
            }
            extern "C" {
                pub static NSCalendarIdentifierIndian: &'static NSCalendarIdentifier;
            }
            extern "C" {
                pub static NSCalendarIdentifierIslamic: &'static NSCalendarIdentifier;
            }
            extern "C" {
                pub static NSCalendarIdentifierIslamicCivil: &'static NSCalendarIdentifier;
            }
            extern "C" {
                pub static NSCalendarIdentifierJapanese: &'static NSCalendarIdentifier;
            }
            extern "C" {
                pub static NSCalendarIdentifierPersian: &'static NSCalendarIdentifier;
            }
            extern "C" {
                pub static NSCalendarIdentifierRepublicOfChina: &'static NSCalendarIdentifier;
            }
            extern "C" {
                pub static NSCalendarIdentifierIslamicTabular: &'static NSCalendarIdentifier;
            }
            extern "C" {
                pub static NSCalendarIdentifierIslamicUmmAlQura: &'static NSCalendarIdentifier;
            }
            #[repr(transparent)]
            pub struct NSCalendarUnit(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSCalendarUnit {
                #[inline]
                fn clone(&self) -> NSCalendarUnit {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSCalendarUnit {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSCalendarUnit {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSCalendarUnit",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSCalendarUnit {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSCalendarUnit {
                #[inline]
                fn eq(&self, other: &NSCalendarUnit) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSCalendarUnit {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSCalendarUnit {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSCalendarUnit {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSCalendarUnit {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSCalendarUnit,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSCalendarUnit {
                #[inline]
                fn cmp(&self, other: &NSCalendarUnit) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSCalendarUnit {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSCalendarUnit {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSCalendarUnit {
                #[doc(alias = "NSCalendarUnitEra")]
                #[allow(non_upper_case_globals)]
                pub const Era: Self = Self(2);
                #[doc(alias = "NSCalendarUnitYear")]
                #[allow(non_upper_case_globals)]
                pub const Year: Self = Self(4);
                #[doc(alias = "NSCalendarUnitMonth")]
                #[allow(non_upper_case_globals)]
                pub const Month: Self = Self(8);
                #[doc(alias = "NSCalendarUnitDay")]
                #[allow(non_upper_case_globals)]
                pub const Day: Self = Self(16);
                #[doc(alias = "NSCalendarUnitHour")]
                #[allow(non_upper_case_globals)]
                pub const Hour: Self = Self(32);
                #[doc(alias = "NSCalendarUnitMinute")]
                #[allow(non_upper_case_globals)]
                pub const Minute: Self = Self(64);
                #[doc(alias = "NSCalendarUnitSecond")]
                #[allow(non_upper_case_globals)]
                pub const Second: Self = Self(128);
                #[doc(alias = "NSCalendarUnitWeekday")]
                #[allow(non_upper_case_globals)]
                pub const Weekday: Self = Self(512);
                #[doc(alias = "NSCalendarUnitWeekdayOrdinal")]
                #[allow(non_upper_case_globals)]
                pub const WeekdayOrdinal: Self = Self(1024);
                #[doc(alias = "NSCalendarUnitQuarter")]
                #[allow(non_upper_case_globals)]
                pub const Quarter: Self = Self(2048);
                #[doc(alias = "NSCalendarUnitWeekOfMonth")]
                #[allow(non_upper_case_globals)]
                pub const WeekOfMonth: Self = Self(4096);
                #[doc(alias = "NSCalendarUnitWeekOfYear")]
                #[allow(non_upper_case_globals)]
                pub const WeekOfYear: Self = Self(8192);
                #[doc(alias = "NSCalendarUnitYearForWeekOfYear")]
                #[allow(non_upper_case_globals)]
                pub const YearForWeekOfYear: Self = Self(16384);
                #[doc(alias = "NSCalendarUnitNanosecond")]
                #[allow(non_upper_case_globals)]
                pub const Nanosecond: Self = Self(32768);
                #[doc(alias = "NSCalendarUnitCalendar")]
                #[allow(non_upper_case_globals)]
                pub const Calendar: Self = Self(1048576);
                #[doc(alias = "NSCalendarUnitTimeZone")]
                #[allow(non_upper_case_globals)]
                pub const TimeZone: Self = Self(2097152);
                #[deprecated]
                #[allow(non_upper_case_globals)]
                pub const NSEraCalendarUnit: Self = Self(2);
                #[deprecated]
                #[allow(non_upper_case_globals)]
                pub const NSYearCalendarUnit: Self = Self(4);
                #[deprecated]
                #[allow(non_upper_case_globals)]
                pub const NSMonthCalendarUnit: Self = Self(8);
                #[deprecated]
                #[allow(non_upper_case_globals)]
                pub const NSDayCalendarUnit: Self = Self(16);
                #[deprecated]
                #[allow(non_upper_case_globals)]
                pub const NSHourCalendarUnit: Self = Self(32);
                #[deprecated]
                #[allow(non_upper_case_globals)]
                pub const NSMinuteCalendarUnit: Self = Self(64);
                #[deprecated]
                #[allow(non_upper_case_globals)]
                pub const NSSecondCalendarUnit: Self = Self(128);
                #[deprecated = "NSCalendarUnitWeekOfMonth or NSCalendarUnitWeekOfYear, depending on which you mean"]
                #[allow(non_upper_case_globals)]
                pub const NSWeekCalendarUnit: Self = Self(256);
                #[deprecated]
                #[allow(non_upper_case_globals)]
                pub const NSWeekdayCalendarUnit: Self = Self(512);
                #[deprecated]
                #[allow(non_upper_case_globals)]
                pub const NSWeekdayOrdinalCalendarUnit: Self = Self(1024);
                #[deprecated]
                #[allow(non_upper_case_globals)]
                pub const NSQuarterCalendarUnit: Self = Self(2048);
                #[deprecated]
                #[allow(non_upper_case_globals)]
                pub const NSWeekOfMonthCalendarUnit: Self = Self(4096);
                #[deprecated]
                #[allow(non_upper_case_globals)]
                pub const NSWeekOfYearCalendarUnit: Self = Self(8192);
                #[deprecated]
                #[allow(non_upper_case_globals)]
                pub const NSYearForWeekOfYearCalendarUnit: Self = Self(16384);
                #[deprecated]
                #[allow(non_upper_case_globals)]
                pub const NSCalendarCalendarUnit: Self = Self(1048576);
                #[deprecated]
                #[allow(non_upper_case_globals)]
                pub const NSTimeZoneCalendarUnit: Self = Self(2097152);
            }
            #[repr(transparent)]
            pub struct NSCalendarOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSCalendarOptions {
                #[inline]
                fn clone(&self) -> NSCalendarOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSCalendarOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSCalendarOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSCalendarOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSCalendarOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSCalendarOptions {
                #[inline]
                fn eq(&self, other: &NSCalendarOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSCalendarOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSCalendarOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSCalendarOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSCalendarOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSCalendarOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSCalendarOptions {
                #[inline]
                fn cmp(&self, other: &NSCalendarOptions) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSCalendarOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSCalendarOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSCalendarOptions {
                #[allow(non_upper_case_globals)]
                pub const NSCalendarWrapComponents: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSCalendarMatchStrictly: Self = Self(1 << 1);
                #[allow(non_upper_case_globals)]
                pub const NSCalendarSearchBackwards: Self = Self(1 << 2);
                #[allow(non_upper_case_globals)]
                pub const NSCalendarMatchPreviousTimePreservingSmallerUnits: Self = Self(
                    1 << 8,
                );
                #[allow(non_upper_case_globals)]
                pub const NSCalendarMatchNextTimePreservingSmallerUnits: Self = Self(
                    1 << 9,
                );
                #[allow(non_upper_case_globals)]
                pub const NSCalendarMatchNextTime: Self = Self(1 << 10);
                #[allow(non_upper_case_globals)]
                pub const NSCalendarMatchFirst: Self = Self(1 << 12);
                #[allow(non_upper_case_globals)]
                pub const NSCalendarMatchLast: Self = Self(1 << 13);
            }
            extern "C" {
                pub static NSCalendarDayChangedNotification: &'static NSNotificationName;
            }
            pub const NSDateComponentUndefined: NSInteger = NSIntegerMax as _;
            #[deprecated]
            pub const NSUndefinedDateComponent: NSInteger = NSDateComponentUndefined;
        }
        #[path = "NSCalendarDate.rs"]
        mod __NSCalendarDate {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSCharacterSet.rs"]
        mod __NSCharacterSet {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub const NSOpenStepUnicodeReservedBase: c_uint = 0xF400;
        }
        #[path = "NSClassDescription.rs"]
        mod __NSClassDescription {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            /// Category "NSClassDescriptionPrimitives" on [`NSObject`].
            #[doc(alias = "NSClassDescriptionPrimitives")]
            pub unsafe trait NSObjectNSClassDescriptionPrimitives: ClassType {
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn inverseForRelationshipKey(
                    &self,
                    relationship_key: &NSString,
                ) -> Option<Id<NSString>>
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("inverseForRelationshipKey:\u{0}") }
                                    }
                                },
                                (relationship_key,),
                            )
                        }
                    }
                }
                #[doc(hidden)]
                const __UNSAFE_INNER: ();
            }
            unsafe impl NSObjectNSClassDescriptionPrimitives for NSObject {
                const __UNSAFE_INNER: () = ();
            }
            extern "C" {
                pub static NSClassDescriptionNeededForClassNotification: &'static NSNotificationName;
            }
        }
        #[path = "NSCoder.rs"]
        mod __NSCoder {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSDecodingFailurePolicy(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSDecodingFailurePolicy {
                #[inline]
                fn clone(&self) -> NSDecodingFailurePolicy {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSDecodingFailurePolicy {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSDecodingFailurePolicy {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSDecodingFailurePolicy",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSDecodingFailurePolicy {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSDecodingFailurePolicy {
                #[inline]
                fn eq(&self, other: &NSDecodingFailurePolicy) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSDecodingFailurePolicy {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSDecodingFailurePolicy {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSDecodingFailurePolicy {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSDecodingFailurePolicy {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSDecodingFailurePolicy,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSDecodingFailurePolicy {
                #[inline]
                fn cmp(&self, other: &NSDecodingFailurePolicy) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSDecodingFailurePolicy {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSDecodingFailurePolicy {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSDecodingFailurePolicy {
                #[doc(alias = "NSDecodingFailurePolicyRaiseException")]
                #[allow(non_upper_case_globals)]
                pub const RaiseException: Self = Self(0);
                #[doc(alias = "NSDecodingFailurePolicySetErrorAndReturn")]
                #[allow(non_upper_case_globals)]
                pub const SetErrorAndReturn: Self = Self(1);
            }
        }
        #[path = "NSComparisonPredicate.rs"]
        mod __NSComparisonPredicate {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSComparisonPredicateOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSComparisonPredicateOptions {
                #[inline]
                fn clone(&self) -> NSComparisonPredicateOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSComparisonPredicateOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSComparisonPredicateOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSComparisonPredicateOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSComparisonPredicateOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSComparisonPredicateOptions {
                #[inline]
                fn eq(&self, other: &NSComparisonPredicateOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSComparisonPredicateOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSComparisonPredicateOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSComparisonPredicateOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSComparisonPredicateOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSComparisonPredicateOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSComparisonPredicateOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSComparisonPredicateOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSComparisonPredicateOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSComparisonPredicateOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSComparisonPredicateOptions {
                #[allow(non_upper_case_globals)]
                pub const NSCaseInsensitivePredicateOption: Self = Self(0x01);
                #[allow(non_upper_case_globals)]
                pub const NSDiacriticInsensitivePredicateOption: Self = Self(0x02);
                #[allow(non_upper_case_globals)]
                pub const NSNormalizedPredicateOption: Self = Self(0x04);
            }
            #[repr(transparent)]
            pub struct NSComparisonPredicateModifier(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSComparisonPredicateModifier {
                #[inline]
                fn clone(&self) -> NSComparisonPredicateModifier {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSComparisonPredicateModifier {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSComparisonPredicateModifier {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSComparisonPredicateModifier",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSComparisonPredicateModifier {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSComparisonPredicateModifier {
                #[inline]
                fn eq(&self, other: &NSComparisonPredicateModifier) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSComparisonPredicateModifier {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSComparisonPredicateModifier {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSComparisonPredicateModifier {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSComparisonPredicateModifier {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSComparisonPredicateModifier,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSComparisonPredicateModifier {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSComparisonPredicateModifier,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSComparisonPredicateModifier {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSComparisonPredicateModifier {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSComparisonPredicateModifier {
                #[allow(non_upper_case_globals)]
                pub const NSDirectPredicateModifier: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSAllPredicateModifier: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSAnyPredicateModifier: Self = Self(2);
            }
            #[repr(transparent)]
            pub struct NSPredicateOperatorType(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSPredicateOperatorType {
                #[inline]
                fn clone(&self) -> NSPredicateOperatorType {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSPredicateOperatorType {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSPredicateOperatorType {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSPredicateOperatorType",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSPredicateOperatorType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSPredicateOperatorType {
                #[inline]
                fn eq(&self, other: &NSPredicateOperatorType) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSPredicateOperatorType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSPredicateOperatorType {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSPredicateOperatorType {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSPredicateOperatorType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSPredicateOperatorType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSPredicateOperatorType {
                #[inline]
                fn cmp(&self, other: &NSPredicateOperatorType) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSPredicateOperatorType {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSPredicateOperatorType {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSPredicateOperatorType {
                #[allow(non_upper_case_globals)]
                pub const NSLessThanPredicateOperatorType: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSLessThanOrEqualToPredicateOperatorType: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSGreaterThanPredicateOperatorType: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSGreaterThanOrEqualToPredicateOperatorType: Self = Self(3);
                #[allow(non_upper_case_globals)]
                pub const NSEqualToPredicateOperatorType: Self = Self(4);
                #[allow(non_upper_case_globals)]
                pub const NSNotEqualToPredicateOperatorType: Self = Self(5);
                #[allow(non_upper_case_globals)]
                pub const NSMatchesPredicateOperatorType: Self = Self(6);
                #[allow(non_upper_case_globals)]
                pub const NSLikePredicateOperatorType: Self = Self(7);
                #[allow(non_upper_case_globals)]
                pub const NSBeginsWithPredicateOperatorType: Self = Self(8);
                #[allow(non_upper_case_globals)]
                pub const NSEndsWithPredicateOperatorType: Self = Self(9);
                #[allow(non_upper_case_globals)]
                pub const NSInPredicateOperatorType: Self = Self(10);
                #[allow(non_upper_case_globals)]
                pub const NSCustomSelectorPredicateOperatorType: Self = Self(11);
                #[allow(non_upper_case_globals)]
                pub const NSContainsPredicateOperatorType: Self = Self(99);
                #[allow(non_upper_case_globals)]
                pub const NSBetweenPredicateOperatorType: Self = Self(100);
            }
        }
        #[path = "NSCompoundPredicate.rs"]
        mod __NSCompoundPredicate {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSCompoundPredicateType(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSCompoundPredicateType {
                #[inline]
                fn clone(&self) -> NSCompoundPredicateType {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSCompoundPredicateType {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSCompoundPredicateType {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSCompoundPredicateType",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSCompoundPredicateType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSCompoundPredicateType {
                #[inline]
                fn eq(&self, other: &NSCompoundPredicateType) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSCompoundPredicateType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSCompoundPredicateType {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSCompoundPredicateType {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSCompoundPredicateType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSCompoundPredicateType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSCompoundPredicateType {
                #[inline]
                fn cmp(&self, other: &NSCompoundPredicateType) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSCompoundPredicateType {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSCompoundPredicateType {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSCompoundPredicateType {
                #[allow(non_upper_case_globals)]
                pub const NSNotPredicateType: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSAndPredicateType: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSOrPredicateType: Self = Self(2);
            }
        }
        #[path = "NSConnection.rs"]
        mod __NSConnection {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSConnectionReplyMode: &'static NSString;
            }
            extern "C" {
                pub static NSConnectionDidDieNotification: &'static NSString;
            }
            #[deprecated = "Use NSXPCConnection instead"]
            pub unsafe trait NSConnectionDelegate: NSObjectProtocol {}
            unsafe impl<T> NSConnectionDelegate for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSConnectionDelegate,
            {}
            unsafe impl ProtocolType for dyn NSConnectionDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSConnectionDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSConnectionDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSConnectionDelegate,
            {
                const __INNER: () = ();
            }
            extern "C" {
                pub static NSFailedAuthenticationException: &'static NSString;
            }
            extern "C" {
                pub static NSConnectionDidInitializeNotification: &'static NSString;
            }
        }
        #[path = "NSData.rs"]
        mod __NSData {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSDataReadingOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSDataReadingOptions {
                #[inline]
                fn clone(&self) -> NSDataReadingOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSDataReadingOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSDataReadingOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSDataReadingOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSDataReadingOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSDataReadingOptions {
                #[inline]
                fn eq(&self, other: &NSDataReadingOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSDataReadingOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSDataReadingOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSDataReadingOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSDataReadingOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSDataReadingOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSDataReadingOptions {
                #[inline]
                fn cmp(&self, other: &NSDataReadingOptions) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSDataReadingOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSDataReadingOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSDataReadingOptions {
                #[allow(non_upper_case_globals)]
                pub const NSDataReadingMappedIfSafe: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSDataReadingUncached: Self = Self(1 << 1);
                #[allow(non_upper_case_globals)]
                pub const NSDataReadingMappedAlways: Self = Self(1 << 3);
                #[deprecated]
                #[allow(non_upper_case_globals)]
                pub const NSDataReadingMapped: Self = Self(
                    NSDataReadingOptions::NSDataReadingMappedIfSafe.0,
                );
                #[deprecated]
                #[allow(non_upper_case_globals)]
                pub const NSMappedRead: Self = Self(
                    NSDataReadingOptions::NSDataReadingMapped.0,
                );
                #[deprecated]
                #[allow(non_upper_case_globals)]
                pub const NSUncachedRead: Self = Self(
                    NSDataReadingOptions::NSDataReadingUncached.0,
                );
            }
            #[repr(transparent)]
            pub struct NSDataWritingOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSDataWritingOptions {
                #[inline]
                fn clone(&self) -> NSDataWritingOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSDataWritingOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSDataWritingOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSDataWritingOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSDataWritingOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSDataWritingOptions {
                #[inline]
                fn eq(&self, other: &NSDataWritingOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSDataWritingOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSDataWritingOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSDataWritingOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSDataWritingOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSDataWritingOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSDataWritingOptions {
                #[inline]
                fn cmp(&self, other: &NSDataWritingOptions) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSDataWritingOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSDataWritingOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSDataWritingOptions {
                #[allow(non_upper_case_globals)]
                pub const NSDataWritingAtomic: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSDataWritingWithoutOverwriting: Self = Self(1 << 1);
                #[allow(non_upper_case_globals)]
                pub const NSDataWritingFileProtectionNone: Self = Self(0x10000000);
                #[allow(non_upper_case_globals)]
                pub const NSDataWritingFileProtectionComplete: Self = Self(0x20000000);
                #[allow(non_upper_case_globals)]
                pub const NSDataWritingFileProtectionCompleteUnlessOpen: Self = Self(
                    0x30000000,
                );
                #[allow(non_upper_case_globals)]
                pub const NSDataWritingFileProtectionCompleteUntilFirstUserAuthentication: Self = Self(
                    0x40000000,
                );
                #[allow(non_upper_case_globals)]
                pub const NSDataWritingFileProtectionCompleteWhenUserInactive: Self = Self(
                    0x50000000,
                );
                #[allow(non_upper_case_globals)]
                pub const NSDataWritingFileProtectionMask: Self = Self(0xf0000000);
                #[deprecated]
                #[allow(non_upper_case_globals)]
                pub const NSAtomicWrite: Self = Self(
                    NSDataWritingOptions::NSDataWritingAtomic.0,
                );
            }
            #[repr(transparent)]
            pub struct NSDataSearchOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSDataSearchOptions {
                #[inline]
                fn clone(&self) -> NSDataSearchOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSDataSearchOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSDataSearchOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSDataSearchOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSDataSearchOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSDataSearchOptions {
                #[inline]
                fn eq(&self, other: &NSDataSearchOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSDataSearchOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSDataSearchOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSDataSearchOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSDataSearchOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSDataSearchOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSDataSearchOptions {
                #[inline]
                fn cmp(&self, other: &NSDataSearchOptions) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSDataSearchOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSDataSearchOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSDataSearchOptions {
                #[allow(non_upper_case_globals)]
                pub const NSDataSearchBackwards: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSDataSearchAnchored: Self = Self(1 << 1);
            }
            #[repr(transparent)]
            pub struct NSDataBase64EncodingOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSDataBase64EncodingOptions {
                #[inline]
                fn clone(&self) -> NSDataBase64EncodingOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSDataBase64EncodingOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSDataBase64EncodingOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSDataBase64EncodingOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSDataBase64EncodingOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSDataBase64EncodingOptions {
                #[inline]
                fn eq(&self, other: &NSDataBase64EncodingOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSDataBase64EncodingOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSDataBase64EncodingOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSDataBase64EncodingOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSDataBase64EncodingOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSDataBase64EncodingOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSDataBase64EncodingOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSDataBase64EncodingOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSDataBase64EncodingOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSDataBase64EncodingOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSDataBase64EncodingOptions {
                #[allow(non_upper_case_globals)]
                pub const NSDataBase64Encoding64CharacterLineLength: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSDataBase64Encoding76CharacterLineLength: Self = Self(1 << 1);
                #[allow(non_upper_case_globals)]
                pub const NSDataBase64EncodingEndLineWithCarriageReturn: Self = Self(
                    1 << 4,
                );
                #[allow(non_upper_case_globals)]
                pub const NSDataBase64EncodingEndLineWithLineFeed: Self = Self(1 << 5);
            }
            #[repr(transparent)]
            pub struct NSDataBase64DecodingOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSDataBase64DecodingOptions {
                #[inline]
                fn clone(&self) -> NSDataBase64DecodingOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSDataBase64DecodingOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSDataBase64DecodingOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSDataBase64DecodingOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSDataBase64DecodingOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSDataBase64DecodingOptions {
                #[inline]
                fn eq(&self, other: &NSDataBase64DecodingOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSDataBase64DecodingOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSDataBase64DecodingOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSDataBase64DecodingOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSDataBase64DecodingOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSDataBase64DecodingOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSDataBase64DecodingOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSDataBase64DecodingOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSDataBase64DecodingOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSDataBase64DecodingOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSDataBase64DecodingOptions {
                #[allow(non_upper_case_globals)]
                pub const NSDataBase64DecodingIgnoreUnknownCharacters: Self = Self(
                    1 << 0,
                );
            }
            #[repr(transparent)]
            pub struct NSDataCompressionAlgorithm(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSDataCompressionAlgorithm {
                #[inline]
                fn clone(&self) -> NSDataCompressionAlgorithm {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSDataCompressionAlgorithm {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSDataCompressionAlgorithm {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSDataCompressionAlgorithm",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSDataCompressionAlgorithm {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSDataCompressionAlgorithm {
                #[inline]
                fn eq(&self, other: &NSDataCompressionAlgorithm) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSDataCompressionAlgorithm {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSDataCompressionAlgorithm {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSDataCompressionAlgorithm {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSDataCompressionAlgorithm {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSDataCompressionAlgorithm,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSDataCompressionAlgorithm {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSDataCompressionAlgorithm,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSDataCompressionAlgorithm {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSDataCompressionAlgorithm {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSDataCompressionAlgorithm {
                #[doc(alias = "NSDataCompressionAlgorithmLZFSE")]
                #[allow(non_upper_case_globals)]
                pub const LZFSE: Self = Self(0);
                #[doc(alias = "NSDataCompressionAlgorithmLZ4")]
                #[allow(non_upper_case_globals)]
                pub const LZ4: Self = Self(1);
                #[doc(alias = "NSDataCompressionAlgorithmLZMA")]
                #[allow(non_upper_case_globals)]
                pub const LZMA: Self = Self(2);
                #[doc(alias = "NSDataCompressionAlgorithmZlib")]
                #[allow(non_upper_case_globals)]
                pub const Zlib: Self = Self(3);
            }
        }
        #[path = "NSDate.rs"]
        mod __NSDate {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSSystemClockDidChangeNotification: &'static NSNotificationName;
            }
            pub type NSTimeInterval = c_double;
        }
        #[path = "NSDateComponentsFormatter.rs"]
        mod __NSDateComponentsFormatter {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSDateComponentsFormatterUnitsStyle(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSDateComponentsFormatterUnitsStyle {
                #[inline]
                fn clone(&self) -> NSDateComponentsFormatterUnitsStyle {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSDateComponentsFormatterUnitsStyle {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSDateComponentsFormatterUnitsStyle {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSDateComponentsFormatterUnitsStyle",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSDateComponentsFormatterUnitsStyle {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSDateComponentsFormatterUnitsStyle {
                #[inline]
                fn eq(&self, other: &NSDateComponentsFormatterUnitsStyle) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSDateComponentsFormatterUnitsStyle {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSDateComponentsFormatterUnitsStyle {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSDateComponentsFormatterUnitsStyle {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSDateComponentsFormatterUnitsStyle {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSDateComponentsFormatterUnitsStyle,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSDateComponentsFormatterUnitsStyle {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSDateComponentsFormatterUnitsStyle,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSDateComponentsFormatterUnitsStyle {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSDateComponentsFormatterUnitsStyle {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSDateComponentsFormatterUnitsStyle {
                #[doc(alias = "NSDateComponentsFormatterUnitsStylePositional")]
                #[allow(non_upper_case_globals)]
                pub const Positional: Self = Self(0);
                #[doc(alias = "NSDateComponentsFormatterUnitsStyleAbbreviated")]
                #[allow(non_upper_case_globals)]
                pub const Abbreviated: Self = Self(1);
                #[doc(alias = "NSDateComponentsFormatterUnitsStyleShort")]
                #[allow(non_upper_case_globals)]
                pub const Short: Self = Self(2);
                #[doc(alias = "NSDateComponentsFormatterUnitsStyleFull")]
                #[allow(non_upper_case_globals)]
                pub const Full: Self = Self(3);
                #[doc(alias = "NSDateComponentsFormatterUnitsStyleSpellOut")]
                #[allow(non_upper_case_globals)]
                pub const SpellOut: Self = Self(4);
                #[doc(alias = "NSDateComponentsFormatterUnitsStyleBrief")]
                #[allow(non_upper_case_globals)]
                pub const Brief: Self = Self(5);
            }
            #[repr(transparent)]
            pub struct NSDateComponentsFormatterZeroFormattingBehavior(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone
            for NSDateComponentsFormatterZeroFormattingBehavior {
                #[inline]
                fn clone(&self) -> NSDateComponentsFormatterZeroFormattingBehavior {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy
            for NSDateComponentsFormatterZeroFormattingBehavior {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSDateComponentsFormatterZeroFormattingBehavior {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSDateComponentsFormatterZeroFormattingBehavior",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSDateComponentsFormatterZeroFormattingBehavior {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq
            for NSDateComponentsFormatterZeroFormattingBehavior {
                #[inline]
                fn eq(
                    &self,
                    other: &NSDateComponentsFormatterZeroFormattingBehavior,
                ) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq
            for NSDateComponentsFormatterZeroFormattingBehavior {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSDateComponentsFormatterZeroFormattingBehavior {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSDateComponentsFormatterZeroFormattingBehavior {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd
            for NSDateComponentsFormatterZeroFormattingBehavior {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSDateComponentsFormatterZeroFormattingBehavior,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSDateComponentsFormatterZeroFormattingBehavior {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSDateComponentsFormatterZeroFormattingBehavior,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode
            for NSDateComponentsFormatterZeroFormattingBehavior {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode
            for NSDateComponentsFormatterZeroFormattingBehavior {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSDateComponentsFormatterZeroFormattingBehavior {
                #[doc(alias = "NSDateComponentsFormatterZeroFormattingBehaviorNone")]
                #[allow(non_upper_case_globals)]
                pub const None: Self = Self(0);
                #[doc(alias = "NSDateComponentsFormatterZeroFormattingBehaviorDefault")]
                #[allow(non_upper_case_globals)]
                pub const Default: Self = Self(1 << 0);
                #[doc(
                    alias = "NSDateComponentsFormatterZeroFormattingBehaviorDropLeading"
                )]
                #[allow(non_upper_case_globals)]
                pub const DropLeading: Self = Self(1 << 1);
                #[doc(
                    alias = "NSDateComponentsFormatterZeroFormattingBehaviorDropMiddle"
                )]
                #[allow(non_upper_case_globals)]
                pub const DropMiddle: Self = Self(1 << 2);
                #[doc(
                    alias = "NSDateComponentsFormatterZeroFormattingBehaviorDropTrailing"
                )]
                #[allow(non_upper_case_globals)]
                pub const DropTrailing: Self = Self(1 << 3);
                #[doc(alias = "NSDateComponentsFormatterZeroFormattingBehaviorDropAll")]
                #[allow(non_upper_case_globals)]
                pub const DropAll: Self = Self(
                    NSDateComponentsFormatterZeroFormattingBehavior::DropLeading.0
                        | NSDateComponentsFormatterZeroFormattingBehavior::DropMiddle.0
                        | NSDateComponentsFormatterZeroFormattingBehavior::DropTrailing.0,
                );
                #[doc(alias = "NSDateComponentsFormatterZeroFormattingBehaviorPad")]
                #[allow(non_upper_case_globals)]
                pub const Pad: Self = Self(1 << 16);
            }
        }
        #[path = "NSDateFormatter.rs"]
        mod __NSDateFormatter {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSDateFormatterStyle(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSDateFormatterStyle {
                #[inline]
                fn clone(&self) -> NSDateFormatterStyle {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSDateFormatterStyle {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSDateFormatterStyle {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSDateFormatterStyle",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSDateFormatterStyle {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSDateFormatterStyle {
                #[inline]
                fn eq(&self, other: &NSDateFormatterStyle) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSDateFormatterStyle {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSDateFormatterStyle {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSDateFormatterStyle {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSDateFormatterStyle {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSDateFormatterStyle,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSDateFormatterStyle {
                #[inline]
                fn cmp(&self, other: &NSDateFormatterStyle) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSDateFormatterStyle {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSDateFormatterStyle {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSDateFormatterStyle {
                #[allow(non_upper_case_globals)]
                pub const NSDateFormatterNoStyle: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSDateFormatterShortStyle: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSDateFormatterMediumStyle: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSDateFormatterLongStyle: Self = Self(3);
                #[allow(non_upper_case_globals)]
                pub const NSDateFormatterFullStyle: Self = Self(4);
            }
            #[repr(transparent)]
            pub struct NSDateFormatterBehavior(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSDateFormatterBehavior {
                #[inline]
                fn clone(&self) -> NSDateFormatterBehavior {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSDateFormatterBehavior {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSDateFormatterBehavior {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSDateFormatterBehavior",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSDateFormatterBehavior {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSDateFormatterBehavior {
                #[inline]
                fn eq(&self, other: &NSDateFormatterBehavior) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSDateFormatterBehavior {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSDateFormatterBehavior {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSDateFormatterBehavior {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSDateFormatterBehavior {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSDateFormatterBehavior,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSDateFormatterBehavior {
                #[inline]
                fn cmp(&self, other: &NSDateFormatterBehavior) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSDateFormatterBehavior {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSDateFormatterBehavior {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSDateFormatterBehavior {
                #[doc(alias = "NSDateFormatterBehaviorDefault")]
                #[allow(non_upper_case_globals)]
                pub const Default: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSDateFormatterBehavior10_0: Self = Self(1000);
                #[allow(non_upper_case_globals)]
                pub const NSDateFormatterBehavior10_4: Self = Self(1040);
            }
        }
        #[path = "NSDateInterval.rs"]
        mod __NSDateInterval {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSDateIntervalFormatter.rs"]
        mod __NSDateIntervalFormatter {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSDateIntervalFormatterStyle(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSDateIntervalFormatterStyle {
                #[inline]
                fn clone(&self) -> NSDateIntervalFormatterStyle {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSDateIntervalFormatterStyle {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSDateIntervalFormatterStyle {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSDateIntervalFormatterStyle",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSDateIntervalFormatterStyle {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSDateIntervalFormatterStyle {
                #[inline]
                fn eq(&self, other: &NSDateIntervalFormatterStyle) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSDateIntervalFormatterStyle {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSDateIntervalFormatterStyle {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSDateIntervalFormatterStyle {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSDateIntervalFormatterStyle {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSDateIntervalFormatterStyle,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSDateIntervalFormatterStyle {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSDateIntervalFormatterStyle,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSDateIntervalFormatterStyle {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSDateIntervalFormatterStyle {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSDateIntervalFormatterStyle {
                #[allow(non_upper_case_globals)]
                pub const NSDateIntervalFormatterNoStyle: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSDateIntervalFormatterShortStyle: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSDateIntervalFormatterMediumStyle: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSDateIntervalFormatterLongStyle: Self = Self(3);
                #[allow(non_upper_case_globals)]
                pub const NSDateIntervalFormatterFullStyle: Self = Self(4);
            }
        }
        #[path = "NSDecimal.rs"]
        mod __NSDecimal {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSRoundingMode(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSRoundingMode {
                #[inline]
                fn clone(&self) -> NSRoundingMode {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSRoundingMode {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSRoundingMode {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSRoundingMode",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSRoundingMode {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSRoundingMode {
                #[inline]
                fn eq(&self, other: &NSRoundingMode) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSRoundingMode {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSRoundingMode {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSRoundingMode {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSRoundingMode {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSRoundingMode,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSRoundingMode {
                #[inline]
                fn cmp(&self, other: &NSRoundingMode) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSRoundingMode {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSRoundingMode {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSRoundingMode {
                #[allow(non_upper_case_globals)]
                pub const NSRoundPlain: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSRoundDown: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSRoundUp: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSRoundBankers: Self = Self(3);
            }
            #[repr(transparent)]
            pub struct NSCalculationError(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSCalculationError {
                #[inline]
                fn clone(&self) -> NSCalculationError {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSCalculationError {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSCalculationError {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSCalculationError",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSCalculationError {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSCalculationError {
                #[inline]
                fn eq(&self, other: &NSCalculationError) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSCalculationError {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSCalculationError {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSCalculationError {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSCalculationError {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSCalculationError,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSCalculationError {
                #[inline]
                fn cmp(&self, other: &NSCalculationError) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSCalculationError {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSCalculationError {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSCalculationError {
                #[allow(non_upper_case_globals)]
                pub const NSCalculationNoError: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSCalculationLossOfPrecision: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSCalculationUnderflow: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSCalculationOverflow: Self = Self(3);
                #[allow(non_upper_case_globals)]
                pub const NSCalculationDivideByZero: Self = Self(4);
            }
            extern "C" {
                pub fn NSDecimalCopy(
                    destination: NonNull<NSDecimal>,
                    source: NonNull<NSDecimal>,
                );
            }
            extern "C" {
                pub fn NSDecimalCompact(number: NonNull<NSDecimal>);
            }
            extern "C" {
                pub fn NSDecimalCompare(
                    left_operand: NonNull<NSDecimal>,
                    right_operand: NonNull<NSDecimal>,
                ) -> NSComparisonResult;
            }
            extern "C" {
                pub fn NSDecimalRound(
                    result: NonNull<NSDecimal>,
                    number: NonNull<NSDecimal>,
                    scale: NSInteger,
                    rounding_mode: NSRoundingMode,
                );
            }
            extern "C" {
                pub fn NSDecimalNormalize(
                    number1: NonNull<NSDecimal>,
                    number2: NonNull<NSDecimal>,
                    rounding_mode: NSRoundingMode,
                ) -> NSCalculationError;
            }
            extern "C" {
                pub fn NSDecimalAdd(
                    result: NonNull<NSDecimal>,
                    left_operand: NonNull<NSDecimal>,
                    right_operand: NonNull<NSDecimal>,
                    rounding_mode: NSRoundingMode,
                ) -> NSCalculationError;
            }
            extern "C" {
                pub fn NSDecimalSubtract(
                    result: NonNull<NSDecimal>,
                    left_operand: NonNull<NSDecimal>,
                    right_operand: NonNull<NSDecimal>,
                    rounding_mode: NSRoundingMode,
                ) -> NSCalculationError;
            }
            extern "C" {
                pub fn NSDecimalMultiply(
                    result: NonNull<NSDecimal>,
                    left_operand: NonNull<NSDecimal>,
                    right_operand: NonNull<NSDecimal>,
                    rounding_mode: NSRoundingMode,
                ) -> NSCalculationError;
            }
            extern "C" {
                pub fn NSDecimalDivide(
                    result: NonNull<NSDecimal>,
                    left_operand: NonNull<NSDecimal>,
                    right_operand: NonNull<NSDecimal>,
                    rounding_mode: NSRoundingMode,
                ) -> NSCalculationError;
            }
            extern "C" {
                pub fn NSDecimalPower(
                    result: NonNull<NSDecimal>,
                    number: NonNull<NSDecimal>,
                    power: NSUInteger,
                    rounding_mode: NSRoundingMode,
                ) -> NSCalculationError;
            }
            extern "C" {
                pub fn NSDecimalMultiplyByPowerOf10(
                    result: NonNull<NSDecimal>,
                    number: NonNull<NSDecimal>,
                    power: c_short,
                    rounding_mode: NSRoundingMode,
                ) -> NSCalculationError;
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSDecimalString(
                    dcm: NonNull<NSDecimal>,
                    locale: Option<&AnyObject>,
                ) -> NonNull<NSString>;
            }
        }
        #[path = "NSDecimalNumber.rs"]
        mod __NSDecimalNumber {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSDecimalNumberExactnessException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSDecimalNumberOverflowException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSDecimalNumberUnderflowException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSDecimalNumberDivideByZeroException: &'static NSExceptionName;
            }
            pub unsafe trait NSDecimalNumberBehaviors {
                unsafe fn roundingMode(&self) -> NSRoundingMode
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("roundingMode\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                unsafe fn scale(&self) -> c_short
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("scale\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
            }
            unsafe impl<T> NSDecimalNumberBehaviors
            for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSDecimalNumberBehaviors,
            {}
            unsafe impl ProtocolType for dyn NSDecimalNumberBehaviors {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSDecimalNumberBehaviors";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSDecimalNumberBehaviors
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSDecimalNumberBehaviors,
            {
                const __INNER: () = ();
            }
        }
        #[path = "NSDictionary.rs"]
        mod __NSDictionary {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[cfg(feature = "Foundation_NSDictionary")]
            unsafe impl<
                KeyType: ?Sized + NSCoding,
                ObjectType: ?Sized + NSCoding,
            > NSCoding for NSDictionary<KeyType, ObjectType> {}
            #[cfg(feature = "Foundation_NSDictionary")]
            unsafe impl<
                KeyType: ?Sized + IsIdCloneable,
                ObjectType: ?Sized + IsIdCloneable,
            > NSCopying for NSDictionary<KeyType, ObjectType> {}
            #[cfg(feature = "Foundation_NSDictionary")]
            unsafe impl<KeyType: ?Sized, ObjectType: ?Sized> NSFastEnumeration
            for NSDictionary<KeyType, ObjectType> {}
            #[cfg(feature = "Foundation_NSDictionary")]
            unsafe impl<
                KeyType: ?Sized + IsIdCloneable,
                ObjectType: ?Sized + IsIdCloneable,
            > NSMutableCopying for NSDictionary<KeyType, ObjectType> {}
            #[cfg(feature = "Foundation_NSDictionary")]
            unsafe impl<KeyType: ?Sized, ObjectType: ?Sized> NSObjectProtocol
            for NSDictionary<KeyType, ObjectType> {}
            #[cfg(feature = "Foundation_NSDictionary")]
            unsafe impl<
                KeyType: ?Sized + NSSecureCoding,
                ObjectType: ?Sized + NSSecureCoding,
            > NSSecureCoding for NSDictionary<KeyType, ObjectType> {}
            #[cfg(feature = "Foundation_NSDictionary")]
            impl<
                KeyType: Message,
                ObjectType: Message,
            > NSDictionary<KeyType, ObjectType> {
                pub fn count(&self) -> NSUInteger {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("count\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn objectForKey(
                    &self,
                    a_key: &KeyType,
                ) -> Option<Id<ObjectType>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("objectForKey:\u{0}") }
                                    }
                                },
                                (a_key,),
                            )
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSEnumerator")]
                pub unsafe fn keyEnumerator(&self) -> Id<NSEnumerator<KeyType>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("keyEnumerator\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub fn init(this: Allocated<Self>) -> Id<Self> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Init as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                this,
                                { ::objc2::__macro_helpers::init_sel() },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn initWithObjects_forKeys_count(
                    this: Allocated<Self>,
                    objects: *mut NonNull<ObjectType>,
                    keys: *mut NonNull<ProtocolObject<dyn NSCopying>>,
                    cnt: NSUInteger,
                ) -> Id<Self> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Init as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                this,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("initWithObjects:forKeys:count:\u{0}")
                                        }
                                    }
                                },
                                (objects, keys, cnt),
                            )
                        }
                    }
                }
            }
            /// Methods declared on superclass `NSObject`
            #[cfg(feature = "Foundation_NSDictionary")]
            impl<
                KeyType: Message,
                ObjectType: Message,
            > NSDictionary<KeyType, ObjectType> {
                pub fn new() -> Id<Self> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::New as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                <Self as ::objc2::ClassType>::class(),
                                { ::objc2::__macro_helpers::new_sel() },
                                (),
                            )
                        }
                    }
                }
            }
            #[cfg(feature = "Foundation_NSDictionary")]
            impl<KeyType: Message, ObjectType: Message> DefaultId
            for NSDictionary<KeyType, ObjectType> {
                #[inline]
                fn default_id() -> Id<Self> {
                    Self::new()
                }
            }
            /// NSExtendedDictionary
            #[cfg(feature = "Foundation_NSDictionary")]
            impl<
                KeyType: Message,
                ObjectType: Message,
            > NSDictionary<KeyType, ObjectType> {
                #[cfg(feature = "Foundation_NSString")]
                pub unsafe fn description(&self) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("description\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                pub unsafe fn descriptionInStringsFileFormat(&self) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("descriptionInStringsFileFormat\u{0}")
                                        }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                pub unsafe fn descriptionWithLocale(
                    &self,
                    locale: Option<&AnyObject>,
                ) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("descriptionWithLocale:\u{0}") }
                                    }
                                },
                                (locale,),
                            )
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                pub unsafe fn descriptionWithLocale_indent(
                    &self,
                    locale: Option<&AnyObject>,
                    level: NSUInteger,
                ) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("descriptionWithLocale:indent:\u{0}")
                                        }
                                    }
                                },
                                (locale, level),
                            )
                        }
                    }
                }
                pub unsafe fn isEqualToDictionary(
                    &self,
                    other_dictionary: &NSDictionary<KeyType, ObjectType>,
                ) -> bool {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("isEqualToDictionary:\u{0}") }
                                    }
                                },
                                (other_dictionary,),
                            );
                            result
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSEnumerator")]
                pub unsafe fn objectEnumerator(&self) -> Id<NSEnumerator<ObjectType>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("objectEnumerator\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn getObjects_andKeys_count(
                    &self,
                    objects: *mut NonNull<ObjectType>,
                    keys: *mut NonNull<KeyType>,
                    count: NSUInteger,
                ) {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("getObjects:andKeys:count:\u{0}") }
                                    }
                                },
                                (objects, keys, count),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn objectForKeyedSubscript(
                    &self,
                    key: &KeyType,
                ) -> Option<Id<ObjectType>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("objectForKeyedSubscript:\u{0}") }
                                    }
                                },
                                (key,),
                            )
                        }
                    }
                }
                pub unsafe fn enumerateKeysAndObjectsUsingBlock(
                    &self,
                    block: &Block<
                        dyn Fn(NonNull<KeyType>, NonNull<ObjectType>, NonNull<Bool>) + '_,
                    >,
                ) {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("enumerateKeysAndObjectsUsingBlock:\u{0}")
                                        }
                                    }
                                },
                                (block,),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn enumerateKeysAndObjectsWithOptions_usingBlock(
                    &self,
                    opts: NSEnumerationOptions,
                    block: &Block<
                        dyn Fn(NonNull<KeyType>, NonNull<ObjectType>, NonNull<Bool>) + '_,
                    >,
                ) {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("enumerateKeysAndObjectsWithOptions:usingBlock:\u{0}")
                                        }
                                    }
                                },
                                (opts, block),
                            );
                            result
                        }
                    }
                }
            }
            /// NSDeprecated
            #[cfg(feature = "Foundation_NSDictionary")]
            impl<
                KeyType: Message,
                ObjectType: Message,
            > NSDictionary<KeyType, ObjectType> {
                #[deprecated = "Use -getObjects:andKeys:count: instead"]
                pub unsafe fn getObjects_andKeys(
                    &self,
                    objects: *mut NonNull<ObjectType>,
                    keys: *mut NonNull<KeyType>,
                ) {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("getObjects:andKeys:\u{0}") }
                                    }
                                },
                                (objects, keys),
                            );
                            result
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                #[deprecated]
                pub unsafe fn dictionaryWithContentsOfFile(
                    path: &NSString,
                ) -> Option<Id<NSDictionary<KeyType, ObjectType>>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("dictionaryWithContentsOfFile:\u{0}")
                                        }
                                    }
                                },
                                (path,),
                            )
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                #[deprecated]
                pub unsafe fn initWithContentsOfFile(
                    this: Allocated<Self>,
                    path: &NSString,
                ) -> Option<Id<NSDictionary<KeyType, ObjectType>>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Init as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                this,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("initWithContentsOfFile:\u{0}") }
                                    }
                                },
                                (path,),
                            )
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                #[deprecated]
                pub unsafe fn writeToFile_atomically(
                    &self,
                    path: &NSString,
                    use_auxiliary_file: bool,
                ) -> bool {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("writeToFile:atomically:\u{0}") }
                                    }
                                },
                                (path, use_auxiliary_file),
                            );
                            result
                        }
                    }
                }
            }
            /// NSDictionaryCreation
            #[cfg(feature = "Foundation_NSDictionary")]
            impl<
                KeyType: Message,
                ObjectType: Message,
            > NSDictionary<KeyType, ObjectType> {
                pub unsafe fn dictionary() -> Id<Self> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("dictionary\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn dictionaryWithObject_forKey(
                    object: &ObjectType,
                    key: &ProtocolObject<dyn NSCopying>,
                ) -> Id<Self> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("dictionaryWithObject:forKey:\u{0}")
                                        }
                                    }
                                },
                                (object, key),
                            )
                        }
                    }
                }
                pub unsafe fn dictionaryWithObjects_forKeys_count(
                    objects: *mut NonNull<ObjectType>,
                    keys: *mut NonNull<ProtocolObject<dyn NSCopying>>,
                    cnt: NSUInteger,
                ) -> Id<Self> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("dictionaryWithObjects:forKeys:count:\u{0}")
                                        }
                                    }
                                },
                                (objects, keys, cnt),
                            )
                        }
                    }
                }
                pub unsafe fn dictionaryWithDictionary(
                    dict: &NSDictionary<KeyType, ObjectType>,
                ) -> Id<Self> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("dictionaryWithDictionary:\u{0}") }
                                    }
                                },
                                (dict,),
                            )
                        }
                    }
                }
                pub unsafe fn initWithDictionary(
                    this: Allocated<Self>,
                    other_dictionary: &NSDictionary<KeyType, ObjectType>,
                ) -> Id<Self> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Init as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                this,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("initWithDictionary:\u{0}") }
                                    }
                                },
                                (other_dictionary,),
                            )
                        }
                    }
                }
                pub unsafe fn initWithDictionary_copyItems(
                    this: Allocated<Self>,
                    other_dictionary: &NSDictionary<KeyType, ObjectType>,
                    flag: bool,
                ) -> Id<Self> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Init as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                this,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("initWithDictionary:copyItems:\u{0}")
                                        }
                                    }
                                },
                                (other_dictionary, flag),
                            )
                        }
                    }
                }
            }
            /// NSSharedKeySetDictionary
            #[cfg(feature = "Foundation_NSDictionary")]
            impl<
                KeyType: Message,
                ObjectType: Message,
            > NSDictionary<KeyType, ObjectType> {}
        }
        #[path = "NSDistantObject.rs"]
        mod __NSDistantObject {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSDistributedLock.rs"]
        mod __NSDistributedLock {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSDistributedNotificationCenter.rs"]
        mod __NSDistributedNotificationCenter {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub type NSDistributedNotificationCenterType = NSString;
            extern "C" {
                pub static NSLocalNotificationCenterType: &'static NSDistributedNotificationCenterType;
            }
            #[repr(transparent)]
            pub struct NSNotificationSuspensionBehavior(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSNotificationSuspensionBehavior {
                #[inline]
                fn clone(&self) -> NSNotificationSuspensionBehavior {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSNotificationSuspensionBehavior {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSNotificationSuspensionBehavior {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSNotificationSuspensionBehavior",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSNotificationSuspensionBehavior {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSNotificationSuspensionBehavior {
                #[inline]
                fn eq(&self, other: &NSNotificationSuspensionBehavior) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSNotificationSuspensionBehavior {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSNotificationSuspensionBehavior {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSNotificationSuspensionBehavior {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSNotificationSuspensionBehavior {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSNotificationSuspensionBehavior,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSNotificationSuspensionBehavior {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSNotificationSuspensionBehavior,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSNotificationSuspensionBehavior {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSNotificationSuspensionBehavior {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSNotificationSuspensionBehavior {
                #[doc(alias = "NSNotificationSuspensionBehaviorDrop")]
                #[allow(non_upper_case_globals)]
                pub const Drop: Self = Self(1);
                #[doc(alias = "NSNotificationSuspensionBehaviorCoalesce")]
                #[allow(non_upper_case_globals)]
                pub const Coalesce: Self = Self(2);
                #[doc(alias = "NSNotificationSuspensionBehaviorHold")]
                #[allow(non_upper_case_globals)]
                pub const Hold: Self = Self(3);
                #[doc(alias = "NSNotificationSuspensionBehaviorDeliverImmediately")]
                #[allow(non_upper_case_globals)]
                pub const DeliverImmediately: Self = Self(4);
            }
            #[repr(transparent)]
            pub struct NSDistributedNotificationOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSDistributedNotificationOptions {
                #[inline]
                fn clone(&self) -> NSDistributedNotificationOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSDistributedNotificationOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSDistributedNotificationOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSDistributedNotificationOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSDistributedNotificationOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSDistributedNotificationOptions {
                #[inline]
                fn eq(&self, other: &NSDistributedNotificationOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSDistributedNotificationOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSDistributedNotificationOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSDistributedNotificationOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSDistributedNotificationOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSDistributedNotificationOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSDistributedNotificationOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSDistributedNotificationOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSDistributedNotificationOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSDistributedNotificationOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSDistributedNotificationOptions {
                #[allow(non_upper_case_globals)]
                pub const NSDistributedNotificationDeliverImmediately: Self = Self(
                    1 << 0,
                );
                #[allow(non_upper_case_globals)]
                pub const NSDistributedNotificationPostToAllSessions: Self = Self(
                    1 << 1,
                );
            }
            pub static NSNotificationDeliverImmediately: NSDistributedNotificationOptions = NSDistributedNotificationOptions(
                NSDistributedNotificationOptions::NSDistributedNotificationDeliverImmediately
                    .0,
            );
            pub static NSNotificationPostToAllSessions: NSDistributedNotificationOptions = NSDistributedNotificationOptions(
                NSDistributedNotificationOptions::NSDistributedNotificationPostToAllSessions
                    .0,
            );
        }
        #[path = "NSEnergyFormatter.rs"]
        mod __NSEnergyFormatter {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSEnergyFormatterUnit(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSEnergyFormatterUnit {
                #[inline]
                fn clone(&self) -> NSEnergyFormatterUnit {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSEnergyFormatterUnit {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSEnergyFormatterUnit {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSEnergyFormatterUnit",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSEnergyFormatterUnit {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSEnergyFormatterUnit {
                #[inline]
                fn eq(&self, other: &NSEnergyFormatterUnit) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSEnergyFormatterUnit {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSEnergyFormatterUnit {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSEnergyFormatterUnit {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSEnergyFormatterUnit {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSEnergyFormatterUnit,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSEnergyFormatterUnit {
                #[inline]
                fn cmp(&self, other: &NSEnergyFormatterUnit) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSEnergyFormatterUnit {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSEnergyFormatterUnit {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSEnergyFormatterUnit {
                #[doc(alias = "NSEnergyFormatterUnitJoule")]
                #[allow(non_upper_case_globals)]
                pub const Joule: Self = Self(11);
                #[doc(alias = "NSEnergyFormatterUnitKilojoule")]
                #[allow(non_upper_case_globals)]
                pub const Kilojoule: Self = Self(14);
                #[doc(alias = "NSEnergyFormatterUnitCalorie")]
                #[allow(non_upper_case_globals)]
                pub const Calorie: Self = Self((7 << 8) + 1);
                #[doc(alias = "NSEnergyFormatterUnitKilocalorie")]
                #[allow(non_upper_case_globals)]
                pub const Kilocalorie: Self = Self((7 << 8) + 2);
            }
        }
        #[path = "NSEnumerator.rs"]
        mod __NSEnumerator {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub unsafe trait NSFastEnumeration {
                unsafe fn countByEnumeratingWithState_objects_count(
                    &self,
                    state: NonNull<NSFastEnumerationState>,
                    buffer: NonNull<*mut AnyObject>,
                    len: NSUInteger,
                ) -> NSUInteger
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("countByEnumeratingWithState:objects:count:\u{0}")
                                        }
                                    }
                                },
                                (state, buffer, len),
                            );
                            result
                        }
                    }
                }
            }
            unsafe impl<T> NSFastEnumeration for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSFastEnumeration,
            {}
            unsafe impl ProtocolType for dyn NSFastEnumeration {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSFastEnumeration";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T> for dyn NSFastEnumeration
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSFastEnumeration,
            {
                const __INNER: () = ();
            }
            #[cfg(feature = "Foundation_NSEnumerator")]
            unsafe impl<ObjectType: ?Sized> NSFastEnumeration
            for NSEnumerator<ObjectType> {}
            #[cfg(feature = "Foundation_NSEnumerator")]
            unsafe impl<ObjectType: ?Sized> NSObjectProtocol
            for NSEnumerator<ObjectType> {}
            #[cfg(feature = "Foundation_NSEnumerator")]
            impl<ObjectType: Message> NSEnumerator<ObjectType> {
                pub fn nextObject(&mut self) -> Option<Id<ObjectType>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("nextObject\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
            }
            /// Methods declared on superclass `NSObject`
            #[cfg(feature = "Foundation_NSEnumerator")]
            impl<ObjectType: Message> NSEnumerator<ObjectType> {
                pub unsafe fn init(this: Allocated<Self>) -> Id<Self> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Init as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                this,
                                { ::objc2::__macro_helpers::init_sel() },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn new() -> Id<Self> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::New as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                <Self as ::objc2::ClassType>::class(),
                                { ::objc2::__macro_helpers::new_sel() },
                                (),
                            )
                        }
                    }
                }
            }
            /// NSExtendedEnumerator
            #[cfg(feature = "Foundation_NSEnumerator")]
            impl<ObjectType: Message> NSEnumerator<ObjectType> {}
        }
        #[path = "NSError.rs"]
        mod __NSError {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[cfg(feature = "Foundation_NSString")]
            pub type NSErrorDomain = NSString;
            extern "C" {
                pub static NSCocoaErrorDomain: &'static NSErrorDomain;
            }
            extern "C" {
                pub static NSPOSIXErrorDomain: &'static NSErrorDomain;
            }
            extern "C" {
                pub static NSOSStatusErrorDomain: &'static NSErrorDomain;
            }
            extern "C" {
                pub static NSMachErrorDomain: &'static NSErrorDomain;
            }
            #[cfg(feature = "Foundation_NSString")]
            pub type NSErrorUserInfoKey = NSString;
            extern "C" {
                pub static NSUnderlyingErrorKey: &'static NSErrorUserInfoKey;
            }
            extern "C" {
                pub static NSMultipleUnderlyingErrorsKey: &'static NSErrorUserInfoKey;
            }
            extern "C" {
                pub static NSLocalizedDescriptionKey: &'static NSErrorUserInfoKey;
            }
            extern "C" {
                pub static NSLocalizedFailureReasonErrorKey: &'static NSErrorUserInfoKey;
            }
            extern "C" {
                pub static NSLocalizedRecoverySuggestionErrorKey: &'static NSErrorUserInfoKey;
            }
            extern "C" {
                pub static NSLocalizedRecoveryOptionsErrorKey: &'static NSErrorUserInfoKey;
            }
            extern "C" {
                pub static NSRecoveryAttempterErrorKey: &'static NSErrorUserInfoKey;
            }
            extern "C" {
                pub static NSHelpAnchorErrorKey: &'static NSErrorUserInfoKey;
            }
            extern "C" {
                pub static NSDebugDescriptionErrorKey: &'static NSErrorUserInfoKey;
            }
            extern "C" {
                pub static NSLocalizedFailureErrorKey: &'static NSErrorUserInfoKey;
            }
            extern "C" {
                pub static NSStringEncodingErrorKey: &'static NSErrorUserInfoKey;
            }
            extern "C" {
                pub static NSURLErrorKey: &'static NSErrorUserInfoKey;
            }
            extern "C" {
                pub static NSFilePathErrorKey: &'static NSErrorUserInfoKey;
            }
            /// Category "NSErrorRecoveryAttempting" on [`NSObject`].
            #[doc(alias = "NSErrorRecoveryAttempting")]
            pub unsafe trait NSObjectNSErrorRecoveryAttempting: ClassType {
                #[doc(hidden)]
                const __UNSAFE_INNER: ();
            }
            unsafe impl NSObjectNSErrorRecoveryAttempting for NSObject {
                const __UNSAFE_INNER: () = ();
            }
        }
        #[path = "NSException.rs"]
        mod __NSException {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSGenericException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSRangeException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSInvalidArgumentException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSInternalInconsistencyException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSMallocException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSObjectInaccessibleException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSObjectNotAvailableException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSDestinationInvalidException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSPortTimeoutException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSInvalidSendPortException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSInvalidReceivePortException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSPortSendException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSPortReceiveException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSOldStyleException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSInconsistentArchiveException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSAssertionHandlerKey: &'static NSString;
            }
        }
        #[path = "NSExpression.rs"]
        mod __NSExpression {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSExpressionType(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSExpressionType {
                #[inline]
                fn clone(&self) -> NSExpressionType {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSExpressionType {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSExpressionType {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSExpressionType",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSExpressionType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSExpressionType {
                #[inline]
                fn eq(&self, other: &NSExpressionType) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSExpressionType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSExpressionType {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSExpressionType {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSExpressionType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSExpressionType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSExpressionType {
                #[inline]
                fn cmp(&self, other: &NSExpressionType) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSExpressionType {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSExpressionType {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSExpressionType {
                #[allow(non_upper_case_globals)]
                pub const NSConstantValueExpressionType: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSEvaluatedObjectExpressionType: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSVariableExpressionType: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSKeyPathExpressionType: Self = Self(3);
                #[allow(non_upper_case_globals)]
                pub const NSFunctionExpressionType: Self = Self(4);
                #[allow(non_upper_case_globals)]
                pub const NSUnionSetExpressionType: Self = Self(5);
                #[allow(non_upper_case_globals)]
                pub const NSIntersectSetExpressionType: Self = Self(6);
                #[allow(non_upper_case_globals)]
                pub const NSMinusSetExpressionType: Self = Self(7);
                #[allow(non_upper_case_globals)]
                pub const NSSubqueryExpressionType: Self = Self(13);
                #[allow(non_upper_case_globals)]
                pub const NSAggregateExpressionType: Self = Self(14);
                #[allow(non_upper_case_globals)]
                pub const NSAnyKeyExpressionType: Self = Self(15);
                #[allow(non_upper_case_globals)]
                pub const NSBlockExpressionType: Self = Self(19);
                #[allow(non_upper_case_globals)]
                pub const NSConditionalExpressionType: Self = Self(20);
            }
        }
        #[path = "NSExtensionContext.rs"]
        mod __NSExtensionContext {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSExtensionItemsAndErrorsKey: Option<&'static NSString>;
            }
            extern "C" {
                pub static NSExtensionHostWillEnterForegroundNotification: Option<
                    &'static NSString,
                >;
            }
            extern "C" {
                pub static NSExtensionHostDidEnterBackgroundNotification: Option<
                    &'static NSString,
                >;
            }
            extern "C" {
                pub static NSExtensionHostWillResignActiveNotification: Option<
                    &'static NSString,
                >;
            }
            extern "C" {
                pub static NSExtensionHostDidBecomeActiveNotification: Option<
                    &'static NSString,
                >;
            }
        }
        #[path = "NSExtensionItem.rs"]
        mod __NSExtensionItem {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSExtensionItemAttributedTitleKey: Option<&'static NSString>;
            }
            extern "C" {
                pub static NSExtensionItemAttributedContentTextKey: Option<
                    &'static NSString,
                >;
            }
            extern "C" {
                pub static NSExtensionItemAttachmentsKey: Option<&'static NSString>;
            }
        }
        #[path = "NSExtensionRequestHandling.rs"]
        mod __NSExtensionRequestHandling {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub unsafe trait NSExtensionRequestHandling: NSObjectProtocol {}
            unsafe impl<T> NSExtensionRequestHandling
            for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSExtensionRequestHandling,
            {}
            unsafe impl ProtocolType for dyn NSExtensionRequestHandling {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSExtensionRequestHandling";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSExtensionRequestHandling
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSExtensionRequestHandling,
            {
                const __INNER: () = ();
            }
        }
        #[path = "NSFileCoordinator.rs"]
        mod __NSFileCoordinator {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSFileCoordinatorReadingOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSFileCoordinatorReadingOptions {
                #[inline]
                fn clone(&self) -> NSFileCoordinatorReadingOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSFileCoordinatorReadingOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSFileCoordinatorReadingOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSFileCoordinatorReadingOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSFileCoordinatorReadingOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSFileCoordinatorReadingOptions {
                #[inline]
                fn eq(&self, other: &NSFileCoordinatorReadingOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSFileCoordinatorReadingOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSFileCoordinatorReadingOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSFileCoordinatorReadingOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSFileCoordinatorReadingOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSFileCoordinatorReadingOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSFileCoordinatorReadingOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSFileCoordinatorReadingOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSFileCoordinatorReadingOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSFileCoordinatorReadingOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSFileCoordinatorReadingOptions {
                #[allow(non_upper_case_globals)]
                pub const NSFileCoordinatorReadingWithoutChanges: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSFileCoordinatorReadingResolvesSymbolicLink: Self = Self(
                    1 << 1,
                );
                #[allow(non_upper_case_globals)]
                pub const NSFileCoordinatorReadingImmediatelyAvailableMetadataOnly: Self = Self(
                    1 << 2,
                );
                #[allow(non_upper_case_globals)]
                pub const NSFileCoordinatorReadingForUploading: Self = Self(1 << 3);
            }
            #[repr(transparent)]
            pub struct NSFileCoordinatorWritingOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSFileCoordinatorWritingOptions {
                #[inline]
                fn clone(&self) -> NSFileCoordinatorWritingOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSFileCoordinatorWritingOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSFileCoordinatorWritingOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSFileCoordinatorWritingOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSFileCoordinatorWritingOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSFileCoordinatorWritingOptions {
                #[inline]
                fn eq(&self, other: &NSFileCoordinatorWritingOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSFileCoordinatorWritingOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSFileCoordinatorWritingOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSFileCoordinatorWritingOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSFileCoordinatorWritingOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSFileCoordinatorWritingOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSFileCoordinatorWritingOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSFileCoordinatorWritingOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSFileCoordinatorWritingOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSFileCoordinatorWritingOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSFileCoordinatorWritingOptions {
                #[allow(non_upper_case_globals)]
                pub const NSFileCoordinatorWritingForDeleting: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSFileCoordinatorWritingForMoving: Self = Self(1 << 1);
                #[allow(non_upper_case_globals)]
                pub const NSFileCoordinatorWritingForMerging: Self = Self(1 << 2);
                #[allow(non_upper_case_globals)]
                pub const NSFileCoordinatorWritingForReplacing: Self = Self(1 << 3);
                #[allow(non_upper_case_globals)]
                pub const NSFileCoordinatorWritingContentIndependentMetadataOnly: Self = Self(
                    1 << 4,
                );
            }
        }
        #[path = "NSFileHandle.rs"]
        mod __NSFileHandle {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSFileHandleOperationException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSFileHandleReadCompletionNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSFileHandleReadToEndOfFileCompletionNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSFileHandleConnectionAcceptedNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSFileHandleDataAvailableNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSFileHandleNotificationDataItem: &'static NSString;
            }
            extern "C" {
                pub static NSFileHandleNotificationFileHandleItem: &'static NSString;
            }
            extern "C" {
                pub static NSFileHandleNotificationMonitorModes: &'static NSString;
            }
        }
        #[path = "NSFileManager.rs"]
        mod __NSFileManager {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub type NSFileAttributeKey = NSString;
            pub type NSFileAttributeType = NSString;
            pub type NSFileProtectionType = NSString;
            pub type NSFileProviderServiceName = NSString;
            #[repr(transparent)]
            pub struct NSVolumeEnumerationOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSVolumeEnumerationOptions {
                #[inline]
                fn clone(&self) -> NSVolumeEnumerationOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSVolumeEnumerationOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSVolumeEnumerationOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSVolumeEnumerationOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSVolumeEnumerationOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSVolumeEnumerationOptions {
                #[inline]
                fn eq(&self, other: &NSVolumeEnumerationOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSVolumeEnumerationOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSVolumeEnumerationOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSVolumeEnumerationOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSVolumeEnumerationOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSVolumeEnumerationOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSVolumeEnumerationOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSVolumeEnumerationOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSVolumeEnumerationOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSVolumeEnumerationOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSVolumeEnumerationOptions {
                #[allow(non_upper_case_globals)]
                pub const NSVolumeEnumerationSkipHiddenVolumes: Self = Self(1 << 1);
                #[allow(non_upper_case_globals)]
                pub const NSVolumeEnumerationProduceFileReferenceURLs: Self = Self(
                    1 << 2,
                );
            }
            #[repr(transparent)]
            pub struct NSDirectoryEnumerationOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSDirectoryEnumerationOptions {
                #[inline]
                fn clone(&self) -> NSDirectoryEnumerationOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSDirectoryEnumerationOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSDirectoryEnumerationOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSDirectoryEnumerationOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSDirectoryEnumerationOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSDirectoryEnumerationOptions {
                #[inline]
                fn eq(&self, other: &NSDirectoryEnumerationOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSDirectoryEnumerationOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSDirectoryEnumerationOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSDirectoryEnumerationOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSDirectoryEnumerationOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSDirectoryEnumerationOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSDirectoryEnumerationOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSDirectoryEnumerationOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSDirectoryEnumerationOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSDirectoryEnumerationOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSDirectoryEnumerationOptions {
                #[allow(non_upper_case_globals)]
                pub const NSDirectoryEnumerationSkipsSubdirectoryDescendants: Self = Self(
                    1 << 0,
                );
                #[allow(non_upper_case_globals)]
                pub const NSDirectoryEnumerationSkipsPackageDescendants: Self = Self(
                    1 << 1,
                );
                #[allow(non_upper_case_globals)]
                pub const NSDirectoryEnumerationSkipsHiddenFiles: Self = Self(1 << 2);
                #[allow(non_upper_case_globals)]
                pub const NSDirectoryEnumerationIncludesDirectoriesPostOrder: Self = Self(
                    1 << 3,
                );
                #[allow(non_upper_case_globals)]
                pub const NSDirectoryEnumerationProducesRelativePathURLs: Self = Self(
                    1 << 4,
                );
            }
            #[repr(transparent)]
            pub struct NSFileManagerItemReplacementOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSFileManagerItemReplacementOptions {
                #[inline]
                fn clone(&self) -> NSFileManagerItemReplacementOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSFileManagerItemReplacementOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSFileManagerItemReplacementOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSFileManagerItemReplacementOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSFileManagerItemReplacementOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSFileManagerItemReplacementOptions {
                #[inline]
                fn eq(&self, other: &NSFileManagerItemReplacementOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSFileManagerItemReplacementOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSFileManagerItemReplacementOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSFileManagerItemReplacementOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSFileManagerItemReplacementOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSFileManagerItemReplacementOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSFileManagerItemReplacementOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSFileManagerItemReplacementOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSFileManagerItemReplacementOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSFileManagerItemReplacementOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSFileManagerItemReplacementOptions {
                #[allow(non_upper_case_globals)]
                pub const NSFileManagerItemReplacementUsingNewMetadataOnly: Self = Self(
                    1 << 0,
                );
                #[allow(non_upper_case_globals)]
                pub const NSFileManagerItemReplacementWithoutDeletingBackupItem: Self = Self(
                    1 << 1,
                );
            }
            #[repr(transparent)]
            pub struct NSURLRelationship(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSURLRelationship {
                #[inline]
                fn clone(&self) -> NSURLRelationship {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSURLRelationship {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSURLRelationship {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSURLRelationship",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSURLRelationship {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSURLRelationship {
                #[inline]
                fn eq(&self, other: &NSURLRelationship) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSURLRelationship {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSURLRelationship {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSURLRelationship {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSURLRelationship {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSURLRelationship,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSURLRelationship {
                #[inline]
                fn cmp(&self, other: &NSURLRelationship) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSURLRelationship {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSURLRelationship {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSURLRelationship {
                #[doc(alias = "NSURLRelationshipContains")]
                #[allow(non_upper_case_globals)]
                pub const Contains: Self = Self(0);
                #[doc(alias = "NSURLRelationshipSame")]
                #[allow(non_upper_case_globals)]
                pub const Same: Self = Self(1);
                #[doc(alias = "NSURLRelationshipOther")]
                #[allow(non_upper_case_globals)]
                pub const Other: Self = Self(2);
            }
            #[repr(transparent)]
            pub struct NSFileManagerUnmountOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSFileManagerUnmountOptions {
                #[inline]
                fn clone(&self) -> NSFileManagerUnmountOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSFileManagerUnmountOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSFileManagerUnmountOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSFileManagerUnmountOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSFileManagerUnmountOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSFileManagerUnmountOptions {
                #[inline]
                fn eq(&self, other: &NSFileManagerUnmountOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSFileManagerUnmountOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSFileManagerUnmountOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSFileManagerUnmountOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSFileManagerUnmountOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSFileManagerUnmountOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSFileManagerUnmountOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSFileManagerUnmountOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSFileManagerUnmountOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSFileManagerUnmountOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSFileManagerUnmountOptions {
                #[allow(non_upper_case_globals)]
                pub const NSFileManagerUnmountAllPartitionsAndEjectDisk: Self = Self(
                    1 << 0,
                );
                #[allow(non_upper_case_globals)]
                pub const NSFileManagerUnmountWithoutUI: Self = Self(1 << 1);
            }
            extern "C" {
                pub static NSFileManagerUnmountDissentingProcessIdentifierErrorKey: &'static NSString;
            }
            extern "C" {
                pub static NSUbiquityIdentityDidChangeNotification: &'static NSNotificationName;
            }
            pub unsafe trait NSFileManagerDelegate: NSObjectProtocol {}
            unsafe impl<T> NSFileManagerDelegate for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSFileManagerDelegate,
            {}
            unsafe impl ProtocolType for dyn NSFileManagerDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSFileManagerDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSFileManagerDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSFileManagerDelegate,
            {
                const __INNER: () = ();
            }
            extern "C" {
                pub static NSFileType: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFileTypeDirectory: &'static NSFileAttributeType;
            }
            extern "C" {
                pub static NSFileTypeRegular: &'static NSFileAttributeType;
            }
            extern "C" {
                pub static NSFileTypeSymbolicLink: &'static NSFileAttributeType;
            }
            extern "C" {
                pub static NSFileTypeSocket: &'static NSFileAttributeType;
            }
            extern "C" {
                pub static NSFileTypeCharacterSpecial: &'static NSFileAttributeType;
            }
            extern "C" {
                pub static NSFileTypeBlockSpecial: &'static NSFileAttributeType;
            }
            extern "C" {
                pub static NSFileTypeUnknown: &'static NSFileAttributeType;
            }
            extern "C" {
                pub static NSFileSize: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFileModificationDate: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFileReferenceCount: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFileDeviceIdentifier: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFileOwnerAccountName: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFileGroupOwnerAccountName: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFilePosixPermissions: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFileSystemNumber: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFileSystemFileNumber: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFileExtensionHidden: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFileHFSCreatorCode: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFileHFSTypeCode: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFileImmutable: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFileAppendOnly: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFileCreationDate: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFileOwnerAccountID: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFileGroupOwnerAccountID: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFileBusy: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFileProtectionKey: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFileProtectionNone: &'static NSFileProtectionType;
            }
            extern "C" {
                pub static NSFileProtectionComplete: &'static NSFileProtectionType;
            }
            extern "C" {
                pub static NSFileProtectionCompleteUnlessOpen: &'static NSFileProtectionType;
            }
            extern "C" {
                pub static NSFileProtectionCompleteUntilFirstUserAuthentication: &'static NSFileProtectionType;
            }
            extern "C" {
                pub static NSFileProtectionCompleteWhenUserInactive: &'static NSFileProtectionType;
            }
            extern "C" {
                pub static NSFileSystemSize: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFileSystemFreeSize: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFileSystemNodes: &'static NSFileAttributeKey;
            }
            extern "C" {
                pub static NSFileSystemFreeNodes: &'static NSFileAttributeKey;
            }
            /// NSFileAttributes
            #[cfg(feature = "Foundation_NSDictionary")]
            impl<
                KeyType: Message,
                ObjectType: Message,
            > NSDictionary<KeyType, ObjectType> {
                pub unsafe fn fileSize(&self) -> c_ulonglong {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("fileSize\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                pub unsafe fn fileType(&self) -> Option<Id<NSString>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("fileType\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn filePosixPermissions(&self) -> NSUInteger {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("filePosixPermissions\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                pub unsafe fn fileOwnerAccountName(&self) -> Option<Id<NSString>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("fileOwnerAccountName\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                pub unsafe fn fileGroupOwnerAccountName(&self) -> Option<Id<NSString>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("fileGroupOwnerAccountName\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn fileSystemNumber(&self) -> NSInteger {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("fileSystemNumber\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn fileSystemFileNumber(&self) -> NSUInteger {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("fileSystemFileNumber\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn fileExtensionHidden(&self) -> bool {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("fileExtensionHidden\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn fileHFSCreatorCode(&self) -> OSType {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("fileHFSCreatorCode\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn fileHFSTypeCode(&self) -> OSType {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("fileHFSTypeCode\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn fileIsImmutable(&self) -> bool {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("fileIsImmutable\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn fileIsAppendOnly(&self) -> bool {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("fileIsAppendOnly\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
            }
        }
        #[path = "NSFilePresenter.rs"]
        mod __NSFilePresenter {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub unsafe trait NSFilePresenter: NSObjectProtocol {
                unsafe fn relinquishPresentedItemToReader(
                    &self,
                    reader: &Block<dyn Fn(*mut Block<dyn Fn()>)>,
                )
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("relinquishPresentedItemToReader:\u{0}")
                                        }
                                    }
                                },
                                (reader,),
                            );
                            result
                        }
                    }
                }
                unsafe fn relinquishPresentedItemToWriter(
                    &self,
                    writer: &Block<dyn Fn(*mut Block<dyn Fn()>)>,
                )
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("relinquishPresentedItemToWriter:\u{0}")
                                        }
                                    }
                                },
                                (writer,),
                            );
                            result
                        }
                    }
                }
                unsafe fn presentedItemDidChange(&self)
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("presentedItemDidChange\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
            }
            unsafe impl<T> NSFilePresenter for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSFilePresenter,
            {}
            unsafe impl ProtocolType for dyn NSFilePresenter {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSFilePresenter";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T> for dyn NSFilePresenter
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message + NSFilePresenter,
            {
                const __INNER: () = ();
            }
        }
        #[path = "NSFileVersion.rs"]
        mod __NSFileVersion {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSFileVersionAddingOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSFileVersionAddingOptions {
                #[inline]
                fn clone(&self) -> NSFileVersionAddingOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSFileVersionAddingOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSFileVersionAddingOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSFileVersionAddingOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSFileVersionAddingOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSFileVersionAddingOptions {
                #[inline]
                fn eq(&self, other: &NSFileVersionAddingOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSFileVersionAddingOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSFileVersionAddingOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSFileVersionAddingOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSFileVersionAddingOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSFileVersionAddingOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSFileVersionAddingOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSFileVersionAddingOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSFileVersionAddingOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSFileVersionAddingOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSFileVersionAddingOptions {
                #[allow(non_upper_case_globals)]
                pub const NSFileVersionAddingByMoving: Self = Self(1 << 0);
            }
            #[repr(transparent)]
            pub struct NSFileVersionReplacingOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSFileVersionReplacingOptions {
                #[inline]
                fn clone(&self) -> NSFileVersionReplacingOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSFileVersionReplacingOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSFileVersionReplacingOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSFileVersionReplacingOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSFileVersionReplacingOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSFileVersionReplacingOptions {
                #[inline]
                fn eq(&self, other: &NSFileVersionReplacingOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSFileVersionReplacingOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSFileVersionReplacingOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSFileVersionReplacingOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSFileVersionReplacingOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSFileVersionReplacingOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSFileVersionReplacingOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSFileVersionReplacingOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSFileVersionReplacingOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSFileVersionReplacingOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSFileVersionReplacingOptions {
                #[allow(non_upper_case_globals)]
                pub const NSFileVersionReplacingByMoving: Self = Self(1 << 0);
            }
        }
        #[path = "NSFileWrapper.rs"]
        mod __NSFileWrapper {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSFileWrapperReadingOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSFileWrapperReadingOptions {
                #[inline]
                fn clone(&self) -> NSFileWrapperReadingOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSFileWrapperReadingOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSFileWrapperReadingOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSFileWrapperReadingOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSFileWrapperReadingOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSFileWrapperReadingOptions {
                #[inline]
                fn eq(&self, other: &NSFileWrapperReadingOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSFileWrapperReadingOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSFileWrapperReadingOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSFileWrapperReadingOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSFileWrapperReadingOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSFileWrapperReadingOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSFileWrapperReadingOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSFileWrapperReadingOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSFileWrapperReadingOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSFileWrapperReadingOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSFileWrapperReadingOptions {
                #[allow(non_upper_case_globals)]
                pub const NSFileWrapperReadingImmediate: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSFileWrapperReadingWithoutMapping: Self = Self(1 << 1);
            }
            #[repr(transparent)]
            pub struct NSFileWrapperWritingOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSFileWrapperWritingOptions {
                #[inline]
                fn clone(&self) -> NSFileWrapperWritingOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSFileWrapperWritingOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSFileWrapperWritingOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSFileWrapperWritingOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSFileWrapperWritingOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSFileWrapperWritingOptions {
                #[inline]
                fn eq(&self, other: &NSFileWrapperWritingOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSFileWrapperWritingOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSFileWrapperWritingOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSFileWrapperWritingOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSFileWrapperWritingOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSFileWrapperWritingOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSFileWrapperWritingOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSFileWrapperWritingOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSFileWrapperWritingOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSFileWrapperWritingOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSFileWrapperWritingOptions {
                #[allow(non_upper_case_globals)]
                pub const NSFileWrapperWritingAtomic: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSFileWrapperWritingWithNameUpdating: Self = Self(1 << 1);
            }
        }
        #[path = "NSFormatter.rs"]
        mod __NSFormatter {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSFormattingContext(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSFormattingContext {
                #[inline]
                fn clone(&self) -> NSFormattingContext {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSFormattingContext {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSFormattingContext {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSFormattingContext",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSFormattingContext {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSFormattingContext {
                #[inline]
                fn eq(&self, other: &NSFormattingContext) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSFormattingContext {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSFormattingContext {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSFormattingContext {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSFormattingContext {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSFormattingContext,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSFormattingContext {
                #[inline]
                fn cmp(&self, other: &NSFormattingContext) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSFormattingContext {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSFormattingContext {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSFormattingContext {
                #[doc(alias = "NSFormattingContextUnknown")]
                #[allow(non_upper_case_globals)]
                pub const Unknown: Self = Self(0);
                #[doc(alias = "NSFormattingContextDynamic")]
                #[allow(non_upper_case_globals)]
                pub const Dynamic: Self = Self(1);
                #[doc(alias = "NSFormattingContextStandalone")]
                #[allow(non_upper_case_globals)]
                pub const Standalone: Self = Self(2);
                #[doc(alias = "NSFormattingContextListItem")]
                #[allow(non_upper_case_globals)]
                pub const ListItem: Self = Self(3);
                #[doc(alias = "NSFormattingContextBeginningOfSentence")]
                #[allow(non_upper_case_globals)]
                pub const BeginningOfSentence: Self = Self(4);
                #[doc(alias = "NSFormattingContextMiddleOfSentence")]
                #[allow(non_upper_case_globals)]
                pub const MiddleOfSentence: Self = Self(5);
            }
            #[repr(transparent)]
            pub struct NSFormattingUnitStyle(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSFormattingUnitStyle {
                #[inline]
                fn clone(&self) -> NSFormattingUnitStyle {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSFormattingUnitStyle {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSFormattingUnitStyle {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSFormattingUnitStyle",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSFormattingUnitStyle {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSFormattingUnitStyle {
                #[inline]
                fn eq(&self, other: &NSFormattingUnitStyle) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSFormattingUnitStyle {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSFormattingUnitStyle {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSFormattingUnitStyle {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSFormattingUnitStyle {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSFormattingUnitStyle,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSFormattingUnitStyle {
                #[inline]
                fn cmp(&self, other: &NSFormattingUnitStyle) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSFormattingUnitStyle {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSFormattingUnitStyle {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSFormattingUnitStyle {
                #[doc(alias = "NSFormattingUnitStyleShort")]
                #[allow(non_upper_case_globals)]
                pub const Short: Self = Self(1);
                #[doc(alias = "NSFormattingUnitStyleMedium")]
                #[allow(non_upper_case_globals)]
                pub const Medium: Self = Self(2);
                #[doc(alias = "NSFormattingUnitStyleLong")]
                #[allow(non_upper_case_globals)]
                pub const Long: Self = Self(3);
            }
        }
        #[path = "NSGarbageCollector.rs"]
        mod __NSGarbageCollector {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSGeometry.rs"]
        mod __NSGeometry {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub type NSPointPointer = *mut NSPoint;
            pub type NSPointArray = *mut NSPoint;
            pub type NSSizePointer = *mut NSSize;
            pub type NSSizeArray = *mut NSSize;
            pub type NSRectPointer = *mut NSRect;
            pub type NSRectArray = *mut NSRect;
            #[repr(C)]
            pub struct NSEdgeInsets {
                pub top: CGFloat,
                pub left: CGFloat,
                pub bottom: CGFloat,
                pub right: CGFloat,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for NSEdgeInsets {
                #[inline]
                fn clone(&self) -> NSEdgeInsets {
                    let _: ::core::clone::AssertParamIsClone<CGFloat>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSEdgeInsets {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSEdgeInsets {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "NSEdgeInsets",
                        "top",
                        &self.top,
                        "left",
                        &self.left,
                        "bottom",
                        &self.bottom,
                        "right",
                        &&self.right,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSEdgeInsets {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSEdgeInsets {
                #[inline]
                fn eq(&self, other: &NSEdgeInsets) -> bool {
                    self.top == other.top && self.left == other.left
                        && self.bottom == other.bottom && self.right == other.right
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSEdgeInsets {
                const ENCODING: objc2::Encoding = objc2::Encoding::Struct(
                    "NSEdgeInsets",
                    &[
                        <CGFloat as objc2::Encode>::ENCODING,
                        <CGFloat as objc2::Encode>::ENCODING,
                        <CGFloat as objc2::Encode>::ENCODING,
                        <CGFloat as objc2::Encode>::ENCODING,
                    ],
                );
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSEdgeInsets {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            unsafe impl Send for NSEdgeInsets {}
            unsafe impl Sync for NSEdgeInsets {}
            #[repr(transparent)]
            pub struct NSAlignmentOptions(pub c_ulonglong);
            #[automatically_derived]
            impl ::core::clone::Clone for NSAlignmentOptions {
                #[inline]
                fn clone(&self) -> NSAlignmentOptions {
                    let _: ::core::clone::AssertParamIsClone<c_ulonglong>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSAlignmentOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSAlignmentOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSAlignmentOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSAlignmentOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSAlignmentOptions {
                #[inline]
                fn eq(&self, other: &NSAlignmentOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSAlignmentOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSAlignmentOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<c_ulonglong>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSAlignmentOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSAlignmentOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSAlignmentOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSAlignmentOptions {
                #[inline]
                fn cmp(&self, other: &NSAlignmentOptions) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSAlignmentOptions {
                const ENCODING: objc2::Encoding = <c_ulonglong as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSAlignmentOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSAlignmentOptions {
                #[allow(non_upper_case_globals)]
                pub const NSAlignMinXInward: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSAlignMinYInward: Self = Self(1 << 1);
                #[allow(non_upper_case_globals)]
                pub const NSAlignMaxXInward: Self = Self(1 << 2);
                #[allow(non_upper_case_globals)]
                pub const NSAlignMaxYInward: Self = Self(1 << 3);
                #[allow(non_upper_case_globals)]
                pub const NSAlignWidthInward: Self = Self(1 << 4);
                #[allow(non_upper_case_globals)]
                pub const NSAlignHeightInward: Self = Self(1 << 5);
                #[allow(non_upper_case_globals)]
                pub const NSAlignMinXOutward: Self = Self(1 << 8);
                #[allow(non_upper_case_globals)]
                pub const NSAlignMinYOutward: Self = Self(1 << 9);
                #[allow(non_upper_case_globals)]
                pub const NSAlignMaxXOutward: Self = Self(1 << 10);
                #[allow(non_upper_case_globals)]
                pub const NSAlignMaxYOutward: Self = Self(1 << 11);
                #[allow(non_upper_case_globals)]
                pub const NSAlignWidthOutward: Self = Self(1 << 12);
                #[allow(non_upper_case_globals)]
                pub const NSAlignHeightOutward: Self = Self(1 << 13);
                #[allow(non_upper_case_globals)]
                pub const NSAlignMinXNearest: Self = Self(1 << 16);
                #[allow(non_upper_case_globals)]
                pub const NSAlignMinYNearest: Self = Self(1 << 17);
                #[allow(non_upper_case_globals)]
                pub const NSAlignMaxXNearest: Self = Self(1 << 18);
                #[allow(non_upper_case_globals)]
                pub const NSAlignMaxYNearest: Self = Self(1 << 19);
                #[allow(non_upper_case_globals)]
                pub const NSAlignWidthNearest: Self = Self(1 << 20);
                #[allow(non_upper_case_globals)]
                pub const NSAlignHeightNearest: Self = Self(1 << 21);
                #[allow(non_upper_case_globals)]
                pub const NSAlignRectFlipped: Self = Self(1 << 63);
                #[allow(non_upper_case_globals)]
                pub const NSAlignAllEdgesInward: Self = Self(
                    NSAlignmentOptions::NSAlignMinXInward.0
                        | NSAlignmentOptions::NSAlignMaxXInward.0
                        | NSAlignmentOptions::NSAlignMinYInward.0
                        | NSAlignmentOptions::NSAlignMaxYInward.0,
                );
                #[allow(non_upper_case_globals)]
                pub const NSAlignAllEdgesOutward: Self = Self(
                    NSAlignmentOptions::NSAlignMinXOutward.0
                        | NSAlignmentOptions::NSAlignMaxXOutward.0
                        | NSAlignmentOptions::NSAlignMinYOutward.0
                        | NSAlignmentOptions::NSAlignMaxYOutward.0,
                );
                #[allow(non_upper_case_globals)]
                pub const NSAlignAllEdgesNearest: Self = Self(
                    NSAlignmentOptions::NSAlignMinXNearest.0
                        | NSAlignmentOptions::NSAlignMaxXNearest.0
                        | NSAlignmentOptions::NSAlignMinYNearest.0
                        | NSAlignmentOptions::NSAlignMaxYNearest.0,
                );
            }
            extern "C" {
                pub static NSZeroPoint: NSPoint;
            }
            extern "C" {
                pub static NSZeroSize: NSSize;
            }
            extern "C" {
                pub static NSZeroRect: NSRect;
            }
            extern "C" {
                pub static NSEdgeInsetsZero: NSEdgeInsets;
            }
            extern "C" {
                pub fn NSEqualPoints(a_point: NSPoint, b_point: NSPoint) -> Bool;
            }
            extern "C" {
                pub fn NSEqualSizes(a_size: NSSize, b_size: NSSize) -> Bool;
            }
            extern "C" {
                pub fn NSEqualRects(a_rect: NSRect, b_rect: NSRect) -> Bool;
            }
            extern "C" {
                pub fn NSIsEmptyRect(a_rect: NSRect) -> Bool;
            }
            extern "C" {
                pub fn NSEdgeInsetsEqual(
                    a_insets: NSEdgeInsets,
                    b_insets: NSEdgeInsets,
                ) -> Bool;
            }
            extern "C" {
                pub fn NSInsetRect(a_rect: NSRect, d_x: CGFloat, d_y: CGFloat) -> NSRect;
            }
            extern "C" {
                pub fn NSIntegralRect(a_rect: NSRect) -> NSRect;
            }
            extern "C" {
                pub fn NSIntegralRectWithOptions(
                    a_rect: NSRect,
                    opts: NSAlignmentOptions,
                ) -> NSRect;
            }
            extern "C" {
                pub fn NSUnionRect(a_rect: NSRect, b_rect: NSRect) -> NSRect;
            }
            extern "C" {
                pub fn NSIntersectionRect(a_rect: NSRect, b_rect: NSRect) -> NSRect;
            }
            extern "C" {
                pub fn NSOffsetRect(
                    a_rect: NSRect,
                    d_x: CGFloat,
                    d_y: CGFloat,
                ) -> NSRect;
            }
            extern "C" {
                pub fn NSDivideRect(
                    in_rect: NSRect,
                    slice: NonNull<NSRect>,
                    rem: NonNull<NSRect>,
                    amount: CGFloat,
                    edge: NSRectEdge,
                );
            }
            extern "C" {
                pub fn NSPointInRect(a_point: NSPoint, a_rect: NSRect) -> Bool;
            }
            extern "C" {
                pub fn NSMouseInRect(
                    a_point: NSPoint,
                    a_rect: NSRect,
                    flipped: Bool,
                ) -> Bool;
            }
            extern "C" {
                pub fn NSContainsRect(a_rect: NSRect, b_rect: NSRect) -> Bool;
            }
            extern "C" {
                pub fn NSIntersectsRect(a_rect: NSRect, b_rect: NSRect) -> Bool;
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSStringFromPoint(a_point: NSPoint) -> NonNull<NSString>;
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSStringFromSize(a_size: NSSize) -> NonNull<NSString>;
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSStringFromRect(a_rect: NSRect) -> NonNull<NSString>;
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSPointFromString(a_string: &NSString) -> NSPoint;
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSSizeFromString(a_string: &NSString) -> NSSize;
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSRectFromString(a_string: &NSString) -> NSRect;
            }
        }
        #[path = "NSHFSFileTypes.rs"]
        mod __NSHFSFileTypes {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSFileTypeForHFSTypeCode(
                    hfs_file_type_code: OSType,
                ) -> *mut NSString;
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSHFSTypeCodeFromFileType(
                    file_type_string: Option<&NSString>,
                ) -> OSType;
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSHFSTypeOfFile(
                    full_file_path: Option<&NSString>,
                ) -> *mut NSString;
            }
        }
        #[path = "NSHTTPCookie.rs"]
        mod __NSHTTPCookie {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub type NSHTTPCookiePropertyKey = NSString;
            pub type NSHTTPCookieStringPolicy = NSString;
            extern "C" {
                pub static NSHTTPCookieName: &'static NSHTTPCookiePropertyKey;
            }
            extern "C" {
                pub static NSHTTPCookieValue: &'static NSHTTPCookiePropertyKey;
            }
            extern "C" {
                pub static NSHTTPCookieOriginURL: &'static NSHTTPCookiePropertyKey;
            }
            extern "C" {
                pub static NSHTTPCookieVersion: &'static NSHTTPCookiePropertyKey;
            }
            extern "C" {
                pub static NSHTTPCookieDomain: &'static NSHTTPCookiePropertyKey;
            }
            extern "C" {
                pub static NSHTTPCookiePath: &'static NSHTTPCookiePropertyKey;
            }
            extern "C" {
                pub static NSHTTPCookieSecure: &'static NSHTTPCookiePropertyKey;
            }
            extern "C" {
                pub static NSHTTPCookieExpires: &'static NSHTTPCookiePropertyKey;
            }
            extern "C" {
                pub static NSHTTPCookieComment: &'static NSHTTPCookiePropertyKey;
            }
            extern "C" {
                pub static NSHTTPCookieCommentURL: &'static NSHTTPCookiePropertyKey;
            }
            extern "C" {
                pub static NSHTTPCookieDiscard: &'static NSHTTPCookiePropertyKey;
            }
            extern "C" {
                pub static NSHTTPCookieMaximumAge: &'static NSHTTPCookiePropertyKey;
            }
            extern "C" {
                pub static NSHTTPCookiePort: &'static NSHTTPCookiePropertyKey;
            }
            extern "C" {
                pub static NSHTTPCookieSameSitePolicy: &'static NSHTTPCookiePropertyKey;
            }
            extern "C" {
                pub static NSHTTPCookieSameSiteLax: &'static NSHTTPCookieStringPolicy;
            }
            extern "C" {
                pub static NSHTTPCookieSameSiteStrict: &'static NSHTTPCookieStringPolicy;
            }
        }
        #[path = "NSHTTPCookieStorage.rs"]
        mod __NSHTTPCookieStorage {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSHTTPCookieAcceptPolicy(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSHTTPCookieAcceptPolicy {
                #[inline]
                fn clone(&self) -> NSHTTPCookieAcceptPolicy {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSHTTPCookieAcceptPolicy {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSHTTPCookieAcceptPolicy {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSHTTPCookieAcceptPolicy",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSHTTPCookieAcceptPolicy {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSHTTPCookieAcceptPolicy {
                #[inline]
                fn eq(&self, other: &NSHTTPCookieAcceptPolicy) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSHTTPCookieAcceptPolicy {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSHTTPCookieAcceptPolicy {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSHTTPCookieAcceptPolicy {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSHTTPCookieAcceptPolicy {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSHTTPCookieAcceptPolicy,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSHTTPCookieAcceptPolicy {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSHTTPCookieAcceptPolicy,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSHTTPCookieAcceptPolicy {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSHTTPCookieAcceptPolicy {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSHTTPCookieAcceptPolicy {
                #[doc(alias = "NSHTTPCookieAcceptPolicyAlways")]
                #[allow(non_upper_case_globals)]
                pub const Always: Self = Self(0);
                #[doc(alias = "NSHTTPCookieAcceptPolicyNever")]
                #[allow(non_upper_case_globals)]
                pub const Never: Self = Self(1);
                #[doc(alias = "NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain")]
                #[allow(non_upper_case_globals)]
                pub const OnlyFromMainDocumentDomain: Self = Self(2);
            }
            extern "C" {
                pub static NSHTTPCookieManagerAcceptPolicyChangedNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSHTTPCookieManagerCookiesChangedNotification: &'static NSNotificationName;
            }
        }
        #[path = "NSHashTable.rs"]
        mod __NSHashTable {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub static NSHashTableStrongMemory: NSPointerFunctionsOptions = NSPointerFunctionsOptions(
                NSPointerFunctionsOptions::NSPointerFunctionsStrongMemory.0,
            );
            pub static NSHashTableZeroingWeakMemory: NSPointerFunctionsOptions = NSPointerFunctionsOptions(
                NSPointerFunctionsOptions::NSPointerFunctionsZeroingWeakMemory.0,
            );
            pub static NSHashTableCopyIn: NSPointerFunctionsOptions = NSPointerFunctionsOptions(
                NSPointerFunctionsOptions::NSPointerFunctionsCopyIn.0,
            );
            pub static NSHashTableObjectPointerPersonality: NSPointerFunctionsOptions = NSPointerFunctionsOptions(
                NSPointerFunctionsOptions::NSPointerFunctionsObjectPointerPersonality.0,
            );
            pub static NSHashTableWeakMemory: NSPointerFunctionsOptions = NSPointerFunctionsOptions(
                NSPointerFunctionsOptions::NSPointerFunctionsWeakMemory.0,
            );
            pub type NSHashTableOptions = NSUInteger;
            #[repr(C)]
            pub struct NSHashEnumerator {
                _pi: NSUInteger,
                _si: NSUInteger,
                _bs: *mut c_void,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for NSHashEnumerator {
                #[inline]
                fn clone(&self) -> NSHashEnumerator {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    let _: ::core::clone::AssertParamIsClone<*mut c_void>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSHashEnumerator {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSHashEnumerator {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "NSHashEnumerator",
                        "_pi",
                        &self._pi,
                        "_si",
                        &self._si,
                        "_bs",
                        &&self._bs,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSHashEnumerator {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSHashEnumerator {
                #[inline]
                fn eq(&self, other: &NSHashEnumerator) -> bool {
                    self._pi == other._pi && self._si == other._si
                        && self._bs == other._bs
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSHashEnumerator {
                const ENCODING: objc2::Encoding = objc2::Encoding::Struct(
                    "?",
                    &[
                        <NSUInteger as objc2::Encode>::ENCODING,
                        <NSUInteger as objc2::Encode>::ENCODING,
                        <*mut c_void as objc2::Encode>::ENCODING,
                    ],
                );
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSHashEnumerator {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            extern "C" {
                pub fn NSNextHashEnumeratorItem(
                    enumerator: NonNull<NSHashEnumerator>,
                ) -> *mut c_void;
            }
            extern "C" {
                pub fn NSEndHashTableEnumeration(enumerator: NonNull<NSHashEnumerator>);
            }
        }
        #[path = "NSHost.rs"]
        mod __NSHost {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSISO8601DateFormatter.rs"]
        mod __NSISO8601DateFormatter {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSISO8601DateFormatOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSISO8601DateFormatOptions {
                #[inline]
                fn clone(&self) -> NSISO8601DateFormatOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSISO8601DateFormatOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSISO8601DateFormatOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSISO8601DateFormatOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSISO8601DateFormatOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSISO8601DateFormatOptions {
                #[inline]
                fn eq(&self, other: &NSISO8601DateFormatOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSISO8601DateFormatOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSISO8601DateFormatOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSISO8601DateFormatOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSISO8601DateFormatOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSISO8601DateFormatOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSISO8601DateFormatOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSISO8601DateFormatOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSISO8601DateFormatOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSISO8601DateFormatOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSISO8601DateFormatOptions {
                #[allow(non_upper_case_globals)]
                pub const NSISO8601DateFormatWithYear: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSISO8601DateFormatWithMonth: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSISO8601DateFormatWithWeekOfYear: Self = Self(4);
                #[allow(non_upper_case_globals)]
                pub const NSISO8601DateFormatWithDay: Self = Self(16);
                #[allow(non_upper_case_globals)]
                pub const NSISO8601DateFormatWithTime: Self = Self(32);
                #[allow(non_upper_case_globals)]
                pub const NSISO8601DateFormatWithTimeZone: Self = Self(64);
                #[allow(non_upper_case_globals)]
                pub const NSISO8601DateFormatWithSpaceBetweenDateAndTime: Self = Self(
                    128,
                );
                #[allow(non_upper_case_globals)]
                pub const NSISO8601DateFormatWithDashSeparatorInDate: Self = Self(256);
                #[allow(non_upper_case_globals)]
                pub const NSISO8601DateFormatWithColonSeparatorInTime: Self = Self(512);
                #[allow(non_upper_case_globals)]
                pub const NSISO8601DateFormatWithColonSeparatorInTimeZone: Self = Self(
                    1024,
                );
                #[allow(non_upper_case_globals)]
                pub const NSISO8601DateFormatWithFractionalSeconds: Self = Self(2048);
                #[allow(non_upper_case_globals)]
                pub const NSISO8601DateFormatWithFullDate: Self = Self(275);
                #[allow(non_upper_case_globals)]
                pub const NSISO8601DateFormatWithFullTime: Self = Self(1632);
                #[allow(non_upper_case_globals)]
                pub const NSISO8601DateFormatWithInternetDateTime: Self = Self(1907);
            }
        }
        #[path = "NSIndexPath.rs"]
        mod __NSIndexPath {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSIndexSet.rs"]
        mod __NSIndexSet {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSInflectionRule.rs"]
        mod __NSInflectionRule {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSInvocation.rs"]
        mod __NSInvocation {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSItemProvider.rs"]
        mod __NSItemProvider {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSItemProviderRepresentationVisibility(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSItemProviderRepresentationVisibility {
                #[inline]
                fn clone(&self) -> NSItemProviderRepresentationVisibility {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSItemProviderRepresentationVisibility {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSItemProviderRepresentationVisibility {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSItemProviderRepresentationVisibility",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSItemProviderRepresentationVisibility {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSItemProviderRepresentationVisibility {
                #[inline]
                fn eq(&self, other: &NSItemProviderRepresentationVisibility) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq
            for NSItemProviderRepresentationVisibility {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSItemProviderRepresentationVisibility {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSItemProviderRepresentationVisibility {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSItemProviderRepresentationVisibility {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSItemProviderRepresentationVisibility,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSItemProviderRepresentationVisibility {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSItemProviderRepresentationVisibility,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSItemProviderRepresentationVisibility {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSItemProviderRepresentationVisibility {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSItemProviderRepresentationVisibility {
                #[doc(alias = "NSItemProviderRepresentationVisibilityAll")]
                #[allow(non_upper_case_globals)]
                pub const All: Self = Self(0);
                #[doc(alias = "NSItemProviderRepresentationVisibilityTeam")]
                #[allow(non_upper_case_globals)]
                pub const Team: Self = Self(1);
                #[doc(alias = "NSItemProviderRepresentationVisibilityGroup")]
                #[allow(non_upper_case_globals)]
                pub const Group: Self = Self(2);
                #[doc(alias = "NSItemProviderRepresentationVisibilityOwnProcess")]
                #[allow(non_upper_case_globals)]
                pub const OwnProcess: Self = Self(3);
            }
            #[repr(transparent)]
            pub struct NSItemProviderFileOptions(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSItemProviderFileOptions {
                #[inline]
                fn clone(&self) -> NSItemProviderFileOptions {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSItemProviderFileOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSItemProviderFileOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSItemProviderFileOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSItemProviderFileOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSItemProviderFileOptions {
                #[inline]
                fn eq(&self, other: &NSItemProviderFileOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSItemProviderFileOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSItemProviderFileOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSItemProviderFileOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSItemProviderFileOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSItemProviderFileOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSItemProviderFileOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSItemProviderFileOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSItemProviderFileOptions {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSItemProviderFileOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSItemProviderFileOptions {
                #[allow(non_upper_case_globals)]
                pub const NSItemProviderFileOptionOpenInPlace: Self = Self(1);
            }
            pub unsafe trait NSItemProviderWriting: NSObjectProtocol {
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn itemProviderVisibilityForRepresentationWithTypeIdentifier_class(
                    type_identifier: &NSString,
                ) -> NSItemProviderRepresentationVisibility
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::ClassType,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get(
                                                    "itemProviderVisibilityForRepresentationWithTypeIdentifier:\u{0}",
                                                )
                                        }
                                    }
                                },
                                (type_identifier,),
                            );
                            result
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn itemProviderVisibilityForRepresentationWithTypeIdentifier(
                    &self,
                    type_identifier: &NSString,
                ) -> NSItemProviderRepresentationVisibility
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get(
                                                    "itemProviderVisibilityForRepresentationWithTypeIdentifier:\u{0}",
                                                )
                                        }
                                    }
                                },
                                (type_identifier,),
                            );
                            result
                        }
                    }
                }
            }
            unsafe impl<T> NSItemProviderWriting for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSItemProviderWriting,
            {}
            unsafe impl ProtocolType for dyn NSItemProviderWriting {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSItemProviderWriting";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSItemProviderWriting
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSItemProviderWriting,
            {
                const __INNER: () = ();
            }
            pub unsafe trait NSItemProviderReading: NSObjectProtocol {}
            unsafe impl<T> NSItemProviderReading for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSItemProviderReading,
            {}
            unsafe impl ProtocolType for dyn NSItemProviderReading {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSItemProviderReading";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSItemProviderReading
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSItemProviderReading,
            {
                const __INNER: () = ();
            }
            extern "C" {
                pub static NSItemProviderPreferredImageSizeKey: &'static NSString;
            }
            extern "C" {
                pub static NSExtensionJavaScriptPreprocessingResultsKey: Option<
                    &'static NSString,
                >;
            }
            extern "C" {
                pub static NSExtensionJavaScriptFinalizeArgumentKey: Option<
                    &'static NSString,
                >;
            }
            extern "C" {
                pub static NSItemProviderErrorDomain: &'static NSString;
            }
            #[repr(transparent)]
            pub struct NSItemProviderErrorCode(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSItemProviderErrorCode {
                #[inline]
                fn clone(&self) -> NSItemProviderErrorCode {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSItemProviderErrorCode {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSItemProviderErrorCode {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSItemProviderErrorCode",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSItemProviderErrorCode {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSItemProviderErrorCode {
                #[inline]
                fn eq(&self, other: &NSItemProviderErrorCode) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSItemProviderErrorCode {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSItemProviderErrorCode {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSItemProviderErrorCode {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSItemProviderErrorCode {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSItemProviderErrorCode,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSItemProviderErrorCode {
                #[inline]
                fn cmp(&self, other: &NSItemProviderErrorCode) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSItemProviderErrorCode {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSItemProviderErrorCode {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSItemProviderErrorCode {
                #[allow(non_upper_case_globals)]
                pub const NSItemProviderUnknownError: Self = Self(-1);
                #[allow(non_upper_case_globals)]
                pub const NSItemProviderItemUnavailableError: Self = Self(-1000);
                #[allow(non_upper_case_globals)]
                pub const NSItemProviderUnexpectedValueClassError: Self = Self(-1100);
                #[allow(non_upper_case_globals)]
                pub const NSItemProviderUnavailableCoercionError: Self = Self(-1200);
            }
        }
        #[path = "NSJSONSerialization.rs"]
        mod __NSJSONSerialization {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSJSONReadingOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSJSONReadingOptions {
                #[inline]
                fn clone(&self) -> NSJSONReadingOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSJSONReadingOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSJSONReadingOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSJSONReadingOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSJSONReadingOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSJSONReadingOptions {
                #[inline]
                fn eq(&self, other: &NSJSONReadingOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSJSONReadingOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSJSONReadingOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSJSONReadingOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSJSONReadingOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSJSONReadingOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSJSONReadingOptions {
                #[inline]
                fn cmp(&self, other: &NSJSONReadingOptions) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSJSONReadingOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSJSONReadingOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSJSONReadingOptions {
                #[allow(non_upper_case_globals)]
                pub const NSJSONReadingMutableContainers: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSJSONReadingMutableLeaves: Self = Self(1 << 1);
                #[allow(non_upper_case_globals)]
                pub const NSJSONReadingFragmentsAllowed: Self = Self(1 << 2);
                #[allow(non_upper_case_globals)]
                pub const NSJSONReadingJSON5Allowed: Self = Self(1 << 3);
                #[allow(non_upper_case_globals)]
                pub const NSJSONReadingTopLevelDictionaryAssumed: Self = Self(1 << 4);
                #[deprecated]
                #[allow(non_upper_case_globals)]
                pub const NSJSONReadingAllowFragments: Self = Self(
                    NSJSONReadingOptions::NSJSONReadingFragmentsAllowed.0,
                );
            }
            #[repr(transparent)]
            pub struct NSJSONWritingOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSJSONWritingOptions {
                #[inline]
                fn clone(&self) -> NSJSONWritingOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSJSONWritingOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSJSONWritingOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSJSONWritingOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSJSONWritingOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSJSONWritingOptions {
                #[inline]
                fn eq(&self, other: &NSJSONWritingOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSJSONWritingOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSJSONWritingOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSJSONWritingOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSJSONWritingOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSJSONWritingOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSJSONWritingOptions {
                #[inline]
                fn cmp(&self, other: &NSJSONWritingOptions) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSJSONWritingOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSJSONWritingOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSJSONWritingOptions {
                #[allow(non_upper_case_globals)]
                pub const NSJSONWritingPrettyPrinted: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSJSONWritingSortedKeys: Self = Self(1 << 1);
                #[allow(non_upper_case_globals)]
                pub const NSJSONWritingFragmentsAllowed: Self = Self(1 << 2);
                #[allow(non_upper_case_globals)]
                pub const NSJSONWritingWithoutEscapingSlashes: Self = Self(1 << 3);
            }
        }
        #[path = "NSKeyValueCoding.rs"]
        mod __NSKeyValueCoding {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSUndefinedKeyException: &'static NSExceptionName;
            }
            pub type NSKeyValueOperator = NSString;
            extern "C" {
                pub static NSAverageKeyValueOperator: &'static NSKeyValueOperator;
            }
            extern "C" {
                pub static NSCountKeyValueOperator: &'static NSKeyValueOperator;
            }
            extern "C" {
                pub static NSDistinctUnionOfArraysKeyValueOperator: &'static NSKeyValueOperator;
            }
            extern "C" {
                pub static NSDistinctUnionOfObjectsKeyValueOperator: &'static NSKeyValueOperator;
            }
            extern "C" {
                pub static NSDistinctUnionOfSetsKeyValueOperator: &'static NSKeyValueOperator;
            }
            extern "C" {
                pub static NSMaximumKeyValueOperator: &'static NSKeyValueOperator;
            }
            extern "C" {
                pub static NSMinimumKeyValueOperator: &'static NSKeyValueOperator;
            }
            extern "C" {
                pub static NSSumKeyValueOperator: &'static NSKeyValueOperator;
            }
            extern "C" {
                pub static NSUnionOfArraysKeyValueOperator: &'static NSKeyValueOperator;
            }
            extern "C" {
                pub static NSUnionOfObjectsKeyValueOperator: &'static NSKeyValueOperator;
            }
            extern "C" {
                pub static NSUnionOfSetsKeyValueOperator: &'static NSKeyValueOperator;
            }
            /// Category "NSKeyValueCoding" on [`NSObject`].
            #[doc(alias = "NSKeyValueCoding")]
            pub unsafe trait NSObjectNSKeyValueCoding: ClassType {
                unsafe fn accessInstanceVariablesDirectly() -> bool
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::ClassType,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("accessInstanceVariablesDirectly\u{0}")
                                        }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn valueForKey(&self, key: &NSString) -> Option<Id<AnyObject>>
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("valueForKey:\u{0}") }
                                    }
                                },
                                (key,),
                            )
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn setValue_forKey(
                    &self,
                    value: Option<&AnyObject>,
                    key: &NSString,
                )
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("setValue:forKey:\u{0}") }
                                    }
                                },
                                (value, key),
                            );
                            result
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn valueForKeyPath(
                    &self,
                    key_path: &NSString,
                ) -> Option<Id<AnyObject>>
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("valueForKeyPath:\u{0}") }
                                    }
                                },
                                (key_path,),
                            )
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn setValue_forKeyPath(
                    &self,
                    value: Option<&AnyObject>,
                    key_path: &NSString,
                )
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("setValue:forKeyPath:\u{0}") }
                                    }
                                },
                                (value, key_path),
                            );
                            result
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn valueForUndefinedKey(
                    &self,
                    key: &NSString,
                ) -> Option<Id<AnyObject>>
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("valueForUndefinedKey:\u{0}") }
                                    }
                                },
                                (key,),
                            )
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn setValue_forUndefinedKey(
                    &self,
                    value: Option<&AnyObject>,
                    key: &NSString,
                )
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("setValue:forUndefinedKey:\u{0}") }
                                    }
                                },
                                (value, key),
                            );
                            result
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn setNilValueForKey(&self, key: &NSString)
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("setNilValueForKey:\u{0}") }
                                    }
                                },
                                (key,),
                            );
                            result
                        }
                    }
                }
                #[cfg(
                    all(
                        feature = "Foundation_NSDictionary",
                        feature = "Foundation_NSString"
                    )
                )]
                unsafe fn setValuesForKeysWithDictionary(
                    &self,
                    keyed_values: &NSDictionary<NSString, AnyObject>,
                )
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("setValuesForKeysWithDictionary:\u{0}")
                                        }
                                    }
                                },
                                (keyed_values,),
                            );
                            result
                        }
                    }
                }
                #[doc(hidden)]
                const __UNSAFE_INNER: ();
            }
            unsafe impl NSObjectNSKeyValueCoding for NSObject {
                const __UNSAFE_INNER: () = ();
            }
            /// NSKeyValueCoding
            #[cfg(feature = "Foundation_NSDictionary")]
            impl<
                KeyType: Message,
                ObjectType: Message,
            > NSDictionary<KeyType, ObjectType> {
                #[cfg(feature = "Foundation_NSString")]
                pub unsafe fn valueForKey(
                    &self,
                    key: &NSString,
                ) -> Option<Id<ObjectType>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("valueForKey:\u{0}") }
                                    }
                                },
                                (key,),
                            )
                        }
                    }
                }
            }
        }
        #[path = "NSKeyValueObserving.rs"]
        mod __NSKeyValueObserving {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSKeyValueObservingOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSKeyValueObservingOptions {
                #[inline]
                fn clone(&self) -> NSKeyValueObservingOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSKeyValueObservingOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSKeyValueObservingOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSKeyValueObservingOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSKeyValueObservingOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSKeyValueObservingOptions {
                #[inline]
                fn eq(&self, other: &NSKeyValueObservingOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSKeyValueObservingOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSKeyValueObservingOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSKeyValueObservingOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSKeyValueObservingOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSKeyValueObservingOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSKeyValueObservingOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSKeyValueObservingOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSKeyValueObservingOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSKeyValueObservingOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSKeyValueObservingOptions {
                #[allow(non_upper_case_globals)]
                pub const NSKeyValueObservingOptionNew: Self = Self(0x01);
                #[allow(non_upper_case_globals)]
                pub const NSKeyValueObservingOptionOld: Self = Self(0x02);
                #[allow(non_upper_case_globals)]
                pub const NSKeyValueObservingOptionInitial: Self = Self(0x04);
                #[allow(non_upper_case_globals)]
                pub const NSKeyValueObservingOptionPrior: Self = Self(0x08);
            }
            #[repr(transparent)]
            pub struct NSKeyValueChange(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSKeyValueChange {
                #[inline]
                fn clone(&self) -> NSKeyValueChange {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSKeyValueChange {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSKeyValueChange {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSKeyValueChange",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSKeyValueChange {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSKeyValueChange {
                #[inline]
                fn eq(&self, other: &NSKeyValueChange) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSKeyValueChange {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSKeyValueChange {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSKeyValueChange {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSKeyValueChange {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSKeyValueChange,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSKeyValueChange {
                #[inline]
                fn cmp(&self, other: &NSKeyValueChange) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSKeyValueChange {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSKeyValueChange {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSKeyValueChange {
                #[doc(alias = "NSKeyValueChangeSetting")]
                #[allow(non_upper_case_globals)]
                pub const Setting: Self = Self(1);
                #[doc(alias = "NSKeyValueChangeInsertion")]
                #[allow(non_upper_case_globals)]
                pub const Insertion: Self = Self(2);
                #[doc(alias = "NSKeyValueChangeRemoval")]
                #[allow(non_upper_case_globals)]
                pub const Removal: Self = Self(3);
                #[doc(alias = "NSKeyValueChangeReplacement")]
                #[allow(non_upper_case_globals)]
                pub const Replacement: Self = Self(4);
            }
            #[repr(transparent)]
            pub struct NSKeyValueSetMutationKind(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSKeyValueSetMutationKind {
                #[inline]
                fn clone(&self) -> NSKeyValueSetMutationKind {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSKeyValueSetMutationKind {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSKeyValueSetMutationKind {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSKeyValueSetMutationKind",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSKeyValueSetMutationKind {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSKeyValueSetMutationKind {
                #[inline]
                fn eq(&self, other: &NSKeyValueSetMutationKind) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSKeyValueSetMutationKind {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSKeyValueSetMutationKind {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSKeyValueSetMutationKind {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSKeyValueSetMutationKind {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSKeyValueSetMutationKind,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSKeyValueSetMutationKind {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSKeyValueSetMutationKind,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSKeyValueSetMutationKind {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSKeyValueSetMutationKind {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSKeyValueSetMutationKind {
                #[allow(non_upper_case_globals)]
                pub const NSKeyValueUnionSetMutation: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSKeyValueMinusSetMutation: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSKeyValueIntersectSetMutation: Self = Self(3);
                #[allow(non_upper_case_globals)]
                pub const NSKeyValueSetSetMutation: Self = Self(4);
            }
            pub type NSKeyValueChangeKey = NSString;
            extern "C" {
                pub static NSKeyValueChangeKindKey: &'static NSKeyValueChangeKey;
            }
            extern "C" {
                pub static NSKeyValueChangeNewKey: &'static NSKeyValueChangeKey;
            }
            extern "C" {
                pub static NSKeyValueChangeOldKey: &'static NSKeyValueChangeKey;
            }
            extern "C" {
                pub static NSKeyValueChangeIndexesKey: &'static NSKeyValueChangeKey;
            }
            extern "C" {
                pub static NSKeyValueChangeNotificationIsPriorKey: &'static NSKeyValueChangeKey;
            }
            /// Category "NSKeyValueObserving" on [`NSObject`].
            #[doc(alias = "NSKeyValueObserving")]
            pub unsafe trait NSObjectNSKeyValueObserving: ClassType {
                #[cfg(
                    all(
                        feature = "Foundation_NSDictionary",
                        feature = "Foundation_NSString"
                    )
                )]
                unsafe fn observeValueForKeyPath_ofObject_change_context(
                    &self,
                    key_path: Option<&NSString>,
                    object: Option<&AnyObject>,
                    change: Option<&NSDictionary<NSKeyValueChangeKey, AnyObject>>,
                    context: *mut c_void,
                )
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("observeValueForKeyPath:ofObject:change:context:\u{0}")
                                        }
                                    }
                                },
                                (key_path, object, change, context),
                            );
                            result
                        }
                    }
                }
                #[doc(hidden)]
                const __UNSAFE_INNER: ();
            }
            unsafe impl NSObjectNSKeyValueObserving for NSObject {
                const __UNSAFE_INNER: () = ();
            }
            /// Category "NSKeyValueObserverRegistration" on [`NSObject`].
            #[doc(alias = "NSKeyValueObserverRegistration")]
            pub unsafe trait NSObjectNSKeyValueObserverRegistration: ClassType {
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn addObserver_forKeyPath_options_context(
                    &self,
                    observer: &NSObject,
                    key_path: &NSString,
                    options: NSKeyValueObservingOptions,
                    context: *mut c_void,
                )
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("addObserver:forKeyPath:options:context:\u{0}")
                                        }
                                    }
                                },
                                (observer, key_path, options, context),
                            );
                            result
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn removeObserver_forKeyPath_context(
                    &self,
                    observer: &NSObject,
                    key_path: &NSString,
                    context: *mut c_void,
                )
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("removeObserver:forKeyPath:context:\u{0}")
                                        }
                                    }
                                },
                                (observer, key_path, context),
                            );
                            result
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn removeObserver_forKeyPath(
                    &self,
                    observer: &NSObject,
                    key_path: &NSString,
                )
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("removeObserver:forKeyPath:\u{0}") }
                                    }
                                },
                                (observer, key_path),
                            );
                            result
                        }
                    }
                }
                #[doc(hidden)]
                const __UNSAFE_INNER: ();
            }
            unsafe impl NSObjectNSKeyValueObserverRegistration for NSObject {
                const __UNSAFE_INNER: () = ();
            }
            /// Category "NSKeyValueObserverNotification" on [`NSObject`].
            #[doc(alias = "NSKeyValueObserverNotification")]
            pub unsafe trait NSObjectNSKeyValueObserverNotification: ClassType {
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn willChangeValueForKey(&self, key: &NSString)
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("willChangeValueForKey:\u{0}") }
                                    }
                                },
                                (key,),
                            );
                            result
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn didChangeValueForKey(&self, key: &NSString)
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("didChangeValueForKey:\u{0}") }
                                    }
                                },
                                (key,),
                            );
                            result
                        }
                    }
                }
                #[doc(hidden)]
                const __UNSAFE_INNER: ();
            }
            unsafe impl NSObjectNSKeyValueObserverNotification for NSObject {
                const __UNSAFE_INNER: () = ();
            }
            /// Category "NSKeyValueObservingCustomization" on [`NSObject`].
            #[doc(alias = "NSKeyValueObservingCustomization")]
            pub unsafe trait NSObjectNSKeyValueObservingCustomization: ClassType {
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn automaticallyNotifiesObserversForKey(key: &NSString) -> bool
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::ClassType,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("automaticallyNotifiesObserversForKey:\u{0}")
                                        }
                                    }
                                },
                                (key,),
                            );
                            result
                        }
                    }
                }
                unsafe fn observationInfo(&self) -> *mut c_void
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("observationInfo\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                unsafe fn setObservationInfo(&self, observation_info: *mut c_void)
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("setObservationInfo:\u{0}") }
                                    }
                                },
                                (observation_info,),
                            );
                            result
                        }
                    }
                }
                #[doc(hidden)]
                const __UNSAFE_INNER: ();
            }
            unsafe impl NSObjectNSKeyValueObservingCustomization for NSObject {
                const __UNSAFE_INNER: () = ();
            }
        }
        #[path = "NSKeyedArchiver.rs"]
        mod __NSKeyedArchiver {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSInvalidArchiveOperationException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSInvalidUnarchiveOperationException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSKeyedArchiveRootObjectKey: &'static NSString;
            }
            pub unsafe trait NSKeyedArchiverDelegate: NSObjectProtocol {}
            unsafe impl<T> NSKeyedArchiverDelegate
            for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSKeyedArchiverDelegate,
            {}
            unsafe impl ProtocolType for dyn NSKeyedArchiverDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSKeyedArchiverDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSKeyedArchiverDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSKeyedArchiverDelegate,
            {
                const __INNER: () = ();
            }
            pub unsafe trait NSKeyedUnarchiverDelegate: NSObjectProtocol {}
            unsafe impl<T> NSKeyedUnarchiverDelegate
            for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSKeyedUnarchiverDelegate,
            {}
            unsafe impl ProtocolType for dyn NSKeyedUnarchiverDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSKeyedUnarchiverDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSKeyedUnarchiverDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSKeyedUnarchiverDelegate,
            {
                const __INNER: () = ();
            }
            /// Category "NSKeyedArchiverObjectSubstitution" on [`NSObject`].
            #[doc(alias = "NSKeyedArchiverObjectSubstitution")]
            pub unsafe trait NSObjectNSKeyedArchiverObjectSubstitution: ClassType {
                unsafe fn classForKeyedArchiver(&self) -> Option<&'static AnyClass>
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("classForKeyedArchiver\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                #[doc(hidden)]
                const __UNSAFE_INNER: ();
            }
            unsafe impl NSObjectNSKeyedArchiverObjectSubstitution for NSObject {
                const __UNSAFE_INNER: () = ();
            }
            /// Category "NSKeyedUnarchiverObjectSubstitution" on [`NSObject`].
            #[doc(alias = "NSKeyedUnarchiverObjectSubstitution")]
            pub unsafe trait NSObjectNSKeyedUnarchiverObjectSubstitution: ClassType {
                unsafe fn classForKeyedUnarchiver() -> &'static AnyClass
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::ClassType,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("classForKeyedUnarchiver\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                #[doc(hidden)]
                const __UNSAFE_INNER: ();
            }
            unsafe impl NSObjectNSKeyedUnarchiverObjectSubstitution for NSObject {
                const __UNSAFE_INNER: () = ();
            }
        }
        #[path = "NSLengthFormatter.rs"]
        mod __NSLengthFormatter {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSLengthFormatterUnit(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSLengthFormatterUnit {
                #[inline]
                fn clone(&self) -> NSLengthFormatterUnit {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSLengthFormatterUnit {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSLengthFormatterUnit {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSLengthFormatterUnit",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSLengthFormatterUnit {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSLengthFormatterUnit {
                #[inline]
                fn eq(&self, other: &NSLengthFormatterUnit) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSLengthFormatterUnit {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSLengthFormatterUnit {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSLengthFormatterUnit {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSLengthFormatterUnit {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSLengthFormatterUnit,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSLengthFormatterUnit {
                #[inline]
                fn cmp(&self, other: &NSLengthFormatterUnit) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSLengthFormatterUnit {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSLengthFormatterUnit {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSLengthFormatterUnit {
                #[doc(alias = "NSLengthFormatterUnitMillimeter")]
                #[allow(non_upper_case_globals)]
                pub const Millimeter: Self = Self(8);
                #[doc(alias = "NSLengthFormatterUnitCentimeter")]
                #[allow(non_upper_case_globals)]
                pub const Centimeter: Self = Self(9);
                #[doc(alias = "NSLengthFormatterUnitMeter")]
                #[allow(non_upper_case_globals)]
                pub const Meter: Self = Self(11);
                #[doc(alias = "NSLengthFormatterUnitKilometer")]
                #[allow(non_upper_case_globals)]
                pub const Kilometer: Self = Self(14);
                #[doc(alias = "NSLengthFormatterUnitInch")]
                #[allow(non_upper_case_globals)]
                pub const Inch: Self = Self((5 << 8) + 1);
                #[doc(alias = "NSLengthFormatterUnitFoot")]
                #[allow(non_upper_case_globals)]
                pub const Foot: Self = Self((5 << 8) + 2);
                #[doc(alias = "NSLengthFormatterUnitYard")]
                #[allow(non_upper_case_globals)]
                pub const Yard: Self = Self((5 << 8) + 3);
                #[doc(alias = "NSLengthFormatterUnitMile")]
                #[allow(non_upper_case_globals)]
                pub const Mile: Self = Self((5 << 8) + 4);
            }
        }
        #[path = "NSLinguisticTagger.rs"]
        mod __NSLinguisticTagger {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub type NSLinguisticTagScheme = NSString;
            extern "C" {
                pub static NSLinguisticTagSchemeTokenType: &'static NSLinguisticTagScheme;
            }
            extern "C" {
                pub static NSLinguisticTagSchemeLexicalClass: &'static NSLinguisticTagScheme;
            }
            extern "C" {
                pub static NSLinguisticTagSchemeNameType: &'static NSLinguisticTagScheme;
            }
            extern "C" {
                pub static NSLinguisticTagSchemeNameTypeOrLexicalClass: &'static NSLinguisticTagScheme;
            }
            extern "C" {
                pub static NSLinguisticTagSchemeLemma: &'static NSLinguisticTagScheme;
            }
            extern "C" {
                pub static NSLinguisticTagSchemeLanguage: &'static NSLinguisticTagScheme;
            }
            extern "C" {
                pub static NSLinguisticTagSchemeScript: &'static NSLinguisticTagScheme;
            }
            pub type NSLinguisticTag = NSString;
            extern "C" {
                pub static NSLinguisticTagWord: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagPunctuation: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagWhitespace: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagOther: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagNoun: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagVerb: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagAdjective: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagAdverb: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagPronoun: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagDeterminer: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagParticle: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagPreposition: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagNumber: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagConjunction: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagInterjection: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagClassifier: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagIdiom: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagOtherWord: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagSentenceTerminator: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagOpenQuote: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagCloseQuote: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagOpenParenthesis: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagCloseParenthesis: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagWordJoiner: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagDash: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagOtherPunctuation: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagParagraphBreak: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagOtherWhitespace: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagPersonalName: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagPlaceName: &'static NSLinguisticTag;
            }
            extern "C" {
                pub static NSLinguisticTagOrganizationName: &'static NSLinguisticTag;
            }
            #[repr(transparent)]
            pub struct NSLinguisticTaggerUnit(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSLinguisticTaggerUnit {
                #[inline]
                fn clone(&self) -> NSLinguisticTaggerUnit {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSLinguisticTaggerUnit {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSLinguisticTaggerUnit {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSLinguisticTaggerUnit",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSLinguisticTaggerUnit {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSLinguisticTaggerUnit {
                #[inline]
                fn eq(&self, other: &NSLinguisticTaggerUnit) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSLinguisticTaggerUnit {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSLinguisticTaggerUnit {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSLinguisticTaggerUnit {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSLinguisticTaggerUnit {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSLinguisticTaggerUnit,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSLinguisticTaggerUnit {
                #[inline]
                fn cmp(&self, other: &NSLinguisticTaggerUnit) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSLinguisticTaggerUnit {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSLinguisticTaggerUnit {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSLinguisticTaggerUnit {
                #[doc(alias = "NSLinguisticTaggerUnitWord")]
                #[allow(non_upper_case_globals)]
                pub const Word: Self = Self(0);
                #[doc(alias = "NSLinguisticTaggerUnitSentence")]
                #[allow(non_upper_case_globals)]
                pub const Sentence: Self = Self(1);
                #[doc(alias = "NSLinguisticTaggerUnitParagraph")]
                #[allow(non_upper_case_globals)]
                pub const Paragraph: Self = Self(2);
                #[doc(alias = "NSLinguisticTaggerUnitDocument")]
                #[allow(non_upper_case_globals)]
                pub const Document: Self = Self(3);
            }
            #[repr(transparent)]
            pub struct NSLinguisticTaggerOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSLinguisticTaggerOptions {
                #[inline]
                fn clone(&self) -> NSLinguisticTaggerOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSLinguisticTaggerOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSLinguisticTaggerOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSLinguisticTaggerOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSLinguisticTaggerOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSLinguisticTaggerOptions {
                #[inline]
                fn eq(&self, other: &NSLinguisticTaggerOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSLinguisticTaggerOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSLinguisticTaggerOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSLinguisticTaggerOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSLinguisticTaggerOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSLinguisticTaggerOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSLinguisticTaggerOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSLinguisticTaggerOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSLinguisticTaggerOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSLinguisticTaggerOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSLinguisticTaggerOptions {
                #[allow(non_upper_case_globals)]
                pub const NSLinguisticTaggerOmitWords: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSLinguisticTaggerOmitPunctuation: Self = Self(1 << 1);
                #[allow(non_upper_case_globals)]
                pub const NSLinguisticTaggerOmitWhitespace: Self = Self(1 << 2);
                #[allow(non_upper_case_globals)]
                pub const NSLinguisticTaggerOmitOther: Self = Self(1 << 3);
                #[allow(non_upper_case_globals)]
                pub const NSLinguisticTaggerJoinNames: Self = Self(1 << 4);
            }
            /// NSLinguisticAnalysis
            #[cfg(feature = "Foundation_NSString")]
            impl NSString {}
        }
        #[path = "NSListFormatter.rs"]
        mod __NSListFormatter {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSLocale.rs"]
        mod __NSLocale {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub type NSLocaleKey = NSString;
            #[repr(transparent)]
            pub struct NSLocaleLanguageDirection(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSLocaleLanguageDirection {
                #[inline]
                fn clone(&self) -> NSLocaleLanguageDirection {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSLocaleLanguageDirection {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSLocaleLanguageDirection {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSLocaleLanguageDirection",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSLocaleLanguageDirection {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSLocaleLanguageDirection {
                #[inline]
                fn eq(&self, other: &NSLocaleLanguageDirection) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSLocaleLanguageDirection {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSLocaleLanguageDirection {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSLocaleLanguageDirection {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSLocaleLanguageDirection {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSLocaleLanguageDirection,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSLocaleLanguageDirection {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSLocaleLanguageDirection,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSLocaleLanguageDirection {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSLocaleLanguageDirection {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSLocaleLanguageDirection {
                #[doc(alias = "NSLocaleLanguageDirectionUnknown")]
                #[allow(non_upper_case_globals)]
                pub const Unknown: Self = Self(0);
                #[doc(alias = "NSLocaleLanguageDirectionLeftToRight")]
                #[allow(non_upper_case_globals)]
                pub const LeftToRight: Self = Self(1);
                #[doc(alias = "NSLocaleLanguageDirectionRightToLeft")]
                #[allow(non_upper_case_globals)]
                pub const RightToLeft: Self = Self(2);
                #[doc(alias = "NSLocaleLanguageDirectionTopToBottom")]
                #[allow(non_upper_case_globals)]
                pub const TopToBottom: Self = Self(3);
                #[doc(alias = "NSLocaleLanguageDirectionBottomToTop")]
                #[allow(non_upper_case_globals)]
                pub const BottomToTop: Self = Self(4);
            }
            extern "C" {
                pub static NSCurrentLocaleDidChangeNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSLocaleIdentifier: &'static NSLocaleKey;
            }
            extern "C" {
                pub static NSLocaleLanguageCode: &'static NSLocaleKey;
            }
            extern "C" {
                pub static NSLocaleCountryCode: &'static NSLocaleKey;
            }
            extern "C" {
                pub static NSLocaleScriptCode: &'static NSLocaleKey;
            }
            extern "C" {
                pub static NSLocaleVariantCode: &'static NSLocaleKey;
            }
            extern "C" {
                pub static NSLocaleExemplarCharacterSet: &'static NSLocaleKey;
            }
            extern "C" {
                pub static NSLocaleCalendar: &'static NSLocaleKey;
            }
            extern "C" {
                pub static NSLocaleCollationIdentifier: &'static NSLocaleKey;
            }
            extern "C" {
                pub static NSLocaleUsesMetricSystem: &'static NSLocaleKey;
            }
            extern "C" {
                pub static NSLocaleMeasurementSystem: &'static NSLocaleKey;
            }
            extern "C" {
                pub static NSLocaleDecimalSeparator: &'static NSLocaleKey;
            }
            extern "C" {
                pub static NSLocaleGroupingSeparator: &'static NSLocaleKey;
            }
            extern "C" {
                pub static NSLocaleCurrencySymbol: &'static NSLocaleKey;
            }
            extern "C" {
                pub static NSLocaleCurrencyCode: &'static NSLocaleKey;
            }
            extern "C" {
                pub static NSLocaleCollatorIdentifier: &'static NSLocaleKey;
            }
            extern "C" {
                pub static NSLocaleQuotationBeginDelimiterKey: &'static NSLocaleKey;
            }
            extern "C" {
                pub static NSLocaleQuotationEndDelimiterKey: &'static NSLocaleKey;
            }
            extern "C" {
                pub static NSLocaleAlternateQuotationBeginDelimiterKey: &'static NSLocaleKey;
            }
            extern "C" {
                pub static NSLocaleAlternateQuotationEndDelimiterKey: &'static NSLocaleKey;
            }
            extern "C" {
                pub static NSGregorianCalendar: &'static NSString;
            }
            extern "C" {
                pub static NSBuddhistCalendar: &'static NSString;
            }
            extern "C" {
                pub static NSChineseCalendar: &'static NSString;
            }
            extern "C" {
                pub static NSHebrewCalendar: &'static NSString;
            }
            extern "C" {
                pub static NSIslamicCalendar: &'static NSString;
            }
            extern "C" {
                pub static NSIslamicCivilCalendar: &'static NSString;
            }
            extern "C" {
                pub static NSJapaneseCalendar: &'static NSString;
            }
            extern "C" {
                pub static NSRepublicOfChinaCalendar: &'static NSString;
            }
            extern "C" {
                pub static NSPersianCalendar: &'static NSString;
            }
            extern "C" {
                pub static NSIndianCalendar: &'static NSString;
            }
            extern "C" {
                pub static NSISO8601Calendar: &'static NSString;
            }
        }
        #[path = "NSLock.rs"]
        mod __NSLock {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub unsafe trait NSLocking {
                unsafe fn lock(&self)
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("lock\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                unsafe fn unlock(&self)
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("unlock\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
            }
            unsafe impl<T> NSLocking for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSLocking,
            {}
            unsafe impl ProtocolType for dyn NSLocking {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSLocking";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T> for dyn NSLocking
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message + NSLocking,
            {
                const __INNER: () = ();
            }
        }
        #[path = "NSMapTable.rs"]
        mod __NSMapTable {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub static NSMapTableStrongMemory: NSPointerFunctionsOptions = NSPointerFunctionsOptions(
                NSPointerFunctionsOptions::NSPointerFunctionsStrongMemory.0,
            );
            pub static NSMapTableZeroingWeakMemory: NSPointerFunctionsOptions = NSPointerFunctionsOptions(
                NSPointerFunctionsOptions::NSPointerFunctionsZeroingWeakMemory.0,
            );
            pub static NSMapTableCopyIn: NSPointerFunctionsOptions = NSPointerFunctionsOptions(
                NSPointerFunctionsOptions::NSPointerFunctionsCopyIn.0,
            );
            pub static NSMapTableObjectPointerPersonality: NSPointerFunctionsOptions = NSPointerFunctionsOptions(
                NSPointerFunctionsOptions::NSPointerFunctionsObjectPointerPersonality.0,
            );
            pub static NSMapTableWeakMemory: NSPointerFunctionsOptions = NSPointerFunctionsOptions(
                NSPointerFunctionsOptions::NSPointerFunctionsWeakMemory.0,
            );
            pub type NSMapTableOptions = NSUInteger;
            #[repr(C)]
            pub struct NSMapEnumerator {
                _pi: NSUInteger,
                _si: NSUInteger,
                _bs: *mut c_void,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for NSMapEnumerator {
                #[inline]
                fn clone(&self) -> NSMapEnumerator {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    let _: ::core::clone::AssertParamIsClone<*mut c_void>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSMapEnumerator {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSMapEnumerator {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "NSMapEnumerator",
                        "_pi",
                        &self._pi,
                        "_si",
                        &self._si,
                        "_bs",
                        &&self._bs,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSMapEnumerator {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSMapEnumerator {
                #[inline]
                fn eq(&self, other: &NSMapEnumerator) -> bool {
                    self._pi == other._pi && self._si == other._si
                        && self._bs == other._bs
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSMapEnumerator {
                const ENCODING: objc2::Encoding = objc2::Encoding::Struct(
                    "?",
                    &[
                        <NSUInteger as objc2::Encode>::ENCODING,
                        <NSUInteger as objc2::Encode>::ENCODING,
                        <*mut c_void as objc2::Encode>::ENCODING,
                    ],
                );
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSMapEnumerator {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            extern "C" {
                pub fn NSNextMapEnumeratorPair(
                    enumerator: NonNull<NSMapEnumerator>,
                    key: *mut *mut c_void,
                    value: *mut *mut c_void,
                ) -> Bool;
            }
            extern "C" {
                pub fn NSEndMapTableEnumeration(enumerator: NonNull<NSMapEnumerator>);
            }
        }
        #[path = "NSMassFormatter.rs"]
        mod __NSMassFormatter {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSMassFormatterUnit(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSMassFormatterUnit {
                #[inline]
                fn clone(&self) -> NSMassFormatterUnit {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSMassFormatterUnit {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSMassFormatterUnit {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSMassFormatterUnit",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSMassFormatterUnit {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSMassFormatterUnit {
                #[inline]
                fn eq(&self, other: &NSMassFormatterUnit) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSMassFormatterUnit {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSMassFormatterUnit {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSMassFormatterUnit {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSMassFormatterUnit {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSMassFormatterUnit,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSMassFormatterUnit {
                #[inline]
                fn cmp(&self, other: &NSMassFormatterUnit) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSMassFormatterUnit {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSMassFormatterUnit {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSMassFormatterUnit {
                #[doc(alias = "NSMassFormatterUnitGram")]
                #[allow(non_upper_case_globals)]
                pub const Gram: Self = Self(11);
                #[doc(alias = "NSMassFormatterUnitKilogram")]
                #[allow(non_upper_case_globals)]
                pub const Kilogram: Self = Self(14);
                #[doc(alias = "NSMassFormatterUnitOunce")]
                #[allow(non_upper_case_globals)]
                pub const Ounce: Self = Self((6 << 8) + 1);
                #[doc(alias = "NSMassFormatterUnitPound")]
                #[allow(non_upper_case_globals)]
                pub const Pound: Self = Self((6 << 8) + 2);
                #[doc(alias = "NSMassFormatterUnitStone")]
                #[allow(non_upper_case_globals)]
                pub const Stone: Self = Self((6 << 8) + 3);
            }
        }
        #[path = "NSMeasurement.rs"]
        mod __NSMeasurement {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSMeasurementFormatter.rs"]
        mod __NSMeasurementFormatter {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSMeasurementFormatterUnitOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSMeasurementFormatterUnitOptions {
                #[inline]
                fn clone(&self) -> NSMeasurementFormatterUnitOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSMeasurementFormatterUnitOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSMeasurementFormatterUnitOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSMeasurementFormatterUnitOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSMeasurementFormatterUnitOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSMeasurementFormatterUnitOptions {
                #[inline]
                fn eq(&self, other: &NSMeasurementFormatterUnitOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSMeasurementFormatterUnitOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSMeasurementFormatterUnitOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSMeasurementFormatterUnitOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSMeasurementFormatterUnitOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSMeasurementFormatterUnitOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSMeasurementFormatterUnitOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSMeasurementFormatterUnitOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSMeasurementFormatterUnitOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSMeasurementFormatterUnitOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSMeasurementFormatterUnitOptions {
                #[doc(alias = "NSMeasurementFormatterUnitOptionsProvidedUnit")]
                #[allow(non_upper_case_globals)]
                pub const ProvidedUnit: Self = Self(1 << 0);
                #[doc(alias = "NSMeasurementFormatterUnitOptionsNaturalScale")]
                #[allow(non_upper_case_globals)]
                pub const NaturalScale: Self = Self(1 << 1);
                #[doc(alias = "NSMeasurementFormatterUnitOptionsTemperatureWithoutUnit")]
                #[allow(non_upper_case_globals)]
                pub const TemperatureWithoutUnit: Self = Self(1 << 2);
            }
        }
        #[path = "NSMetadata.rs"]
        mod __NSMetadata {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub unsafe trait NSMetadataQueryDelegate: NSObjectProtocol {}
            unsafe impl<T> NSMetadataQueryDelegate
            for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSMetadataQueryDelegate,
            {}
            unsafe impl ProtocolType for dyn NSMetadataQueryDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSMetadataQueryDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSMetadataQueryDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSMetadataQueryDelegate,
            {
                const __INNER: () = ();
            }
            extern "C" {
                pub static NSMetadataQueryDidStartGatheringNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSMetadataQueryGatheringProgressNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSMetadataQueryDidFinishGatheringNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSMetadataQueryDidUpdateNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSMetadataQueryUpdateAddedItemsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataQueryUpdateChangedItemsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataQueryUpdateRemovedItemsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataQueryResultContentRelevanceAttribute: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataQueryUserHomeScope: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataQueryLocalComputerScope: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataQueryNetworkScope: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataQueryIndexedLocalComputerScope: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataQueryIndexedNetworkScope: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataQueryUbiquitousDocumentsScope: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataQueryUbiquitousDataScope: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataQueryAccessibleUbiquitousExternalDocumentsScope: &'static NSString;
            }
        }
        #[path = "NSMetadataAttributes.rs"]
        mod __NSMetadataAttributes {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSMetadataItemFSNameKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemDisplayNameKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemURLKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemPathKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemFSSizeKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemFSCreationDateKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemFSContentChangeDateKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemContentTypeKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemContentTypeTreeKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemIsUbiquitousKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousItemHasUnresolvedConflictsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousItemIsDownloadedKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousItemDownloadingStatusKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousItemDownloadingStatusNotDownloaded: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousItemDownloadingStatusDownloaded: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousItemDownloadingStatusCurrent: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousItemIsDownloadingKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousItemIsUploadedKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousItemIsUploadingKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousItemPercentDownloadedKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousItemPercentUploadedKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousItemDownloadingErrorKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousItemUploadingErrorKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousItemDownloadRequestedKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousItemIsExternalDocumentKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousItemContainerDisplayNameKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousItemURLInLocalContainerKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousItemIsSharedKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousSharedItemCurrentUserRoleKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousSharedItemCurrentUserPermissionsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousSharedItemOwnerNameComponentsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousSharedItemMostRecentEditorNameComponentsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousSharedItemRoleOwner: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousSharedItemRoleParticipant: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousSharedItemPermissionsReadOnly: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataUbiquitousSharedItemPermissionsReadWrite: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemAttributeChangeDateKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemKeywordsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemTitleKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemAuthorsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemEditorsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemParticipantsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemProjectsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemDownloadedDateKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemWhereFromsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemCommentKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemCopyrightKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemLastUsedDateKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemContentCreationDateKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemContentModificationDateKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemDateAddedKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemDurationSecondsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemContactKeywordsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemVersionKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemPixelHeightKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemPixelWidthKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemPixelCountKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemColorSpaceKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemBitsPerSampleKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemFlashOnOffKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemFocalLengthKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemAcquisitionMakeKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemAcquisitionModelKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemISOSpeedKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemOrientationKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemLayerNamesKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemWhiteBalanceKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemApertureKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemProfileNameKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemResolutionWidthDPIKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemResolutionHeightDPIKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemExposureModeKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemExposureTimeSecondsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemEXIFVersionKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemCameraOwnerKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemFocalLength35mmKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemLensModelKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemEXIFGPSVersionKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemAltitudeKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemLatitudeKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemLongitudeKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemSpeedKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemTimestampKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemGPSTrackKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemImageDirectionKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemNamedLocationKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemGPSStatusKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemGPSMeasureModeKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemGPSDOPKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemGPSMapDatumKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemGPSDestLatitudeKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemGPSDestLongitudeKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemGPSDestBearingKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemGPSDestDistanceKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemGPSProcessingMethodKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemGPSAreaInformationKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemGPSDateStampKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemGPSDifferentalKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemCodecsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemMediaTypesKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemStreamableKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemTotalBitRateKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemVideoBitRateKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemAudioBitRateKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemDeliveryTypeKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemAlbumKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemHasAlphaChannelKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemRedEyeOnOffKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemMeteringModeKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemMaxApertureKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemFNumberKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemExposureProgramKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemExposureTimeStringKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemHeadlineKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemInstructionsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemCityKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemStateOrProvinceKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemCountryKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemTextContentKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemAudioSampleRateKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemAudioChannelCountKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemTempoKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemKeySignatureKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemTimeSignatureKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemAudioEncodingApplicationKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemComposerKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemLyricistKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemAudioTrackNumberKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemRecordingDateKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemMusicalGenreKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemIsGeneralMIDISequenceKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemRecordingYearKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemOrganizationsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemLanguagesKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemRightsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemPublishersKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemContributorsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemCoverageKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemSubjectKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemThemeKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemDescriptionKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemIdentifierKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemAudiencesKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemNumberOfPagesKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemPageWidthKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemPageHeightKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemSecurityMethodKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemCreatorKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemEncodingApplicationsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemDueDateKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemStarRatingKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemPhoneNumbersKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemEmailAddressesKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemInstantMessageAddressesKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemKindKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemRecipientsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemFinderCommentKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemFontsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemAppleLoopsRootKeyKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemAppleLoopsKeyFilterTypeKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemAppleLoopsLoopModeKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemAppleLoopDescriptorsKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemMusicalInstrumentCategoryKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemMusicalInstrumentNameKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemCFBundleIdentifierKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemInformationKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemDirectorKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemProducerKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemGenreKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemPerformersKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemOriginalFormatKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemOriginalSourceKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemAuthorEmailAddressesKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemRecipientEmailAddressesKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemAuthorAddressesKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemRecipientAddressesKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemIsLikelyJunkKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemExecutableArchitecturesKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemExecutablePlatformKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemApplicationCategoriesKey: &'static NSString;
            }
            extern "C" {
                pub static NSMetadataItemIsApplicationManagedKey: &'static NSString;
            }
        }
        #[path = "NSMethodSignature.rs"]
        mod __NSMethodSignature {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSMorphology.rs"]
        mod __NSMorphology {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSGrammaticalGender(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSGrammaticalGender {
                #[inline]
                fn clone(&self) -> NSGrammaticalGender {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSGrammaticalGender {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSGrammaticalGender {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSGrammaticalGender",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSGrammaticalGender {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSGrammaticalGender {
                #[inline]
                fn eq(&self, other: &NSGrammaticalGender) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSGrammaticalGender {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSGrammaticalGender {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSGrammaticalGender {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSGrammaticalGender {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSGrammaticalGender,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSGrammaticalGender {
                #[inline]
                fn cmp(&self, other: &NSGrammaticalGender) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSGrammaticalGender {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSGrammaticalGender {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSGrammaticalGender {
                #[doc(alias = "NSGrammaticalGenderNotSet")]
                #[allow(non_upper_case_globals)]
                pub const NotSet: Self = Self(0);
                #[doc(alias = "NSGrammaticalGenderFeminine")]
                #[allow(non_upper_case_globals)]
                pub const Feminine: Self = Self(1);
                #[doc(alias = "NSGrammaticalGenderMasculine")]
                #[allow(non_upper_case_globals)]
                pub const Masculine: Self = Self(2);
                #[doc(alias = "NSGrammaticalGenderNeuter")]
                #[allow(non_upper_case_globals)]
                pub const Neuter: Self = Self(3);
            }
            #[repr(transparent)]
            pub struct NSGrammaticalPartOfSpeech(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSGrammaticalPartOfSpeech {
                #[inline]
                fn clone(&self) -> NSGrammaticalPartOfSpeech {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSGrammaticalPartOfSpeech {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSGrammaticalPartOfSpeech {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSGrammaticalPartOfSpeech",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSGrammaticalPartOfSpeech {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSGrammaticalPartOfSpeech {
                #[inline]
                fn eq(&self, other: &NSGrammaticalPartOfSpeech) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSGrammaticalPartOfSpeech {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSGrammaticalPartOfSpeech {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSGrammaticalPartOfSpeech {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSGrammaticalPartOfSpeech {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSGrammaticalPartOfSpeech,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSGrammaticalPartOfSpeech {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSGrammaticalPartOfSpeech,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSGrammaticalPartOfSpeech {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSGrammaticalPartOfSpeech {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSGrammaticalPartOfSpeech {
                #[doc(alias = "NSGrammaticalPartOfSpeechNotSet")]
                #[allow(non_upper_case_globals)]
                pub const NotSet: Self = Self(0);
                #[doc(alias = "NSGrammaticalPartOfSpeechDeterminer")]
                #[allow(non_upper_case_globals)]
                pub const Determiner: Self = Self(1);
                #[doc(alias = "NSGrammaticalPartOfSpeechPronoun")]
                #[allow(non_upper_case_globals)]
                pub const Pronoun: Self = Self(2);
                #[doc(alias = "NSGrammaticalPartOfSpeechLetter")]
                #[allow(non_upper_case_globals)]
                pub const Letter: Self = Self(3);
                #[doc(alias = "NSGrammaticalPartOfSpeechAdverb")]
                #[allow(non_upper_case_globals)]
                pub const Adverb: Self = Self(4);
                #[doc(alias = "NSGrammaticalPartOfSpeechParticle")]
                #[allow(non_upper_case_globals)]
                pub const Particle: Self = Self(5);
                #[doc(alias = "NSGrammaticalPartOfSpeechAdjective")]
                #[allow(non_upper_case_globals)]
                pub const Adjective: Self = Self(6);
                #[doc(alias = "NSGrammaticalPartOfSpeechAdposition")]
                #[allow(non_upper_case_globals)]
                pub const Adposition: Self = Self(7);
                #[doc(alias = "NSGrammaticalPartOfSpeechVerb")]
                #[allow(non_upper_case_globals)]
                pub const Verb: Self = Self(8);
                #[doc(alias = "NSGrammaticalPartOfSpeechNoun")]
                #[allow(non_upper_case_globals)]
                pub const Noun: Self = Self(9);
                #[doc(alias = "NSGrammaticalPartOfSpeechConjunction")]
                #[allow(non_upper_case_globals)]
                pub const Conjunction: Self = Self(10);
                #[doc(alias = "NSGrammaticalPartOfSpeechNumeral")]
                #[allow(non_upper_case_globals)]
                pub const Numeral: Self = Self(11);
                #[doc(alias = "NSGrammaticalPartOfSpeechInterjection")]
                #[allow(non_upper_case_globals)]
                pub const Interjection: Self = Self(12);
                #[doc(alias = "NSGrammaticalPartOfSpeechPreposition")]
                #[allow(non_upper_case_globals)]
                pub const Preposition: Self = Self(13);
                #[doc(alias = "NSGrammaticalPartOfSpeechAbbreviation")]
                #[allow(non_upper_case_globals)]
                pub const Abbreviation: Self = Self(14);
            }
            #[repr(transparent)]
            pub struct NSGrammaticalNumber(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSGrammaticalNumber {
                #[inline]
                fn clone(&self) -> NSGrammaticalNumber {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSGrammaticalNumber {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSGrammaticalNumber {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSGrammaticalNumber",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSGrammaticalNumber {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSGrammaticalNumber {
                #[inline]
                fn eq(&self, other: &NSGrammaticalNumber) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSGrammaticalNumber {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSGrammaticalNumber {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSGrammaticalNumber {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSGrammaticalNumber {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSGrammaticalNumber,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSGrammaticalNumber {
                #[inline]
                fn cmp(&self, other: &NSGrammaticalNumber) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSGrammaticalNumber {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSGrammaticalNumber {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSGrammaticalNumber {
                #[doc(alias = "NSGrammaticalNumberNotSet")]
                #[allow(non_upper_case_globals)]
                pub const NotSet: Self = Self(0);
                #[doc(alias = "NSGrammaticalNumberSingular")]
                #[allow(non_upper_case_globals)]
                pub const Singular: Self = Self(1);
                #[doc(alias = "NSGrammaticalNumberZero")]
                #[allow(non_upper_case_globals)]
                pub const Zero: Self = Self(2);
                #[doc(alias = "NSGrammaticalNumberPlural")]
                #[allow(non_upper_case_globals)]
                pub const Plural: Self = Self(3);
                #[doc(alias = "NSGrammaticalNumberPluralTwo")]
                #[allow(non_upper_case_globals)]
                pub const PluralTwo: Self = Self(4);
                #[doc(alias = "NSGrammaticalNumberPluralFew")]
                #[allow(non_upper_case_globals)]
                pub const PluralFew: Self = Self(5);
                #[doc(alias = "NSGrammaticalNumberPluralMany")]
                #[allow(non_upper_case_globals)]
                pub const PluralMany: Self = Self(6);
            }
            #[repr(transparent)]
            pub struct NSGrammaticalCase(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSGrammaticalCase {
                #[inline]
                fn clone(&self) -> NSGrammaticalCase {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSGrammaticalCase {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSGrammaticalCase {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSGrammaticalCase",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSGrammaticalCase {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSGrammaticalCase {
                #[inline]
                fn eq(&self, other: &NSGrammaticalCase) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSGrammaticalCase {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSGrammaticalCase {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSGrammaticalCase {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSGrammaticalCase {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSGrammaticalCase,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSGrammaticalCase {
                #[inline]
                fn cmp(&self, other: &NSGrammaticalCase) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSGrammaticalCase {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSGrammaticalCase {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSGrammaticalCase {
                #[doc(alias = "NSGrammaticalCaseNotSet")]
                #[allow(non_upper_case_globals)]
                pub const NotSet: Self = Self(0);
                #[doc(alias = "NSGrammaticalCaseNominative")]
                #[allow(non_upper_case_globals)]
                pub const Nominative: Self = Self(1);
                #[doc(alias = "NSGrammaticalCaseAccusative")]
                #[allow(non_upper_case_globals)]
                pub const Accusative: Self = Self(2);
                #[doc(alias = "NSGrammaticalCaseDative")]
                #[allow(non_upper_case_globals)]
                pub const Dative: Self = Self(3);
                #[doc(alias = "NSGrammaticalCaseGenitive")]
                #[allow(non_upper_case_globals)]
                pub const Genitive: Self = Self(4);
                #[doc(alias = "NSGrammaticalCasePrepositional")]
                #[allow(non_upper_case_globals)]
                pub const Prepositional: Self = Self(5);
                #[doc(alias = "NSGrammaticalCaseAblative")]
                #[allow(non_upper_case_globals)]
                pub const Ablative: Self = Self(6);
                #[doc(alias = "NSGrammaticalCaseAdessive")]
                #[allow(non_upper_case_globals)]
                pub const Adessive: Self = Self(7);
                #[doc(alias = "NSGrammaticalCaseAllative")]
                #[allow(non_upper_case_globals)]
                pub const Allative: Self = Self(8);
                #[doc(alias = "NSGrammaticalCaseElative")]
                #[allow(non_upper_case_globals)]
                pub const Elative: Self = Self(9);
                #[doc(alias = "NSGrammaticalCaseIllative")]
                #[allow(non_upper_case_globals)]
                pub const Illative: Self = Self(10);
                #[doc(alias = "NSGrammaticalCaseEssive")]
                #[allow(non_upper_case_globals)]
                pub const Essive: Self = Self(11);
                #[doc(alias = "NSGrammaticalCaseInessive")]
                #[allow(non_upper_case_globals)]
                pub const Inessive: Self = Self(12);
                #[doc(alias = "NSGrammaticalCaseLocative")]
                #[allow(non_upper_case_globals)]
                pub const Locative: Self = Self(13);
                #[doc(alias = "NSGrammaticalCaseTranslative")]
                #[allow(non_upper_case_globals)]
                pub const Translative: Self = Self(14);
            }
            #[repr(transparent)]
            pub struct NSGrammaticalPronounType(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSGrammaticalPronounType {
                #[inline]
                fn clone(&self) -> NSGrammaticalPronounType {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSGrammaticalPronounType {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSGrammaticalPronounType {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSGrammaticalPronounType",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSGrammaticalPronounType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSGrammaticalPronounType {
                #[inline]
                fn eq(&self, other: &NSGrammaticalPronounType) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSGrammaticalPronounType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSGrammaticalPronounType {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSGrammaticalPronounType {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSGrammaticalPronounType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSGrammaticalPronounType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSGrammaticalPronounType {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSGrammaticalPronounType,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSGrammaticalPronounType {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSGrammaticalPronounType {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSGrammaticalPronounType {
                #[doc(alias = "NSGrammaticalPronounTypeNotSet")]
                #[allow(non_upper_case_globals)]
                pub const NotSet: Self = Self(0);
                #[doc(alias = "NSGrammaticalPronounTypePersonal")]
                #[allow(non_upper_case_globals)]
                pub const Personal: Self = Self(1);
                #[doc(alias = "NSGrammaticalPronounTypeReflexive")]
                #[allow(non_upper_case_globals)]
                pub const Reflexive: Self = Self(2);
                #[doc(alias = "NSGrammaticalPronounTypePossessive")]
                #[allow(non_upper_case_globals)]
                pub const Possessive: Self = Self(3);
            }
            #[repr(transparent)]
            pub struct NSGrammaticalPerson(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSGrammaticalPerson {
                #[inline]
                fn clone(&self) -> NSGrammaticalPerson {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSGrammaticalPerson {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSGrammaticalPerson {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSGrammaticalPerson",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSGrammaticalPerson {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSGrammaticalPerson {
                #[inline]
                fn eq(&self, other: &NSGrammaticalPerson) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSGrammaticalPerson {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSGrammaticalPerson {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSGrammaticalPerson {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSGrammaticalPerson {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSGrammaticalPerson,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSGrammaticalPerson {
                #[inline]
                fn cmp(&self, other: &NSGrammaticalPerson) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSGrammaticalPerson {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSGrammaticalPerson {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSGrammaticalPerson {
                #[doc(alias = "NSGrammaticalPersonNotSet")]
                #[allow(non_upper_case_globals)]
                pub const NotSet: Self = Self(0);
                #[doc(alias = "NSGrammaticalPersonFirst")]
                #[allow(non_upper_case_globals)]
                pub const First: Self = Self(1);
                #[doc(alias = "NSGrammaticalPersonSecond")]
                #[allow(non_upper_case_globals)]
                pub const Second: Self = Self(2);
                #[doc(alias = "NSGrammaticalPersonThird")]
                #[allow(non_upper_case_globals)]
                pub const Third: Self = Self(3);
            }
            #[repr(transparent)]
            pub struct NSGrammaticalDetermination(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSGrammaticalDetermination {
                #[inline]
                fn clone(&self) -> NSGrammaticalDetermination {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSGrammaticalDetermination {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSGrammaticalDetermination {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSGrammaticalDetermination",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSGrammaticalDetermination {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSGrammaticalDetermination {
                #[inline]
                fn eq(&self, other: &NSGrammaticalDetermination) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSGrammaticalDetermination {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSGrammaticalDetermination {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSGrammaticalDetermination {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSGrammaticalDetermination {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSGrammaticalDetermination,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSGrammaticalDetermination {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSGrammaticalDetermination,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSGrammaticalDetermination {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSGrammaticalDetermination {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSGrammaticalDetermination {
                #[doc(alias = "NSGrammaticalDeterminationNotSet")]
                #[allow(non_upper_case_globals)]
                pub const NotSet: Self = Self(0);
                #[doc(alias = "NSGrammaticalDeterminationIndependent")]
                #[allow(non_upper_case_globals)]
                pub const Independent: Self = Self(1);
                #[doc(alias = "NSGrammaticalDeterminationDependent")]
                #[allow(non_upper_case_globals)]
                pub const Dependent: Self = Self(2);
            }
            #[repr(transparent)]
            pub struct NSGrammaticalDefiniteness(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSGrammaticalDefiniteness {
                #[inline]
                fn clone(&self) -> NSGrammaticalDefiniteness {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSGrammaticalDefiniteness {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSGrammaticalDefiniteness {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSGrammaticalDefiniteness",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSGrammaticalDefiniteness {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSGrammaticalDefiniteness {
                #[inline]
                fn eq(&self, other: &NSGrammaticalDefiniteness) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSGrammaticalDefiniteness {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSGrammaticalDefiniteness {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSGrammaticalDefiniteness {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSGrammaticalDefiniteness {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSGrammaticalDefiniteness,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSGrammaticalDefiniteness {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSGrammaticalDefiniteness,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSGrammaticalDefiniteness {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSGrammaticalDefiniteness {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSGrammaticalDefiniteness {
                #[doc(alias = "NSGrammaticalDefinitenessNotSet")]
                #[allow(non_upper_case_globals)]
                pub const NotSet: Self = Self(0);
                #[doc(alias = "NSGrammaticalDefinitenessIndefinite")]
                #[allow(non_upper_case_globals)]
                pub const Indefinite: Self = Self(1);
                #[doc(alias = "NSGrammaticalDefinitenessDefinite")]
                #[allow(non_upper_case_globals)]
                pub const Definite: Self = Self(2);
            }
        }
        #[path = "NSNetServices.rs"]
        mod __NSNetServices {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSNetServicesErrorCode: &'static NSString;
            }
            extern "C" {
                pub static NSNetServicesErrorDomain: &'static NSErrorDomain;
            }
            #[repr(transparent)]
            pub struct NSNetServicesError(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSNetServicesError {
                #[inline]
                fn clone(&self) -> NSNetServicesError {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSNetServicesError {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSNetServicesError {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSNetServicesError",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSNetServicesError {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSNetServicesError {
                #[inline]
                fn eq(&self, other: &NSNetServicesError) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSNetServicesError {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSNetServicesError {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSNetServicesError {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSNetServicesError {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSNetServicesError,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSNetServicesError {
                #[inline]
                fn cmp(&self, other: &NSNetServicesError) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSNetServicesError {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSNetServicesError {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSNetServicesError {
                #[allow(non_upper_case_globals)]
                pub const NSNetServicesUnknownError: Self = Self(-72000);
                #[allow(non_upper_case_globals)]
                pub const NSNetServicesCollisionError: Self = Self(-72001);
                #[allow(non_upper_case_globals)]
                pub const NSNetServicesNotFoundError: Self = Self(-72002);
                #[allow(non_upper_case_globals)]
                pub const NSNetServicesActivityInProgress: Self = Self(-72003);
                #[allow(non_upper_case_globals)]
                pub const NSNetServicesBadArgumentError: Self = Self(-72004);
                #[allow(non_upper_case_globals)]
                pub const NSNetServicesCancelledError: Self = Self(-72005);
                #[allow(non_upper_case_globals)]
                pub const NSNetServicesInvalidError: Self = Self(-72006);
                #[allow(non_upper_case_globals)]
                pub const NSNetServicesTimeoutError: Self = Self(-72007);
                #[allow(non_upper_case_globals)]
                pub const NSNetServicesMissingRequiredConfigurationError: Self = Self(
                    -72008,
                );
            }
            #[repr(transparent)]
            pub struct NSNetServiceOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSNetServiceOptions {
                #[inline]
                fn clone(&self) -> NSNetServiceOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSNetServiceOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSNetServiceOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSNetServiceOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSNetServiceOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSNetServiceOptions {
                #[inline]
                fn eq(&self, other: &NSNetServiceOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSNetServiceOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSNetServiceOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSNetServiceOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSNetServiceOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSNetServiceOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSNetServiceOptions {
                #[inline]
                fn cmp(&self, other: &NSNetServiceOptions) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSNetServiceOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSNetServiceOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSNetServiceOptions {
                #[allow(non_upper_case_globals)]
                pub const NSNetServiceNoAutoRename: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSNetServiceListenForConnections: Self = Self(1 << 1);
            }
            pub unsafe trait NSNetServiceDelegate: NSObjectProtocol {}
            unsafe impl<T> NSNetServiceDelegate for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSNetServiceDelegate,
            {}
            unsafe impl ProtocolType for dyn NSNetServiceDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSNetServiceDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSNetServiceDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSNetServiceDelegate,
            {
                const __INNER: () = ();
            }
            pub unsafe trait NSNetServiceBrowserDelegate: NSObjectProtocol {}
            unsafe impl<T> NSNetServiceBrowserDelegate
            for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSNetServiceBrowserDelegate,
            {}
            unsafe impl ProtocolType for dyn NSNetServiceBrowserDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSNetServiceBrowserDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSNetServiceBrowserDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSNetServiceBrowserDelegate,
            {
                const __INNER: () = ();
            }
        }
        #[path = "NSNotification.rs"]
        mod __NSNotification {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub type NSNotificationName = NSString;
        }
        #[path = "NSNotificationQueue.rs"]
        mod __NSNotificationQueue {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSPostingStyle(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSPostingStyle {
                #[inline]
                fn clone(&self) -> NSPostingStyle {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSPostingStyle {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSPostingStyle {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSPostingStyle",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSPostingStyle {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSPostingStyle {
                #[inline]
                fn eq(&self, other: &NSPostingStyle) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSPostingStyle {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSPostingStyle {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSPostingStyle {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSPostingStyle {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSPostingStyle,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSPostingStyle {
                #[inline]
                fn cmp(&self, other: &NSPostingStyle) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSPostingStyle {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSPostingStyle {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSPostingStyle {
                #[allow(non_upper_case_globals)]
                pub const NSPostWhenIdle: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSPostASAP: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSPostNow: Self = Self(3);
            }
            #[repr(transparent)]
            pub struct NSNotificationCoalescing(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSNotificationCoalescing {
                #[inline]
                fn clone(&self) -> NSNotificationCoalescing {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSNotificationCoalescing {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSNotificationCoalescing {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSNotificationCoalescing",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSNotificationCoalescing {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSNotificationCoalescing {
                #[inline]
                fn eq(&self, other: &NSNotificationCoalescing) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSNotificationCoalescing {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSNotificationCoalescing {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSNotificationCoalescing {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSNotificationCoalescing {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSNotificationCoalescing,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSNotificationCoalescing {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSNotificationCoalescing,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSNotificationCoalescing {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSNotificationCoalescing {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSNotificationCoalescing {
                #[allow(non_upper_case_globals)]
                pub const NSNotificationNoCoalescing: Self = Self(0);
                #[doc(alias = "NSNotificationCoalescingOnName")]
                #[allow(non_upper_case_globals)]
                pub const OnName: Self = Self(1);
                #[doc(alias = "NSNotificationCoalescingOnSender")]
                #[allow(non_upper_case_globals)]
                pub const OnSender: Self = Self(2);
            }
        }
        #[path = "NSNull.rs"]
        mod __NSNull {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSNumberFormatter.rs"]
        mod __NSNumberFormatter {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSNumberFormatterBehavior(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSNumberFormatterBehavior {
                #[inline]
                fn clone(&self) -> NSNumberFormatterBehavior {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSNumberFormatterBehavior {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSNumberFormatterBehavior {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSNumberFormatterBehavior",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSNumberFormatterBehavior {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSNumberFormatterBehavior {
                #[inline]
                fn eq(&self, other: &NSNumberFormatterBehavior) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSNumberFormatterBehavior {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSNumberFormatterBehavior {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSNumberFormatterBehavior {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSNumberFormatterBehavior {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSNumberFormatterBehavior,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSNumberFormatterBehavior {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSNumberFormatterBehavior,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSNumberFormatterBehavior {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSNumberFormatterBehavior {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSNumberFormatterBehavior {
                #[doc(alias = "NSNumberFormatterBehaviorDefault")]
                #[allow(non_upper_case_globals)]
                pub const Default: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterBehavior10_0: Self = Self(1000);
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterBehavior10_4: Self = Self(1040);
            }
            #[repr(transparent)]
            pub struct NSNumberFormatterStyle(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSNumberFormatterStyle {
                #[inline]
                fn clone(&self) -> NSNumberFormatterStyle {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSNumberFormatterStyle {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSNumberFormatterStyle {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSNumberFormatterStyle",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSNumberFormatterStyle {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSNumberFormatterStyle {
                #[inline]
                fn eq(&self, other: &NSNumberFormatterStyle) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSNumberFormatterStyle {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSNumberFormatterStyle {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSNumberFormatterStyle {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSNumberFormatterStyle {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSNumberFormatterStyle,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSNumberFormatterStyle {
                #[inline]
                fn cmp(&self, other: &NSNumberFormatterStyle) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSNumberFormatterStyle {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSNumberFormatterStyle {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSNumberFormatterStyle {
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterNoStyle: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterDecimalStyle: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterCurrencyStyle: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterPercentStyle: Self = Self(3);
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterScientificStyle: Self = Self(4);
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterSpellOutStyle: Self = Self(5);
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterOrdinalStyle: Self = Self(6);
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterCurrencyISOCodeStyle: Self = Self(8);
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterCurrencyPluralStyle: Self = Self(9);
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterCurrencyAccountingStyle: Self = Self(10);
            }
            #[repr(transparent)]
            pub struct NSNumberFormatterPadPosition(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSNumberFormatterPadPosition {
                #[inline]
                fn clone(&self) -> NSNumberFormatterPadPosition {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSNumberFormatterPadPosition {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSNumberFormatterPadPosition {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSNumberFormatterPadPosition",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSNumberFormatterPadPosition {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSNumberFormatterPadPosition {
                #[inline]
                fn eq(&self, other: &NSNumberFormatterPadPosition) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSNumberFormatterPadPosition {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSNumberFormatterPadPosition {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSNumberFormatterPadPosition {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSNumberFormatterPadPosition {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSNumberFormatterPadPosition,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSNumberFormatterPadPosition {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSNumberFormatterPadPosition,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSNumberFormatterPadPosition {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSNumberFormatterPadPosition {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSNumberFormatterPadPosition {
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterPadBeforePrefix: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterPadAfterPrefix: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterPadBeforeSuffix: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterPadAfterSuffix: Self = Self(3);
            }
            #[repr(transparent)]
            pub struct NSNumberFormatterRoundingMode(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSNumberFormatterRoundingMode {
                #[inline]
                fn clone(&self) -> NSNumberFormatterRoundingMode {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSNumberFormatterRoundingMode {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSNumberFormatterRoundingMode {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSNumberFormatterRoundingMode",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSNumberFormatterRoundingMode {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSNumberFormatterRoundingMode {
                #[inline]
                fn eq(&self, other: &NSNumberFormatterRoundingMode) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSNumberFormatterRoundingMode {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSNumberFormatterRoundingMode {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSNumberFormatterRoundingMode {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSNumberFormatterRoundingMode {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSNumberFormatterRoundingMode,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSNumberFormatterRoundingMode {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSNumberFormatterRoundingMode,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSNumberFormatterRoundingMode {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSNumberFormatterRoundingMode {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSNumberFormatterRoundingMode {
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterRoundCeiling: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterRoundFloor: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterRoundDown: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterRoundUp: Self = Self(3);
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterRoundHalfEven: Self = Self(4);
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterRoundHalfDown: Self = Self(5);
                #[allow(non_upper_case_globals)]
                pub const NSNumberFormatterRoundHalfUp: Self = Self(6);
            }
        }
        #[path = "NSObjCRuntime.rs"]
        mod __NSObjCRuntime {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSFoundationVersionNumber: c_double;
            }
            pub type NSExceptionName = NSString;
            pub type NSRunLoopMode = NSString;
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSStringFromSelector(a_selector: Sel) -> NonNull<NSString>;
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSSelectorFromString(a_selector_name: &NSString) -> Sel;
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSStringFromClass(a_class: &AnyClass) -> NonNull<NSString>;
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSClassFromString(a_class_name: &NSString) -> *const AnyClass;
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSStringFromProtocol(proto: &AnyProtocol) -> NonNull<NSString>;
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSProtocolFromString(namestr: &NSString) -> *mut AnyProtocol;
            }
            extern "C" {
                pub fn NSGetSizeAndAlignment(
                    type_ptr: NonNull<c_char>,
                    sizep: *mut NSUInteger,
                    alignp: *mut NSUInteger,
                ) -> NonNull<c_char>;
            }
            pub type NSComparator = *mut Block<
                dyn Fn(NonNull<AnyObject>, NonNull<AnyObject>) -> NSComparisonResult,
            >;
            #[repr(transparent)]
            pub struct NSEnumerationOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSEnumerationOptions {
                #[inline]
                fn clone(&self) -> NSEnumerationOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSEnumerationOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSEnumerationOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSEnumerationOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSEnumerationOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSEnumerationOptions {
                #[inline]
                fn eq(&self, other: &NSEnumerationOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSEnumerationOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSEnumerationOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSEnumerationOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSEnumerationOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSEnumerationOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSEnumerationOptions {
                #[inline]
                fn cmp(&self, other: &NSEnumerationOptions) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSEnumerationOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSEnumerationOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSEnumerationOptions {
                #[allow(non_upper_case_globals)]
                pub const NSEnumerationConcurrent: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSEnumerationReverse: Self = Self(1 << 1);
            }
            #[repr(transparent)]
            pub struct NSSortOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSSortOptions {
                #[inline]
                fn clone(&self) -> NSSortOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSSortOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSSortOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSSortOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSSortOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSSortOptions {
                #[inline]
                fn eq(&self, other: &NSSortOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSSortOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSSortOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSSortOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSSortOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSSortOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSSortOptions {
                #[inline]
                fn cmp(&self, other: &NSSortOptions) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSSortOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSSortOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSSortOptions {
                #[allow(non_upper_case_globals)]
                pub const NSSortConcurrent: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSSortStable: Self = Self(1 << 4);
            }
            #[repr(transparent)]
            pub struct NSQualityOfService(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSQualityOfService {
                #[inline]
                fn clone(&self) -> NSQualityOfService {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSQualityOfService {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSQualityOfService {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSQualityOfService",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSQualityOfService {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSQualityOfService {
                #[inline]
                fn eq(&self, other: &NSQualityOfService) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSQualityOfService {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSQualityOfService {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSQualityOfService {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSQualityOfService {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSQualityOfService,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSQualityOfService {
                #[inline]
                fn cmp(&self, other: &NSQualityOfService) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSQualityOfService {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSQualityOfService {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSQualityOfService {
                #[doc(alias = "NSQualityOfServiceUserInteractive")]
                #[allow(non_upper_case_globals)]
                pub const UserInteractive: Self = Self(0x21);
                #[doc(alias = "NSQualityOfServiceUserInitiated")]
                #[allow(non_upper_case_globals)]
                pub const UserInitiated: Self = Self(0x19);
                #[doc(alias = "NSQualityOfServiceUtility")]
                #[allow(non_upper_case_globals)]
                pub const Utility: Self = Self(0x11);
                #[doc(alias = "NSQualityOfServiceBackground")]
                #[allow(non_upper_case_globals)]
                pub const Background: Self = Self(0x09);
                #[doc(alias = "NSQualityOfServiceDefault")]
                #[allow(non_upper_case_globals)]
                pub const Default: Self = Self(-1);
            }
            pub static NSNotFound: NSInteger = NSIntegerMax as _;
        }
        #[path = "NSObject.rs"]
        mod __NSObject {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub unsafe trait NSCoding {}
            unsafe impl<T> NSCoding for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSCoding,
            {}
            unsafe impl ProtocolType for dyn NSCoding {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSCoding";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T> for dyn NSCoding
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message + NSCoding,
            {
                const __INNER: () = ();
            }
            pub unsafe trait NSSecureCoding: NSCoding {
                unsafe fn supportsSecureCoding() -> bool
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::ClassType,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("supportsSecureCoding\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
            }
            unsafe impl<T> NSSecureCoding for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSSecureCoding,
            {}
            unsafe impl ProtocolType for dyn NSSecureCoding {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSSecureCoding";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T> for dyn NSSecureCoding
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message + NSSecureCoding,
            {
                const __INNER: () = ();
            }
            /// Category "NSCoderMethods" on [`NSObject`].
            #[doc(alias = "NSCoderMethods")]
            pub unsafe trait NSObjectNSCoderMethods: ClassType {
                unsafe fn version() -> NSInteger
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::ClassType,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("version\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                unsafe fn setVersion(a_version: NSInteger)
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::ClassType,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("setVersion:\u{0}") }
                                    }
                                },
                                (a_version,),
                            );
                            result
                        }
                    }
                }
                unsafe fn classForCoder(&self) -> &'static AnyClass
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("classForCoder\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                #[doc(hidden)]
                const __UNSAFE_INNER: ();
            }
            unsafe impl NSObjectNSCoderMethods for NSObject {
                const __UNSAFE_INNER: () = ();
            }
            pub unsafe trait NSDiscardableContent {
                unsafe fn beginContentAccess(&self) -> bool
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("beginContentAccess\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                unsafe fn endContentAccess(&self)
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("endContentAccess\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                unsafe fn discardContentIfPossible(&self)
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("discardContentIfPossible\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                unsafe fn isContentDiscarded(&self) -> bool
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("isContentDiscarded\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
            }
            unsafe impl<T> NSDiscardableContent for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSDiscardableContent,
            {}
            unsafe impl ProtocolType for dyn NSDiscardableContent {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSDiscardableContent";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSDiscardableContent
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSDiscardableContent,
            {
                const __INNER: () = ();
            }
            /// Category "NSDiscardableContentProxy" on [`NSObject`].
            #[doc(alias = "NSDiscardableContentProxy")]
            pub unsafe trait NSObjectNSDiscardableContentProxy: ClassType {
                unsafe fn autoContentAccessingProxy(&self) -> Id<AnyObject>
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("autoContentAccessingProxy\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                #[doc(hidden)]
                const __UNSAFE_INNER: ();
            }
            unsafe impl NSObjectNSDiscardableContentProxy for NSObject {
                const __UNSAFE_INNER: () = ();
            }
            extern "C" {
                pub fn NSAllocateObject(
                    a_class: &AnyClass,
                    extra_bytes: NSUInteger,
                    zone: *mut NSZone,
                ) -> NonNull<AnyObject>;
            }
            extern "C" {
                pub fn NSDeallocateObject(object: &AnyObject);
            }
            #[deprecated = "Not supported"]
            extern "C" {
                pub fn NSCopyObject(
                    object: &AnyObject,
                    extra_bytes: NSUInteger,
                    zone: *mut NSZone,
                ) -> NonNull<AnyObject>;
            }
            extern "C" {
                pub fn NSShouldRetainWithZone(
                    an_object: &AnyObject,
                    requested_zone: *mut NSZone,
                ) -> Bool;
            }
            extern "C" {
                pub fn NSIncrementExtraRefCount(object: &AnyObject);
            }
            extern "C" {
                pub fn NSDecrementExtraRefCountWasZero(object: &AnyObject) -> Bool;
            }
            extern "C" {
                pub fn NSExtraRefCount(object: &AnyObject) -> NSUInteger;
            }
        }
        #[path = "NSObjectScripting.rs"]
        mod __NSObjectScripting {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            /// Category "NSScripting" on [`NSObject`].
            #[doc(alias = "NSScripting")]
            pub unsafe trait NSObjectNSScripting: ClassType {
                #[cfg(
                    all(
                        feature = "Foundation_NSDictionary",
                        feature = "Foundation_NSString"
                    )
                )]
                unsafe fn scriptingProperties(
                    &self,
                ) -> Option<Id<NSDictionary<NSString, AnyObject>>>
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("scriptingProperties\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                #[cfg(
                    all(
                        feature = "Foundation_NSDictionary",
                        feature = "Foundation_NSString"
                    )
                )]
                unsafe fn setScriptingProperties(
                    &self,
                    scripting_properties: Option<&NSDictionary<NSString, AnyObject>>,
                )
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("setScriptingProperties:\u{0}") }
                                    }
                                },
                                (scripting_properties,),
                            );
                            result
                        }
                    }
                }
                #[cfg(
                    all(
                        feature = "Foundation_NSDictionary",
                        feature = "Foundation_NSString"
                    )
                )]
                unsafe fn copyScriptingValue_forKey_withProperties(
                    &self,
                    value: &AnyObject,
                    key: &NSString,
                    properties: &NSDictionary<NSString, AnyObject>,
                ) -> Option<Id<AnyObject>>
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::CopyOrMutCopy as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("copyScriptingValue:forKey:withProperties:\u{0}")
                                        }
                                    }
                                },
                                (value, key, properties),
                            )
                        }
                    }
                }
                #[cfg(
                    all(
                        feature = "Foundation_NSDictionary",
                        feature = "Foundation_NSString"
                    )
                )]
                unsafe fn newScriptingObjectOfClass_forValueForKey_withContentsValue_properties(
                    &self,
                    object_class: &AnyClass,
                    key: &NSString,
                    contents_value: Option<&AnyObject>,
                    properties: &NSDictionary<NSString, AnyObject>,
                ) -> Option<Id<AnyObject>>
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::New as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get(
                                                    "newScriptingObjectOfClass:forValueForKey:withContentsValue:properties:\u{0}",
                                                )
                                        }
                                    }
                                },
                                (object_class, key, contents_value, properties),
                            )
                        }
                    }
                }
                #[doc(hidden)]
                const __UNSAFE_INNER: ();
            }
            unsafe impl NSObjectNSScripting for NSObject {
                const __UNSAFE_INNER: () = ();
            }
        }
        #[path = "NSOperation.rs"]
        mod __NSOperation {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSOperationQueuePriority(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSOperationQueuePriority {
                #[inline]
                fn clone(&self) -> NSOperationQueuePriority {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSOperationQueuePriority {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSOperationQueuePriority {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSOperationQueuePriority",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSOperationQueuePriority {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSOperationQueuePriority {
                #[inline]
                fn eq(&self, other: &NSOperationQueuePriority) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSOperationQueuePriority {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSOperationQueuePriority {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSOperationQueuePriority {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSOperationQueuePriority {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSOperationQueuePriority,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSOperationQueuePriority {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSOperationQueuePriority,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSOperationQueuePriority {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSOperationQueuePriority {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSOperationQueuePriority {
                #[doc(alias = "NSOperationQueuePriorityVeryLow")]
                #[allow(non_upper_case_globals)]
                pub const VeryLow: Self = Self(-8);
                #[doc(alias = "NSOperationQueuePriorityLow")]
                #[allow(non_upper_case_globals)]
                pub const Low: Self = Self(-4);
                #[doc(alias = "NSOperationQueuePriorityNormal")]
                #[allow(non_upper_case_globals)]
                pub const Normal: Self = Self(0);
                #[doc(alias = "NSOperationQueuePriorityHigh")]
                #[allow(non_upper_case_globals)]
                pub const High: Self = Self(4);
                #[doc(alias = "NSOperationQueuePriorityVeryHigh")]
                #[allow(non_upper_case_globals)]
                pub const VeryHigh: Self = Self(8);
            }
            extern "C" {
                pub static NSInvocationOperationVoidResultException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSInvocationOperationCancelledException: &'static NSExceptionName;
            }
            pub static NSOperationQueueDefaultMaxConcurrentOperationCount: NSInteger = -1;
        }
        #[path = "NSOrderedCollectionChange.rs"]
        mod __NSOrderedCollectionChange {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSCollectionChangeType(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSCollectionChangeType {
                #[inline]
                fn clone(&self) -> NSCollectionChangeType {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSCollectionChangeType {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSCollectionChangeType {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSCollectionChangeType",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSCollectionChangeType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSCollectionChangeType {
                #[inline]
                fn eq(&self, other: &NSCollectionChangeType) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSCollectionChangeType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSCollectionChangeType {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSCollectionChangeType {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSCollectionChangeType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSCollectionChangeType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSCollectionChangeType {
                #[inline]
                fn cmp(&self, other: &NSCollectionChangeType) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSCollectionChangeType {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSCollectionChangeType {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSCollectionChangeType {
                #[allow(non_upper_case_globals)]
                pub const NSCollectionChangeInsert: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSCollectionChangeRemove: Self = Self(1);
            }
        }
        #[path = "NSOrderedCollectionDifference.rs"]
        mod __NSOrderedCollectionDifference {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSOrderedCollectionDifferenceCalculationOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone
            for NSOrderedCollectionDifferenceCalculationOptions {
                #[inline]
                fn clone(&self) -> NSOrderedCollectionDifferenceCalculationOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy
            for NSOrderedCollectionDifferenceCalculationOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSOrderedCollectionDifferenceCalculationOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSOrderedCollectionDifferenceCalculationOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSOrderedCollectionDifferenceCalculationOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq
            for NSOrderedCollectionDifferenceCalculationOptions {
                #[inline]
                fn eq(
                    &self,
                    other: &NSOrderedCollectionDifferenceCalculationOptions,
                ) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq
            for NSOrderedCollectionDifferenceCalculationOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSOrderedCollectionDifferenceCalculationOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSOrderedCollectionDifferenceCalculationOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd
            for NSOrderedCollectionDifferenceCalculationOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSOrderedCollectionDifferenceCalculationOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSOrderedCollectionDifferenceCalculationOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSOrderedCollectionDifferenceCalculationOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode
            for NSOrderedCollectionDifferenceCalculationOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode
            for NSOrderedCollectionDifferenceCalculationOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSOrderedCollectionDifferenceCalculationOptions {
                #[allow(non_upper_case_globals)]
                pub const NSOrderedCollectionDifferenceCalculationOmitInsertedObjects: Self = Self(
                    1 << 0,
                );
                #[allow(non_upper_case_globals)]
                pub const NSOrderedCollectionDifferenceCalculationOmitRemovedObjects: Self = Self(
                    1 << 1,
                );
                #[allow(non_upper_case_globals)]
                pub const NSOrderedCollectionDifferenceCalculationInferMoves: Self = Self(
                    1 << 2,
                );
            }
        }
        #[path = "NSOrderedSet.rs"]
        mod __NSOrderedSet {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSOrthography.rs"]
        mod __NSOrthography {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSPathUtilities.rs"]
        mod __NSPathUtilities {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            /// NSStringPathExtensions
            #[cfg(feature = "Foundation_NSString")]
            impl NSString {
                pub unsafe fn isAbsolutePath(&self) -> bool {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("isAbsolutePath\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn lastPathComponent(&self) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("lastPathComponent\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn stringByDeletingLastPathComponent(&self) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("stringByDeletingLastPathComponent\u{0}")
                                        }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub fn stringByAppendingPathComponent(
                    &self,
                    str: &NSString,
                ) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("stringByAppendingPathComponent:\u{0}")
                                        }
                                    }
                                },
                                (str,),
                            )
                        }
                    }
                }
                pub unsafe fn pathExtension(&self) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("pathExtension\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn stringByDeletingPathExtension(&self) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("stringByDeletingPathExtension\u{0}")
                                        }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn stringByAppendingPathExtension(
                    &self,
                    str: &NSString,
                ) -> Option<Id<NSString>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("stringByAppendingPathExtension:\u{0}")
                                        }
                                    }
                                },
                                (str,),
                            )
                        }
                    }
                }
                pub unsafe fn stringByAbbreviatingWithTildeInPath(
                    &self,
                ) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("stringByAbbreviatingWithTildeInPath\u{0}")
                                        }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn stringByExpandingTildeInPath(&self) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("stringByExpandingTildeInPath\u{0}")
                                        }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn stringByStandardizingPath(&self) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("stringByStandardizingPath\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn stringByResolvingSymlinksInPath(&self) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("stringByResolvingSymlinksInPath\u{0}")
                                        }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn fileSystemRepresentation(&self) -> NonNull<c_char> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("fileSystemRepresentation\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn getFileSystemRepresentation_maxLength(
                    &self,
                    cname: NonNull<c_char>,
                    max: NSUInteger,
                ) -> bool {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("getFileSystemRepresentation:maxLength:\u{0}")
                                        }
                                    }
                                },
                                (cname, max),
                            );
                            result
                        }
                    }
                }
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSUserName() -> NonNull<NSString>;
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSFullUserName() -> NonNull<NSString>;
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSHomeDirectory() -> NonNull<NSString>;
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSHomeDirectoryForUser(
                    user_name: Option<&NSString>,
                ) -> *mut NSString;
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSTemporaryDirectory() -> NonNull<NSString>;
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSOpenStepRootDirectory() -> NonNull<NSString>;
            }
            #[repr(transparent)]
            pub struct NSSearchPathDirectory(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSSearchPathDirectory {
                #[inline]
                fn clone(&self) -> NSSearchPathDirectory {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSSearchPathDirectory {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSSearchPathDirectory {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSSearchPathDirectory",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSSearchPathDirectory {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSSearchPathDirectory {
                #[inline]
                fn eq(&self, other: &NSSearchPathDirectory) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSSearchPathDirectory {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSSearchPathDirectory {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSSearchPathDirectory {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSSearchPathDirectory {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSSearchPathDirectory,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSSearchPathDirectory {
                #[inline]
                fn cmp(&self, other: &NSSearchPathDirectory) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSSearchPathDirectory {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSSearchPathDirectory {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSSearchPathDirectory {
                #[allow(non_upper_case_globals)]
                pub const NSApplicationDirectory: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSDemoApplicationDirectory: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSDeveloperApplicationDirectory: Self = Self(3);
                #[allow(non_upper_case_globals)]
                pub const NSAdminApplicationDirectory: Self = Self(4);
                #[allow(non_upper_case_globals)]
                pub const NSLibraryDirectory: Self = Self(5);
                #[allow(non_upper_case_globals)]
                pub const NSDeveloperDirectory: Self = Self(6);
                #[allow(non_upper_case_globals)]
                pub const NSUserDirectory: Self = Self(7);
                #[allow(non_upper_case_globals)]
                pub const NSDocumentationDirectory: Self = Self(8);
                #[allow(non_upper_case_globals)]
                pub const NSDocumentDirectory: Self = Self(9);
                #[allow(non_upper_case_globals)]
                pub const NSCoreServiceDirectory: Self = Self(10);
                #[allow(non_upper_case_globals)]
                pub const NSAutosavedInformationDirectory: Self = Self(11);
                #[allow(non_upper_case_globals)]
                pub const NSDesktopDirectory: Self = Self(12);
                #[allow(non_upper_case_globals)]
                pub const NSCachesDirectory: Self = Self(13);
                #[allow(non_upper_case_globals)]
                pub const NSApplicationSupportDirectory: Self = Self(14);
                #[allow(non_upper_case_globals)]
                pub const NSDownloadsDirectory: Self = Self(15);
                #[allow(non_upper_case_globals)]
                pub const NSInputMethodsDirectory: Self = Self(16);
                #[allow(non_upper_case_globals)]
                pub const NSMoviesDirectory: Self = Self(17);
                #[allow(non_upper_case_globals)]
                pub const NSMusicDirectory: Self = Self(18);
                #[allow(non_upper_case_globals)]
                pub const NSPicturesDirectory: Self = Self(19);
                #[allow(non_upper_case_globals)]
                pub const NSPrinterDescriptionDirectory: Self = Self(20);
                #[allow(non_upper_case_globals)]
                pub const NSSharedPublicDirectory: Self = Self(21);
                #[allow(non_upper_case_globals)]
                pub const NSPreferencePanesDirectory: Self = Self(22);
                #[allow(non_upper_case_globals)]
                pub const NSApplicationScriptsDirectory: Self = Self(23);
                #[allow(non_upper_case_globals)]
                pub const NSItemReplacementDirectory: Self = Self(99);
                #[allow(non_upper_case_globals)]
                pub const NSAllApplicationsDirectory: Self = Self(100);
                #[allow(non_upper_case_globals)]
                pub const NSAllLibrariesDirectory: Self = Self(101);
                #[allow(non_upper_case_globals)]
                pub const NSTrashDirectory: Self = Self(102);
            }
            #[repr(transparent)]
            pub struct NSSearchPathDomainMask(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSSearchPathDomainMask {
                #[inline]
                fn clone(&self) -> NSSearchPathDomainMask {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSSearchPathDomainMask {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSSearchPathDomainMask {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSSearchPathDomainMask",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSSearchPathDomainMask {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSSearchPathDomainMask {
                #[inline]
                fn eq(&self, other: &NSSearchPathDomainMask) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSSearchPathDomainMask {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSSearchPathDomainMask {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSSearchPathDomainMask {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSSearchPathDomainMask {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSSearchPathDomainMask,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSSearchPathDomainMask {
                #[inline]
                fn cmp(&self, other: &NSSearchPathDomainMask) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSSearchPathDomainMask {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSSearchPathDomainMask {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSSearchPathDomainMask {
                #[allow(non_upper_case_globals)]
                pub const NSUserDomainMask: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSLocalDomainMask: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSNetworkDomainMask: Self = Self(4);
                #[allow(non_upper_case_globals)]
                pub const NSSystemDomainMask: Self = Self(8);
                #[allow(non_upper_case_globals)]
                pub const NSAllDomainsMask: Self = Self(0x0ffff);
            }
        }
        #[path = "NSPersonNameComponents.rs"]
        mod __NSPersonNameComponents {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSPersonNameComponentsFormatter.rs"]
        mod __NSPersonNameComponentsFormatter {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSPersonNameComponentsFormatterStyle(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSPersonNameComponentsFormatterStyle {
                #[inline]
                fn clone(&self) -> NSPersonNameComponentsFormatterStyle {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSPersonNameComponentsFormatterStyle {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSPersonNameComponentsFormatterStyle {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSPersonNameComponentsFormatterStyle",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSPersonNameComponentsFormatterStyle {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSPersonNameComponentsFormatterStyle {
                #[inline]
                fn eq(&self, other: &NSPersonNameComponentsFormatterStyle) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSPersonNameComponentsFormatterStyle {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSPersonNameComponentsFormatterStyle {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSPersonNameComponentsFormatterStyle {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSPersonNameComponentsFormatterStyle {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSPersonNameComponentsFormatterStyle,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSPersonNameComponentsFormatterStyle {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSPersonNameComponentsFormatterStyle,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSPersonNameComponentsFormatterStyle {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSPersonNameComponentsFormatterStyle {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSPersonNameComponentsFormatterStyle {
                #[doc(alias = "NSPersonNameComponentsFormatterStyleDefault")]
                #[allow(non_upper_case_globals)]
                pub const Default: Self = Self(0);
                #[doc(alias = "NSPersonNameComponentsFormatterStyleShort")]
                #[allow(non_upper_case_globals)]
                pub const Short: Self = Self(1);
                #[doc(alias = "NSPersonNameComponentsFormatterStyleMedium")]
                #[allow(non_upper_case_globals)]
                pub const Medium: Self = Self(2);
                #[doc(alias = "NSPersonNameComponentsFormatterStyleLong")]
                #[allow(non_upper_case_globals)]
                pub const Long: Self = Self(3);
                #[doc(alias = "NSPersonNameComponentsFormatterStyleAbbreviated")]
                #[allow(non_upper_case_globals)]
                pub const Abbreviated: Self = Self(4);
            }
            #[repr(transparent)]
            pub struct NSPersonNameComponentsFormatterOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSPersonNameComponentsFormatterOptions {
                #[inline]
                fn clone(&self) -> NSPersonNameComponentsFormatterOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSPersonNameComponentsFormatterOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSPersonNameComponentsFormatterOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSPersonNameComponentsFormatterOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSPersonNameComponentsFormatterOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSPersonNameComponentsFormatterOptions {
                #[inline]
                fn eq(&self, other: &NSPersonNameComponentsFormatterOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq
            for NSPersonNameComponentsFormatterOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSPersonNameComponentsFormatterOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSPersonNameComponentsFormatterOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSPersonNameComponentsFormatterOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSPersonNameComponentsFormatterOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSPersonNameComponentsFormatterOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSPersonNameComponentsFormatterOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSPersonNameComponentsFormatterOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSPersonNameComponentsFormatterOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSPersonNameComponentsFormatterOptions {
                #[allow(non_upper_case_globals)]
                pub const NSPersonNameComponentsFormatterPhonetic: Self = Self(1 << 1);
            }
            extern "C" {
                pub static NSPersonNameComponentKey: &'static NSString;
            }
            extern "C" {
                pub static NSPersonNameComponentGivenName: &'static NSString;
            }
            extern "C" {
                pub static NSPersonNameComponentFamilyName: &'static NSString;
            }
            extern "C" {
                pub static NSPersonNameComponentMiddleName: &'static NSString;
            }
            extern "C" {
                pub static NSPersonNameComponentPrefix: &'static NSString;
            }
            extern "C" {
                pub static NSPersonNameComponentSuffix: &'static NSString;
            }
            extern "C" {
                pub static NSPersonNameComponentNickname: &'static NSString;
            }
            extern "C" {
                pub static NSPersonNameComponentDelimiter: &'static NSString;
            }
        }
        #[path = "NSPointerArray.rs"]
        mod __NSPointerArray {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSPointerFunctions.rs"]
        mod __NSPointerFunctions {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSPointerFunctionsOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSPointerFunctionsOptions {
                #[inline]
                fn clone(&self) -> NSPointerFunctionsOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSPointerFunctionsOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSPointerFunctionsOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSPointerFunctionsOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSPointerFunctionsOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSPointerFunctionsOptions {
                #[inline]
                fn eq(&self, other: &NSPointerFunctionsOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSPointerFunctionsOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSPointerFunctionsOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSPointerFunctionsOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSPointerFunctionsOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSPointerFunctionsOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSPointerFunctionsOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSPointerFunctionsOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSPointerFunctionsOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSPointerFunctionsOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSPointerFunctionsOptions {
                #[allow(non_upper_case_globals)]
                pub const NSPointerFunctionsStrongMemory: Self = Self(0 << 0);
                #[deprecated = "GC no longer supported"]
                #[allow(non_upper_case_globals)]
                pub const NSPointerFunctionsZeroingWeakMemory: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSPointerFunctionsOpaqueMemory: Self = Self(2 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSPointerFunctionsMallocMemory: Self = Self(3 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSPointerFunctionsMachVirtualMemory: Self = Self(4 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSPointerFunctionsWeakMemory: Self = Self(5 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSPointerFunctionsObjectPersonality: Self = Self(0 << 8);
                #[allow(non_upper_case_globals)]
                pub const NSPointerFunctionsOpaquePersonality: Self = Self(1 << 8);
                #[allow(non_upper_case_globals)]
                pub const NSPointerFunctionsObjectPointerPersonality: Self = Self(
                    2 << 8,
                );
                #[allow(non_upper_case_globals)]
                pub const NSPointerFunctionsCStringPersonality: Self = Self(3 << 8);
                #[allow(non_upper_case_globals)]
                pub const NSPointerFunctionsStructPersonality: Self = Self(4 << 8);
                #[allow(non_upper_case_globals)]
                pub const NSPointerFunctionsIntegerPersonality: Self = Self(5 << 8);
                #[allow(non_upper_case_globals)]
                pub const NSPointerFunctionsCopyIn: Self = Self(1 << 16);
            }
        }
        #[path = "NSPort.rs"]
        mod __NSPort {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub type NSSocketNativeHandle = c_int;
            extern "C" {
                pub static NSPortDidBecomeInvalidNotification: &'static NSNotificationName;
            }
            pub unsafe trait NSPortDelegate: NSObjectProtocol {}
            unsafe impl<T> NSPortDelegate for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSPortDelegate,
            {}
            unsafe impl ProtocolType for dyn NSPortDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSPortDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T> for dyn NSPortDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message + NSPortDelegate,
            {
                const __INNER: () = ();
            }
            #[repr(transparent)]
            pub struct NSMachPortOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSMachPortOptions {
                #[inline]
                fn clone(&self) -> NSMachPortOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSMachPortOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSMachPortOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSMachPortOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSMachPortOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSMachPortOptions {
                #[inline]
                fn eq(&self, other: &NSMachPortOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSMachPortOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSMachPortOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSMachPortOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSMachPortOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSMachPortOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSMachPortOptions {
                #[inline]
                fn cmp(&self, other: &NSMachPortOptions) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSMachPortOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSMachPortOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSMachPortOptions {
                #[allow(non_upper_case_globals)]
                pub const NSMachPortDeallocateNone: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSMachPortDeallocateSendRight: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSMachPortDeallocateReceiveRight: Self = Self(1 << 1);
            }
            pub unsafe trait NSMachPortDelegate: NSPortDelegate {
                unsafe fn handleMachMessage(&self, msg: NonNull<c_void>)
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("handleMachMessage:\u{0}") }
                                    }
                                },
                                (msg,),
                            );
                            result
                        }
                    }
                }
            }
            unsafe impl<T> NSMachPortDelegate for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSMachPortDelegate,
            {}
            unsafe impl ProtocolType for dyn NSMachPortDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSMachPortDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T> for dyn NSMachPortDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSMachPortDelegate,
            {
                const __INNER: () = ();
            }
        }
        #[path = "NSPortCoder.rs"]
        mod __NSPortCoder {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSPortMessage.rs"]
        mod __NSPortMessage {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSPortNameServer.rs"]
        mod __NSPortNameServer {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSPredicate.rs"]
        mod __NSPredicate {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSProcessInfo.rs"]
        mod __NSProcessInfo {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[deprecated = "Not supported"]
            pub const NSWindowsNTOperatingSystem: c_uint = 1;
            #[deprecated = "Not supported"]
            pub const NSWindows95OperatingSystem: c_uint = 2;
            #[deprecated = "Not supported"]
            pub const NSSolarisOperatingSystem: c_uint = 3;
            #[deprecated = "Not supported"]
            pub const NSHPUXOperatingSystem: c_uint = 4;
            #[deprecated = "Not supported"]
            pub const NSMACHOperatingSystem: c_uint = 5;
            #[deprecated = "Not supported"]
            pub const NSSunOSOperatingSystem: c_uint = 6;
            #[deprecated = "Not supported"]
            pub const NSOSF1OperatingSystem: c_uint = 7;
            #[repr(C)]
            pub struct NSOperatingSystemVersion {
                pub majorVersion: NSInteger,
                pub minorVersion: NSInteger,
                pub patchVersion: NSInteger,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for NSOperatingSystemVersion {
                #[inline]
                fn clone(&self) -> NSOperatingSystemVersion {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSOperatingSystemVersion {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSOperatingSystemVersion {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "NSOperatingSystemVersion",
                        "majorVersion",
                        &self.majorVersion,
                        "minorVersion",
                        &self.minorVersion,
                        "patchVersion",
                        &&self.patchVersion,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSOperatingSystemVersion {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSOperatingSystemVersion {
                #[inline]
                fn eq(&self, other: &NSOperatingSystemVersion) -> bool {
                    self.majorVersion == other.majorVersion
                        && self.minorVersion == other.minorVersion
                        && self.patchVersion == other.patchVersion
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSOperatingSystemVersion {
                const ENCODING: objc2::Encoding = objc2::Encoding::Struct(
                    "?",
                    &[
                        <NSInteger as objc2::Encode>::ENCODING,
                        <NSInteger as objc2::Encode>::ENCODING,
                        <NSInteger as objc2::Encode>::ENCODING,
                    ],
                );
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSOperatingSystemVersion {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            unsafe impl Send for NSOperatingSystemVersion {}
            unsafe impl Sync for NSOperatingSystemVersion {}
            #[repr(transparent)]
            pub struct NSActivityOptions(pub u64);
            #[automatically_derived]
            impl ::core::clone::Clone for NSActivityOptions {
                #[inline]
                fn clone(&self) -> NSActivityOptions {
                    let _: ::core::clone::AssertParamIsClone<u64>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSActivityOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSActivityOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSActivityOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSActivityOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSActivityOptions {
                #[inline]
                fn eq(&self, other: &NSActivityOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSActivityOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSActivityOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u64>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSActivityOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSActivityOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSActivityOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSActivityOptions {
                #[inline]
                fn cmp(&self, other: &NSActivityOptions) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSActivityOptions {
                const ENCODING: objc2::Encoding = <u64 as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSActivityOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSActivityOptions {
                #[allow(non_upper_case_globals)]
                pub const NSActivityIdleDisplaySleepDisabled: Self = Self(1 << 40);
                #[allow(non_upper_case_globals)]
                pub const NSActivityIdleSystemSleepDisabled: Self = Self(1 << 20);
                #[allow(non_upper_case_globals)]
                pub const NSActivitySuddenTerminationDisabled: Self = Self(1 << 14);
                #[allow(non_upper_case_globals)]
                pub const NSActivityAutomaticTerminationDisabled: Self = Self(1 << 15);
                #[allow(non_upper_case_globals)]
                pub const NSActivityAnimationTrackingEnabled: Self = Self(1 << 45);
                #[allow(non_upper_case_globals)]
                pub const NSActivityTrackingEnabled: Self = Self(1 << 46);
                #[allow(non_upper_case_globals)]
                pub const NSActivityUserInitiated: Self = Self(
                    0x00FFFFFF | NSActivityOptions::NSActivityIdleSystemSleepDisabled.0,
                );
                #[allow(non_upper_case_globals)]
                pub const NSActivityUserInitiatedAllowingIdleSystemSleep: Self = Self(
                    NSActivityOptions::NSActivityUserInitiated.0
                        & !NSActivityOptions::NSActivityIdleSystemSleepDisabled.0,
                );
                #[allow(non_upper_case_globals)]
                pub const NSActivityBackground: Self = Self(0x000000FF);
                #[allow(non_upper_case_globals)]
                pub const NSActivityLatencyCritical: Self = Self(0xFF00000000);
                #[allow(non_upper_case_globals)]
                pub const NSActivityUserInteractive: Self = Self(
                    NSActivityOptions::NSActivityUserInitiated.0
                        | NSActivityOptions::NSActivityLatencyCritical.0,
                );
            }
            #[repr(transparent)]
            pub struct NSProcessInfoThermalState(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSProcessInfoThermalState {
                #[inline]
                fn clone(&self) -> NSProcessInfoThermalState {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSProcessInfoThermalState {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSProcessInfoThermalState {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSProcessInfoThermalState",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSProcessInfoThermalState {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSProcessInfoThermalState {
                #[inline]
                fn eq(&self, other: &NSProcessInfoThermalState) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSProcessInfoThermalState {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSProcessInfoThermalState {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSProcessInfoThermalState {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSProcessInfoThermalState {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSProcessInfoThermalState,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSProcessInfoThermalState {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSProcessInfoThermalState,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSProcessInfoThermalState {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSProcessInfoThermalState {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSProcessInfoThermalState {
                #[doc(alias = "NSProcessInfoThermalStateNominal")]
                #[allow(non_upper_case_globals)]
                pub const Nominal: Self = Self(0);
                #[doc(alias = "NSProcessInfoThermalStateFair")]
                #[allow(non_upper_case_globals)]
                pub const Fair: Self = Self(1);
                #[doc(alias = "NSProcessInfoThermalStateSerious")]
                #[allow(non_upper_case_globals)]
                pub const Serious: Self = Self(2);
                #[doc(alias = "NSProcessInfoThermalStateCritical")]
                #[allow(non_upper_case_globals)]
                pub const Critical: Self = Self(3);
            }
            extern "C" {
                pub static NSProcessInfoThermalStateDidChangeNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSProcessInfoPowerStateDidChangeNotification: &'static NSNotificationName;
            }
        }
        #[path = "NSProgress.rs"]
        mod __NSProgress {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub type NSProgressKind = NSString;
            pub type NSProgressUserInfoKey = NSString;
            pub type NSProgressFileOperationKind = NSString;
            pub type NSProgressUnpublishingHandler = *mut Block<dyn Fn()>;
            pub unsafe trait NSProgressReporting: NSObjectProtocol {}
            unsafe impl<T> NSProgressReporting for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSProgressReporting,
            {}
            unsafe impl ProtocolType for dyn NSProgressReporting {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSProgressReporting";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T> for dyn NSProgressReporting
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSProgressReporting,
            {
                const __INNER: () = ();
            }
            extern "C" {
                pub static NSProgressEstimatedTimeRemainingKey: &'static NSProgressUserInfoKey;
            }
            extern "C" {
                pub static NSProgressThroughputKey: &'static NSProgressUserInfoKey;
            }
            extern "C" {
                pub static NSProgressKindFile: &'static NSProgressKind;
            }
            extern "C" {
                pub static NSProgressFileOperationKindKey: &'static NSProgressUserInfoKey;
            }
            extern "C" {
                pub static NSProgressFileOperationKindDownloading: &'static NSProgressFileOperationKind;
            }
            extern "C" {
                pub static NSProgressFileOperationKindDecompressingAfterDownloading: &'static NSProgressFileOperationKind;
            }
            extern "C" {
                pub static NSProgressFileOperationKindReceiving: &'static NSProgressFileOperationKind;
            }
            extern "C" {
                pub static NSProgressFileOperationKindCopying: &'static NSProgressFileOperationKind;
            }
            extern "C" {
                pub static NSProgressFileOperationKindUploading: &'static NSProgressFileOperationKind;
            }
            extern "C" {
                pub static NSProgressFileOperationKindDuplicating: &'static NSProgressFileOperationKind;
            }
            extern "C" {
                pub static NSProgressFileURLKey: &'static NSProgressUserInfoKey;
            }
            extern "C" {
                pub static NSProgressFileTotalCountKey: &'static NSProgressUserInfoKey;
            }
            extern "C" {
                pub static NSProgressFileCompletedCountKey: &'static NSProgressUserInfoKey;
            }
            extern "C" {
                pub static NSProgressFileAnimationImageKey: &'static NSProgressUserInfoKey;
            }
            extern "C" {
                pub static NSProgressFileAnimationImageOriginalRectKey: &'static NSProgressUserInfoKey;
            }
            extern "C" {
                pub static NSProgressFileIconKey: &'static NSProgressUserInfoKey;
            }
        }
        #[path = "NSPropertyList.rs"]
        mod __NSPropertyList {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSPropertyListMutabilityOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSPropertyListMutabilityOptions {
                #[inline]
                fn clone(&self) -> NSPropertyListMutabilityOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSPropertyListMutabilityOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSPropertyListMutabilityOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSPropertyListMutabilityOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSPropertyListMutabilityOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSPropertyListMutabilityOptions {
                #[inline]
                fn eq(&self, other: &NSPropertyListMutabilityOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSPropertyListMutabilityOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSPropertyListMutabilityOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSPropertyListMutabilityOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSPropertyListMutabilityOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSPropertyListMutabilityOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSPropertyListMutabilityOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSPropertyListMutabilityOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSPropertyListMutabilityOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSPropertyListMutabilityOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSPropertyListMutabilityOptions {
                #[allow(non_upper_case_globals)]
                pub const NSPropertyListImmutable: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSPropertyListMutableContainers: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSPropertyListMutableContainersAndLeaves: Self = Self(2);
            }
            #[repr(transparent)]
            pub struct NSPropertyListFormat(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSPropertyListFormat {
                #[inline]
                fn clone(&self) -> NSPropertyListFormat {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSPropertyListFormat {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSPropertyListFormat {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSPropertyListFormat",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSPropertyListFormat {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSPropertyListFormat {
                #[inline]
                fn eq(&self, other: &NSPropertyListFormat) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSPropertyListFormat {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSPropertyListFormat {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSPropertyListFormat {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSPropertyListFormat {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSPropertyListFormat,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSPropertyListFormat {
                #[inline]
                fn cmp(&self, other: &NSPropertyListFormat) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSPropertyListFormat {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSPropertyListFormat {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSPropertyListFormat {
                #[allow(non_upper_case_globals)]
                pub const NSPropertyListOpenStepFormat: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSPropertyListXMLFormat_v1_0: Self = Self(100);
                #[allow(non_upper_case_globals)]
                pub const NSPropertyListBinaryFormat_v1_0: Self = Self(200);
            }
            pub type NSPropertyListReadOptions = NSPropertyListMutabilityOptions;
            pub type NSPropertyListWriteOptions = NSUInteger;
        }
        #[path = "NSProtocolChecker.rs"]
        mod __NSProtocolChecker {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSProxy.rs"]
        mod __NSProxy {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSRange.rs"]
        mod __NSRange {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub type NSRangePointer = *mut NSRange;
            extern "C" {
                pub fn NSUnionRange(range1: NSRange, range2: NSRange) -> NSRange;
            }
            extern "C" {
                pub fn NSIntersectionRange(range1: NSRange, range2: NSRange) -> NSRange;
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSStringFromRange(range: NSRange) -> NonNull<NSString>;
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSRangeFromString(a_string: &NSString) -> NSRange;
            }
        }
        #[path = "NSRegularExpression.rs"]
        mod __NSRegularExpression {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSRegularExpressionOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSRegularExpressionOptions {
                #[inline]
                fn clone(&self) -> NSRegularExpressionOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSRegularExpressionOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSRegularExpressionOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSRegularExpressionOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSRegularExpressionOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSRegularExpressionOptions {
                #[inline]
                fn eq(&self, other: &NSRegularExpressionOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSRegularExpressionOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSRegularExpressionOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSRegularExpressionOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSRegularExpressionOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSRegularExpressionOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSRegularExpressionOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSRegularExpressionOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSRegularExpressionOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSRegularExpressionOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSRegularExpressionOptions {
                #[allow(non_upper_case_globals)]
                pub const NSRegularExpressionCaseInsensitive: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSRegularExpressionAllowCommentsAndWhitespace: Self = Self(
                    1 << 1,
                );
                #[allow(non_upper_case_globals)]
                pub const NSRegularExpressionIgnoreMetacharacters: Self = Self(1 << 2);
                #[allow(non_upper_case_globals)]
                pub const NSRegularExpressionDotMatchesLineSeparators: Self = Self(
                    1 << 3,
                );
                #[allow(non_upper_case_globals)]
                pub const NSRegularExpressionAnchorsMatchLines: Self = Self(1 << 4);
                #[allow(non_upper_case_globals)]
                pub const NSRegularExpressionUseUnixLineSeparators: Self = Self(1 << 5);
                #[allow(non_upper_case_globals)]
                pub const NSRegularExpressionUseUnicodeWordBoundaries: Self = Self(
                    1 << 6,
                );
            }
            #[repr(transparent)]
            pub struct NSMatchingOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSMatchingOptions {
                #[inline]
                fn clone(&self) -> NSMatchingOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSMatchingOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSMatchingOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSMatchingOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSMatchingOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSMatchingOptions {
                #[inline]
                fn eq(&self, other: &NSMatchingOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSMatchingOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSMatchingOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSMatchingOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSMatchingOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSMatchingOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSMatchingOptions {
                #[inline]
                fn cmp(&self, other: &NSMatchingOptions) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSMatchingOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSMatchingOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSMatchingOptions {
                #[allow(non_upper_case_globals)]
                pub const NSMatchingReportProgress: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSMatchingReportCompletion: Self = Self(1 << 1);
                #[allow(non_upper_case_globals)]
                pub const NSMatchingAnchored: Self = Self(1 << 2);
                #[allow(non_upper_case_globals)]
                pub const NSMatchingWithTransparentBounds: Self = Self(1 << 3);
                #[allow(non_upper_case_globals)]
                pub const NSMatchingWithoutAnchoringBounds: Self = Self(1 << 4);
            }
            #[repr(transparent)]
            pub struct NSMatchingFlags(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSMatchingFlags {
                #[inline]
                fn clone(&self) -> NSMatchingFlags {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSMatchingFlags {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSMatchingFlags {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSMatchingFlags",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSMatchingFlags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSMatchingFlags {
                #[inline]
                fn eq(&self, other: &NSMatchingFlags) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSMatchingFlags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSMatchingFlags {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSMatchingFlags {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSMatchingFlags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSMatchingFlags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSMatchingFlags {
                #[inline]
                fn cmp(&self, other: &NSMatchingFlags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSMatchingFlags {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSMatchingFlags {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSMatchingFlags {
                #[allow(non_upper_case_globals)]
                pub const NSMatchingProgress: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSMatchingCompleted: Self = Self(1 << 1);
                #[allow(non_upper_case_globals)]
                pub const NSMatchingHitEnd: Self = Self(1 << 2);
                #[allow(non_upper_case_globals)]
                pub const NSMatchingRequiredEnd: Self = Self(1 << 3);
                #[allow(non_upper_case_globals)]
                pub const NSMatchingInternalError: Self = Self(1 << 4);
            }
        }
        #[path = "NSRelativeDateTimeFormatter.rs"]
        mod __NSRelativeDateTimeFormatter {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSRelativeDateTimeFormatterStyle(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSRelativeDateTimeFormatterStyle {
                #[inline]
                fn clone(&self) -> NSRelativeDateTimeFormatterStyle {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSRelativeDateTimeFormatterStyle {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSRelativeDateTimeFormatterStyle {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSRelativeDateTimeFormatterStyle",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSRelativeDateTimeFormatterStyle {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSRelativeDateTimeFormatterStyle {
                #[inline]
                fn eq(&self, other: &NSRelativeDateTimeFormatterStyle) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSRelativeDateTimeFormatterStyle {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSRelativeDateTimeFormatterStyle {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSRelativeDateTimeFormatterStyle {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSRelativeDateTimeFormatterStyle {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSRelativeDateTimeFormatterStyle,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSRelativeDateTimeFormatterStyle {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSRelativeDateTimeFormatterStyle,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSRelativeDateTimeFormatterStyle {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSRelativeDateTimeFormatterStyle {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSRelativeDateTimeFormatterStyle {
                #[doc(alias = "NSRelativeDateTimeFormatterStyleNumeric")]
                #[allow(non_upper_case_globals)]
                pub const Numeric: Self = Self(0);
                #[doc(alias = "NSRelativeDateTimeFormatterStyleNamed")]
                #[allow(non_upper_case_globals)]
                pub const Named: Self = Self(1);
            }
            #[repr(transparent)]
            pub struct NSRelativeDateTimeFormatterUnitsStyle(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSRelativeDateTimeFormatterUnitsStyle {
                #[inline]
                fn clone(&self) -> NSRelativeDateTimeFormatterUnitsStyle {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSRelativeDateTimeFormatterUnitsStyle {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSRelativeDateTimeFormatterUnitsStyle {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSRelativeDateTimeFormatterUnitsStyle",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSRelativeDateTimeFormatterUnitsStyle {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSRelativeDateTimeFormatterUnitsStyle {
                #[inline]
                fn eq(&self, other: &NSRelativeDateTimeFormatterUnitsStyle) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSRelativeDateTimeFormatterUnitsStyle {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSRelativeDateTimeFormatterUnitsStyle {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSRelativeDateTimeFormatterUnitsStyle {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSRelativeDateTimeFormatterUnitsStyle {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSRelativeDateTimeFormatterUnitsStyle,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSRelativeDateTimeFormatterUnitsStyle {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSRelativeDateTimeFormatterUnitsStyle,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSRelativeDateTimeFormatterUnitsStyle {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSRelativeDateTimeFormatterUnitsStyle {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSRelativeDateTimeFormatterUnitsStyle {
                #[doc(alias = "NSRelativeDateTimeFormatterUnitsStyleFull")]
                #[allow(non_upper_case_globals)]
                pub const Full: Self = Self(0);
                #[doc(alias = "NSRelativeDateTimeFormatterUnitsStyleSpellOut")]
                #[allow(non_upper_case_globals)]
                pub const SpellOut: Self = Self(1);
                #[doc(alias = "NSRelativeDateTimeFormatterUnitsStyleShort")]
                #[allow(non_upper_case_globals)]
                pub const Short: Self = Self(2);
                #[doc(alias = "NSRelativeDateTimeFormatterUnitsStyleAbbreviated")]
                #[allow(non_upper_case_globals)]
                pub const Abbreviated: Self = Self(3);
            }
        }
        #[path = "NSRunLoop.rs"]
        mod __NSRunLoop {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSDefaultRunLoopMode: &'static NSRunLoopMode;
            }
            extern "C" {
                pub static NSRunLoopCommonModes: &'static NSRunLoopMode;
            }
            /// Category "NSDelayedPerforming" on [`NSObject`].
            #[doc(alias = "NSDelayedPerforming")]
            pub unsafe trait NSObjectNSDelayedPerforming: ClassType {
                unsafe fn performSelector_withObject_afterDelay(
                    &self,
                    a_selector: Sel,
                    an_argument: Option<&AnyObject>,
                    delay: NSTimeInterval,
                )
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("performSelector:withObject:afterDelay:\u{0}")
                                        }
                                    }
                                },
                                (a_selector, an_argument, delay),
                            );
                            result
                        }
                    }
                }
                unsafe fn cancelPreviousPerformRequestsWithTarget_selector_object(
                    a_target: &AnyObject,
                    a_selector: Sel,
                    an_argument: Option<&AnyObject>,
                )
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::ClassType,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get(
                                                    "cancelPreviousPerformRequestsWithTarget:selector:object:\u{0}",
                                                )
                                        }
                                    }
                                },
                                (a_target, a_selector, an_argument),
                            );
                            result
                        }
                    }
                }
                unsafe fn cancelPreviousPerformRequestsWithTarget(a_target: &AnyObject)
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::ClassType,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("cancelPreviousPerformRequestsWithTarget:\u{0}")
                                        }
                                    }
                                },
                                (a_target,),
                            );
                            result
                        }
                    }
                }
                #[doc(hidden)]
                const __UNSAFE_INNER: ();
            }
            unsafe impl NSObjectNSDelayedPerforming for NSObject {
                const __UNSAFE_INNER: () = ();
            }
        }
        #[path = "NSScanner.rs"]
        mod __NSScanner {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSScriptClassDescription.rs"]
        mod __NSScriptClassDescription {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            /// Category "NSScriptClassDescription" on [`NSObject`].
            #[doc(alias = "NSScriptClassDescription")]
            pub unsafe trait NSObjectNSScriptClassDescription: ClassType {
                unsafe fn classCode(&self) -> FourCharCode
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("classCode\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn className(&self) -> Id<NSString>
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("className\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                #[doc(hidden)]
                const __UNSAFE_INNER: ();
            }
            unsafe impl NSObjectNSScriptClassDescription for NSObject {
                const __UNSAFE_INNER: () = ();
            }
        }
        #[path = "NSScriptCoercionHandler.rs"]
        mod __NSScriptCoercionHandler {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSScriptCommand.rs"]
        mod __NSScriptCommand {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub const NSNoScriptError: NSInteger = 0;
            pub const NSReceiverEvaluationScriptError: NSInteger = 1;
            pub const NSKeySpecifierEvaluationScriptError: NSInteger = 2;
            pub const NSArgumentEvaluationScriptError: NSInteger = 3;
            pub const NSReceiversCantHandleCommandScriptError: NSInteger = 4;
            pub const NSRequiredArgumentsMissingScriptError: NSInteger = 5;
            pub const NSArgumentsWrongScriptError: NSInteger = 6;
            pub const NSUnknownKeyScriptError: NSInteger = 7;
            pub const NSInternalScriptError: NSInteger = 8;
            pub const NSOperationNotSupportedForKeyScriptError: NSInteger = 9;
            pub const NSCannotCreateScriptCommandError: NSInteger = 10;
        }
        #[path = "NSScriptCommandDescription.rs"]
        mod __NSScriptCommandDescription {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSScriptExecutionContext.rs"]
        mod __NSScriptExecutionContext {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSScriptKeyValueCoding.rs"]
        mod __NSScriptKeyValueCoding {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSOperationNotSupportedForKeyException: &'static NSString;
            }
            /// Category "NSScriptKeyValueCoding" on [`NSObject`].
            #[doc(alias = "NSScriptKeyValueCoding")]
            pub unsafe trait NSObjectNSScriptKeyValueCoding: ClassType {
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn valueAtIndex_inPropertyWithKey(
                    &self,
                    index: NSUInteger,
                    key: &NSString,
                ) -> Option<Id<AnyObject>>
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("valueAtIndex:inPropertyWithKey:\u{0}")
                                        }
                                    }
                                },
                                (index, key),
                            )
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn valueWithName_inPropertyWithKey(
                    &self,
                    name: &NSString,
                    key: &NSString,
                ) -> Option<Id<AnyObject>>
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("valueWithName:inPropertyWithKey:\u{0}")
                                        }
                                    }
                                },
                                (name, key),
                            )
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn valueWithUniqueID_inPropertyWithKey(
                    &self,
                    unique_id: &AnyObject,
                    key: &NSString,
                ) -> Option<Id<AnyObject>>
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("valueWithUniqueID:inPropertyWithKey:\u{0}")
                                        }
                                    }
                                },
                                (unique_id, key),
                            )
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn insertValue_atIndex_inPropertyWithKey(
                    &self,
                    value: &AnyObject,
                    index: NSUInteger,
                    key: &NSString,
                )
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("insertValue:atIndex:inPropertyWithKey:\u{0}")
                                        }
                                    }
                                },
                                (value, index, key),
                            );
                            result
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn removeValueAtIndex_fromPropertyWithKey(
                    &self,
                    index: NSUInteger,
                    key: &NSString,
                )
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("removeValueAtIndex:fromPropertyWithKey:\u{0}")
                                        }
                                    }
                                },
                                (index, key),
                            );
                            result
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn replaceValueAtIndex_inPropertyWithKey_withValue(
                    &self,
                    index: NSUInteger,
                    key: &NSString,
                    value: &AnyObject,
                )
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get(
                                                    "replaceValueAtIndex:inPropertyWithKey:withValue:\u{0}",
                                                )
                                        }
                                    }
                                },
                                (index, key, value),
                            );
                            result
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn insertValue_inPropertyWithKey(
                    &self,
                    value: &AnyObject,
                    key: &NSString,
                )
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("insertValue:inPropertyWithKey:\u{0}")
                                        }
                                    }
                                },
                                (value, key),
                            );
                            result
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn coerceValue_forKey(
                    &self,
                    value: Option<&AnyObject>,
                    key: &NSString,
                ) -> Option<Id<AnyObject>>
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("coerceValue:forKey:\u{0}") }
                                    }
                                },
                                (value, key),
                            )
                        }
                    }
                }
                #[doc(hidden)]
                const __UNSAFE_INNER: ();
            }
            unsafe impl NSObjectNSScriptKeyValueCoding for NSObject {
                const __UNSAFE_INNER: () = ();
            }
        }
        #[path = "NSScriptObjectSpecifiers.rs"]
        mod __NSScriptObjectSpecifiers {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub const NSNoSpecifierError: NSInteger = 0;
            pub const NSNoTopLevelContainersSpecifierError: NSInteger = 1;
            pub const NSContainerSpecifierError: NSInteger = 2;
            pub const NSUnknownKeySpecifierError: NSInteger = 3;
            pub const NSInvalidIndexSpecifierError: NSInteger = 4;
            pub const NSInternalSpecifierError: NSInteger = 5;
            pub const NSOperationNotSupportedForKeySpecifierError: NSInteger = 6;
            #[repr(transparent)]
            pub struct NSInsertionPosition(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSInsertionPosition {
                #[inline]
                fn clone(&self) -> NSInsertionPosition {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSInsertionPosition {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSInsertionPosition {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSInsertionPosition",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSInsertionPosition {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSInsertionPosition {
                #[inline]
                fn eq(&self, other: &NSInsertionPosition) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSInsertionPosition {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSInsertionPosition {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSInsertionPosition {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSInsertionPosition {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSInsertionPosition,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSInsertionPosition {
                #[inline]
                fn cmp(&self, other: &NSInsertionPosition) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSInsertionPosition {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSInsertionPosition {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSInsertionPosition {
                #[allow(non_upper_case_globals)]
                pub const NSPositionAfter: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSPositionBefore: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSPositionBeginning: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSPositionEnd: Self = Self(3);
                #[allow(non_upper_case_globals)]
                pub const NSPositionReplace: Self = Self(4);
            }
            #[repr(transparent)]
            pub struct NSRelativePosition(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSRelativePosition {
                #[inline]
                fn clone(&self) -> NSRelativePosition {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSRelativePosition {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSRelativePosition {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSRelativePosition",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSRelativePosition {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSRelativePosition {
                #[inline]
                fn eq(&self, other: &NSRelativePosition) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSRelativePosition {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSRelativePosition {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSRelativePosition {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSRelativePosition {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSRelativePosition,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSRelativePosition {
                #[inline]
                fn cmp(&self, other: &NSRelativePosition) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSRelativePosition {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSRelativePosition {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSRelativePosition {
                #[allow(non_upper_case_globals)]
                pub const NSRelativeAfter: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSRelativeBefore: Self = Self(1);
            }
            #[repr(transparent)]
            pub struct NSWhoseSubelementIdentifier(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSWhoseSubelementIdentifier {
                #[inline]
                fn clone(&self) -> NSWhoseSubelementIdentifier {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSWhoseSubelementIdentifier {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSWhoseSubelementIdentifier {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSWhoseSubelementIdentifier",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSWhoseSubelementIdentifier {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSWhoseSubelementIdentifier {
                #[inline]
                fn eq(&self, other: &NSWhoseSubelementIdentifier) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSWhoseSubelementIdentifier {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSWhoseSubelementIdentifier {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSWhoseSubelementIdentifier {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSWhoseSubelementIdentifier {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSWhoseSubelementIdentifier,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSWhoseSubelementIdentifier {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSWhoseSubelementIdentifier,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSWhoseSubelementIdentifier {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSWhoseSubelementIdentifier {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSWhoseSubelementIdentifier {
                #[allow(non_upper_case_globals)]
                pub const NSIndexSubelement: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSEverySubelement: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSMiddleSubelement: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSRandomSubelement: Self = Self(3);
                #[allow(non_upper_case_globals)]
                pub const NSNoSubelement: Self = Self(4);
            }
            /// Category "NSScriptObjectSpecifiers" on [`NSObject`].
            #[doc(alias = "NSScriptObjectSpecifiers")]
            pub unsafe trait NSObjectNSScriptObjectSpecifiers: ClassType {
                #[doc(hidden)]
                const __UNSAFE_INNER: ();
            }
            unsafe impl NSObjectNSScriptObjectSpecifiers for NSObject {
                const __UNSAFE_INNER: () = ();
            }
        }
        #[path = "NSScriptStandardSuiteCommands.rs"]
        mod __NSScriptStandardSuiteCommands {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSSaveOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSSaveOptions {
                #[inline]
                fn clone(&self) -> NSSaveOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSSaveOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSSaveOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSSaveOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSSaveOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSSaveOptions {
                #[inline]
                fn eq(&self, other: &NSSaveOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSSaveOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSSaveOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSSaveOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSSaveOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSSaveOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSSaveOptions {
                #[inline]
                fn cmp(&self, other: &NSSaveOptions) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSSaveOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSSaveOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSSaveOptions {
                #[doc(alias = "NSSaveOptionsYes")]
                #[allow(non_upper_case_globals)]
                pub const Yes: Self = Self(0);
                #[doc(alias = "NSSaveOptionsNo")]
                #[allow(non_upper_case_globals)]
                pub const No: Self = Self(1);
                #[doc(alias = "NSSaveOptionsAsk")]
                #[allow(non_upper_case_globals)]
                pub const Ask: Self = Self(2);
            }
        }
        #[path = "NSScriptSuiteRegistry.rs"]
        mod __NSScriptSuiteRegistry {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSScriptWhoseTests.rs"]
        mod __NSScriptWhoseTests {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSTestComparisonOperation(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSTestComparisonOperation {
                #[inline]
                fn clone(&self) -> NSTestComparisonOperation {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSTestComparisonOperation {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSTestComparisonOperation {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSTestComparisonOperation",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSTestComparisonOperation {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSTestComparisonOperation {
                #[inline]
                fn eq(&self, other: &NSTestComparisonOperation) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSTestComparisonOperation {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSTestComparisonOperation {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSTestComparisonOperation {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSTestComparisonOperation {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSTestComparisonOperation,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSTestComparisonOperation {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSTestComparisonOperation,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSTestComparisonOperation {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSTestComparisonOperation {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSTestComparisonOperation {
                #[allow(non_upper_case_globals)]
                pub const NSEqualToComparison: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSLessThanOrEqualToComparison: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSLessThanComparison: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSGreaterThanOrEqualToComparison: Self = Self(3);
                #[allow(non_upper_case_globals)]
                pub const NSGreaterThanComparison: Self = Self(4);
                #[allow(non_upper_case_globals)]
                pub const NSBeginsWithComparison: Self = Self(5);
                #[allow(non_upper_case_globals)]
                pub const NSEndsWithComparison: Self = Self(6);
                #[allow(non_upper_case_globals)]
                pub const NSContainsComparison: Self = Self(7);
            }
            /// Category "NSComparisonMethods" on [`NSObject`].
            #[doc(alias = "NSComparisonMethods")]
            pub unsafe trait NSObjectNSComparisonMethods: ClassType {
                unsafe fn isEqualTo(&self, object: Option<&AnyObject>) -> bool
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("isEqualTo:\u{0}") }
                                    }
                                },
                                (object,),
                            );
                            result
                        }
                    }
                }
                unsafe fn isLessThanOrEqualTo(&self, object: Option<&AnyObject>) -> bool
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("isLessThanOrEqualTo:\u{0}") }
                                    }
                                },
                                (object,),
                            );
                            result
                        }
                    }
                }
                unsafe fn isLessThan(&self, object: Option<&AnyObject>) -> bool
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("isLessThan:\u{0}") }
                                    }
                                },
                                (object,),
                            );
                            result
                        }
                    }
                }
                unsafe fn isGreaterThanOrEqualTo(
                    &self,
                    object: Option<&AnyObject>,
                ) -> bool
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("isGreaterThanOrEqualTo:\u{0}") }
                                    }
                                },
                                (object,),
                            );
                            result
                        }
                    }
                }
                unsafe fn isGreaterThan(&self, object: Option<&AnyObject>) -> bool
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("isGreaterThan:\u{0}") }
                                    }
                                },
                                (object,),
                            );
                            result
                        }
                    }
                }
                unsafe fn isNotEqualTo(&self, object: Option<&AnyObject>) -> bool
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("isNotEqualTo:\u{0}") }
                                    }
                                },
                                (object,),
                            );
                            result
                        }
                    }
                }
                unsafe fn doesContain(&self, object: &AnyObject) -> bool
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("doesContain:\u{0}") }
                                    }
                                },
                                (object,),
                            );
                            result
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn isLike(&self, object: &NSString) -> bool
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("isLike:\u{0}") }
                                    }
                                },
                                (object,),
                            );
                            result
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSString")]
                unsafe fn isCaseInsensitiveLike(&self, object: &NSString) -> bool
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("isCaseInsensitiveLike:\u{0}") }
                                    }
                                },
                                (object,),
                            );
                            result
                        }
                    }
                }
                #[doc(hidden)]
                const __UNSAFE_INNER: ();
            }
            unsafe impl NSObjectNSComparisonMethods for NSObject {
                const __UNSAFE_INNER: () = ();
            }
            /// Category "NSScriptingComparisonMethods" on [`NSObject`].
            #[doc(alias = "NSScriptingComparisonMethods")]
            pub unsafe trait NSObjectNSScriptingComparisonMethods: ClassType {
                unsafe fn scriptingIsEqualTo(&self, object: &AnyObject) -> bool
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("scriptingIsEqualTo:\u{0}") }
                                    }
                                },
                                (object,),
                            );
                            result
                        }
                    }
                }
                unsafe fn scriptingIsLessThanOrEqualTo(&self, object: &AnyObject) -> bool
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("scriptingIsLessThanOrEqualTo:\u{0}")
                                        }
                                    }
                                },
                                (object,),
                            );
                            result
                        }
                    }
                }
                unsafe fn scriptingIsLessThan(&self, object: &AnyObject) -> bool
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("scriptingIsLessThan:\u{0}") }
                                    }
                                },
                                (object,),
                            );
                            result
                        }
                    }
                }
                unsafe fn scriptingIsGreaterThanOrEqualTo(
                    &self,
                    object: &AnyObject,
                ) -> bool
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("scriptingIsGreaterThanOrEqualTo:\u{0}")
                                        }
                                    }
                                },
                                (object,),
                            );
                            result
                        }
                    }
                }
                unsafe fn scriptingIsGreaterThan(&self, object: &AnyObject) -> bool
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("scriptingIsGreaterThan:\u{0}") }
                                    }
                                },
                                (object,),
                            );
                            result
                        }
                    }
                }
                unsafe fn scriptingBeginsWith(&self, object: &AnyObject) -> bool
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("scriptingBeginsWith:\u{0}") }
                                    }
                                },
                                (object,),
                            );
                            result
                        }
                    }
                }
                unsafe fn scriptingEndsWith(&self, object: &AnyObject) -> bool
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("scriptingEndsWith:\u{0}") }
                                    }
                                },
                                (object,),
                            );
                            result
                        }
                    }
                }
                unsafe fn scriptingContains(&self, object: &AnyObject) -> bool
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("scriptingContains:\u{0}") }
                                    }
                                },
                                (object,),
                            );
                            result
                        }
                    }
                }
                #[doc(hidden)]
                const __UNSAFE_INNER: ();
            }
            unsafe impl NSObjectNSScriptingComparisonMethods for NSObject {
                const __UNSAFE_INNER: () = ();
            }
        }
        #[path = "NSSet.rs"]
        mod __NSSet {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSSortDescriptor.rs"]
        mod __NSSortDescriptor {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSSpellServer.rs"]
        mod __NSSpellServer {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSGrammarRange: &'static NSString;
            }
            extern "C" {
                pub static NSGrammarUserDescription: &'static NSString;
            }
            extern "C" {
                pub static NSGrammarCorrections: &'static NSString;
            }
            pub unsafe trait NSSpellServerDelegate: NSObjectProtocol {}
            unsafe impl<T> NSSpellServerDelegate for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSSpellServerDelegate,
            {}
            unsafe impl ProtocolType for dyn NSSpellServerDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSSpellServerDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSSpellServerDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSSpellServerDelegate,
            {
                const __INNER: () = ();
            }
        }
        #[path = "NSStream.rs"]
        mod __NSStream {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub type NSStreamPropertyKey = NSString;
            #[repr(transparent)]
            pub struct NSStreamStatus(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSStreamStatus {
                #[inline]
                fn clone(&self) -> NSStreamStatus {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSStreamStatus {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSStreamStatus {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSStreamStatus",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSStreamStatus {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSStreamStatus {
                #[inline]
                fn eq(&self, other: &NSStreamStatus) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSStreamStatus {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSStreamStatus {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSStreamStatus {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSStreamStatus {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSStreamStatus,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSStreamStatus {
                #[inline]
                fn cmp(&self, other: &NSStreamStatus) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSStreamStatus {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSStreamStatus {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSStreamStatus {
                #[doc(alias = "NSStreamStatusNotOpen")]
                #[allow(non_upper_case_globals)]
                pub const NotOpen: Self = Self(0);
                #[doc(alias = "NSStreamStatusOpening")]
                #[allow(non_upper_case_globals)]
                pub const Opening: Self = Self(1);
                #[doc(alias = "NSStreamStatusOpen")]
                #[allow(non_upper_case_globals)]
                pub const Open: Self = Self(2);
                #[doc(alias = "NSStreamStatusReading")]
                #[allow(non_upper_case_globals)]
                pub const Reading: Self = Self(3);
                #[doc(alias = "NSStreamStatusWriting")]
                #[allow(non_upper_case_globals)]
                pub const Writing: Self = Self(4);
                #[doc(alias = "NSStreamStatusAtEnd")]
                #[allow(non_upper_case_globals)]
                pub const AtEnd: Self = Self(5);
                #[doc(alias = "NSStreamStatusClosed")]
                #[allow(non_upper_case_globals)]
                pub const Closed: Self = Self(6);
                #[doc(alias = "NSStreamStatusError")]
                #[allow(non_upper_case_globals)]
                pub const Error: Self = Self(7);
            }
            #[repr(transparent)]
            pub struct NSStreamEvent(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSStreamEvent {
                #[inline]
                fn clone(&self) -> NSStreamEvent {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSStreamEvent {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSStreamEvent {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSStreamEvent",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSStreamEvent {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSStreamEvent {
                #[inline]
                fn eq(&self, other: &NSStreamEvent) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSStreamEvent {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSStreamEvent {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSStreamEvent {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSStreamEvent {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSStreamEvent,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSStreamEvent {
                #[inline]
                fn cmp(&self, other: &NSStreamEvent) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSStreamEvent {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSStreamEvent {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSStreamEvent {
                #[doc(alias = "NSStreamEventNone")]
                #[allow(non_upper_case_globals)]
                pub const None: Self = Self(0);
                #[doc(alias = "NSStreamEventOpenCompleted")]
                #[allow(non_upper_case_globals)]
                pub const OpenCompleted: Self = Self(1 << 0);
                #[doc(alias = "NSStreamEventHasBytesAvailable")]
                #[allow(non_upper_case_globals)]
                pub const HasBytesAvailable: Self = Self(1 << 1);
                #[doc(alias = "NSStreamEventHasSpaceAvailable")]
                #[allow(non_upper_case_globals)]
                pub const HasSpaceAvailable: Self = Self(1 << 2);
                #[doc(alias = "NSStreamEventErrorOccurred")]
                #[allow(non_upper_case_globals)]
                pub const ErrorOccurred: Self = Self(1 << 3);
                #[doc(alias = "NSStreamEventEndEncountered")]
                #[allow(non_upper_case_globals)]
                pub const EndEncountered: Self = Self(1 << 4);
            }
            pub unsafe trait NSStreamDelegate: NSObjectProtocol {}
            unsafe impl<T> NSStreamDelegate for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSStreamDelegate,
            {}
            unsafe impl ProtocolType for dyn NSStreamDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSStreamDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T> for dyn NSStreamDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSStreamDelegate,
            {
                const __INNER: () = ();
            }
            extern "C" {
                pub static NSStreamSocketSecurityLevelKey: &'static NSStreamPropertyKey;
            }
            pub type NSStreamSocketSecurityLevel = NSString;
            extern "C" {
                pub static NSStreamSocketSecurityLevelNone: &'static NSStreamSocketSecurityLevel;
            }
            extern "C" {
                pub static NSStreamSocketSecurityLevelSSLv2: &'static NSStreamSocketSecurityLevel;
            }
            extern "C" {
                pub static NSStreamSocketSecurityLevelSSLv3: &'static NSStreamSocketSecurityLevel;
            }
            extern "C" {
                pub static NSStreamSocketSecurityLevelTLSv1: &'static NSStreamSocketSecurityLevel;
            }
            extern "C" {
                pub static NSStreamSocketSecurityLevelNegotiatedSSL: &'static NSStreamSocketSecurityLevel;
            }
            extern "C" {
                pub static NSStreamSOCKSProxyConfigurationKey: &'static NSStreamPropertyKey;
            }
            pub type NSStreamSOCKSProxyConfiguration = NSString;
            extern "C" {
                pub static NSStreamSOCKSProxyHostKey: &'static NSStreamSOCKSProxyConfiguration;
            }
            extern "C" {
                pub static NSStreamSOCKSProxyPortKey: &'static NSStreamSOCKSProxyConfiguration;
            }
            extern "C" {
                pub static NSStreamSOCKSProxyVersionKey: &'static NSStreamSOCKSProxyConfiguration;
            }
            extern "C" {
                pub static NSStreamSOCKSProxyUserKey: &'static NSStreamSOCKSProxyConfiguration;
            }
            extern "C" {
                pub static NSStreamSOCKSProxyPasswordKey: &'static NSStreamSOCKSProxyConfiguration;
            }
            pub type NSStreamSOCKSProxyVersion = NSString;
            extern "C" {
                pub static NSStreamSOCKSProxyVersion4: &'static NSStreamSOCKSProxyVersion;
            }
            extern "C" {
                pub static NSStreamSOCKSProxyVersion5: &'static NSStreamSOCKSProxyVersion;
            }
            extern "C" {
                pub static NSStreamDataWrittenToMemoryStreamKey: &'static NSStreamPropertyKey;
            }
            extern "C" {
                pub static NSStreamFileCurrentOffsetKey: &'static NSStreamPropertyKey;
            }
            extern "C" {
                pub static NSStreamSocketSSLErrorDomain: &'static NSErrorDomain;
            }
            extern "C" {
                pub static NSStreamSOCKSErrorDomain: &'static NSErrorDomain;
            }
            extern "C" {
                pub static NSStreamNetworkServiceType: &'static NSStreamPropertyKey;
            }
            pub type NSStreamNetworkServiceTypeValue = NSString;
            extern "C" {
                pub static NSStreamNetworkServiceTypeVoIP: &'static NSStreamNetworkServiceTypeValue;
            }
            extern "C" {
                pub static NSStreamNetworkServiceTypeVideo: &'static NSStreamNetworkServiceTypeValue;
            }
            extern "C" {
                pub static NSStreamNetworkServiceTypeBackground: &'static NSStreamNetworkServiceTypeValue;
            }
            extern "C" {
                pub static NSStreamNetworkServiceTypeVoice: &'static NSStreamNetworkServiceTypeValue;
            }
            extern "C" {
                pub static NSStreamNetworkServiceTypeCallSignaling: &'static NSStreamNetworkServiceTypeValue;
            }
        }
        #[path = "NSString.rs"]
        mod __NSString {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub type unichar = c_ushort;
            #[repr(transparent)]
            pub struct NSStringCompareOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSStringCompareOptions {
                #[inline]
                fn clone(&self) -> NSStringCompareOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSStringCompareOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSStringCompareOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSStringCompareOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSStringCompareOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSStringCompareOptions {
                #[inline]
                fn eq(&self, other: &NSStringCompareOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSStringCompareOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSStringCompareOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSStringCompareOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSStringCompareOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSStringCompareOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSStringCompareOptions {
                #[inline]
                fn cmp(&self, other: &NSStringCompareOptions) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSStringCompareOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSStringCompareOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSStringCompareOptions {
                #[allow(non_upper_case_globals)]
                pub const NSCaseInsensitiveSearch: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSLiteralSearch: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSBackwardsSearch: Self = Self(4);
                #[allow(non_upper_case_globals)]
                pub const NSAnchoredSearch: Self = Self(8);
                #[allow(non_upper_case_globals)]
                pub const NSNumericSearch: Self = Self(64);
                #[allow(non_upper_case_globals)]
                pub const NSDiacriticInsensitiveSearch: Self = Self(128);
                #[allow(non_upper_case_globals)]
                pub const NSWidthInsensitiveSearch: Self = Self(256);
                #[allow(non_upper_case_globals)]
                pub const NSForcedOrderingSearch: Self = Self(512);
                #[allow(non_upper_case_globals)]
                pub const NSRegularExpressionSearch: Self = Self(1024);
            }
            pub type NSStringEncoding = NSUInteger;
            pub const NSASCIIStringEncoding: NSStringEncoding = 1;
            pub const NSNEXTSTEPStringEncoding: NSStringEncoding = 2;
            pub const NSJapaneseEUCStringEncoding: NSStringEncoding = 3;
            pub const NSUTF8StringEncoding: NSStringEncoding = 4;
            pub const NSISOLatin1StringEncoding: NSStringEncoding = 5;
            pub const NSSymbolStringEncoding: NSStringEncoding = 6;
            pub const NSNonLossyASCIIStringEncoding: NSStringEncoding = 7;
            pub const NSShiftJISStringEncoding: NSStringEncoding = 8;
            pub const NSISOLatin2StringEncoding: NSStringEncoding = 9;
            pub const NSUnicodeStringEncoding: NSStringEncoding = 10;
            pub const NSWindowsCP1251StringEncoding: NSStringEncoding = 11;
            pub const NSWindowsCP1252StringEncoding: NSStringEncoding = 12;
            pub const NSWindowsCP1253StringEncoding: NSStringEncoding = 13;
            pub const NSWindowsCP1254StringEncoding: NSStringEncoding = 14;
            pub const NSWindowsCP1250StringEncoding: NSStringEncoding = 15;
            pub const NSISO2022JPStringEncoding: NSStringEncoding = 21;
            pub const NSMacOSRomanStringEncoding: NSStringEncoding = 30;
            pub const NSUTF16StringEncoding: NSStringEncoding = NSUnicodeStringEncoding;
            pub const NSUTF16BigEndianStringEncoding: NSStringEncoding = 0x90000100;
            pub const NSUTF16LittleEndianStringEncoding: NSStringEncoding = 0x94000100;
            pub const NSUTF32StringEncoding: NSStringEncoding = 0x8c000100;
            pub const NSUTF32BigEndianStringEncoding: NSStringEncoding = 0x98000100;
            pub const NSUTF32LittleEndianStringEncoding: NSStringEncoding = 0x9c000100;
            #[repr(transparent)]
            pub struct NSStringEncodingConversionOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSStringEncodingConversionOptions {
                #[inline]
                fn clone(&self) -> NSStringEncodingConversionOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSStringEncodingConversionOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSStringEncodingConversionOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSStringEncodingConversionOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSStringEncodingConversionOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSStringEncodingConversionOptions {
                #[inline]
                fn eq(&self, other: &NSStringEncodingConversionOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSStringEncodingConversionOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSStringEncodingConversionOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSStringEncodingConversionOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSStringEncodingConversionOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSStringEncodingConversionOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSStringEncodingConversionOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSStringEncodingConversionOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSStringEncodingConversionOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSStringEncodingConversionOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSStringEncodingConversionOptions {
                #[allow(non_upper_case_globals)]
                pub const NSStringEncodingConversionAllowLossy: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSStringEncodingConversionExternalRepresentation: Self = Self(
                    2,
                );
            }
            #[cfg(feature = "Foundation_NSString")]
            #[repr(C)]
            pub struct NSString {
                __superclass: NSObject,
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSString {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSString {
                #[inline]
                fn eq(&self, other: &NSString) -> bool {
                    self.__superclass == other.__superclass
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSString {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSString {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSObject>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSString {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.__superclass, state)
                }
            }
            #[cfg(feature = "Foundation_NSString")]
            unsafe impl ::objc2::RefEncode for NSString {
                const ENCODING_REF: ::objc2::Encoding = <NSObject as ::objc2::RefEncode>::ENCODING_REF;
            }
            #[cfg(feature = "Foundation_NSString")]
            unsafe impl ::objc2::Message for NSString {}
            #[cfg(feature = "Foundation_NSString")]
            impl ::objc2::__macro_helpers::Deref for NSString {
                type Target = NSObject;
                #[inline]
                fn deref(&self) -> &Self::Target {
                    &self.__superclass
                }
            }
            #[cfg(feature = "Foundation_NSString")]
            impl ::objc2::__macro_helpers::DerefMut for NSString {
                #[inline]
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.__superclass
                }
            }
            #[cfg(feature = "Foundation_NSString")]
            impl ::objc2::__macro_helpers::AsRef<Self> for NSString {
                #[inline]
                fn as_ref(&self) -> &Self {
                    self
                }
            }
            #[cfg(feature = "Foundation_NSString")]
            impl ::objc2::__macro_helpers::AsMut<Self> for NSString {
                #[inline]
                fn as_mut(&mut self) -> &mut Self {
                    self
                }
            }
            impl ::objc2::__macro_helpers::AsRef<NSObject> for NSString {
                #[inline]
                fn as_ref(&self) -> &NSObject {
                    &*self
                }
            }
            impl ::objc2::__macro_helpers::AsMut<NSObject> for NSString {
                #[inline]
                fn as_mut(&mut self) -> &mut NSObject {
                    &mut *self
                }
            }
            impl ::objc2::__macro_helpers::Borrow<NSObject> for NSString {
                #[inline]
                fn borrow(&self) -> &NSObject {
                    &*self
                }
            }
            impl ::objc2::__macro_helpers::BorrowMut<NSObject> for NSString {
                #[inline]
                fn borrow_mut(&mut self) -> &mut NSObject {
                    &mut *self
                }
            }
            impl ::objc2::__macro_helpers::AsRef<::objc2::runtime::AnyObject>
            for NSString {
                #[inline]
                fn as_ref(&self) -> &::objc2::runtime::AnyObject {
                    &*self
                }
            }
            impl ::objc2::__macro_helpers::AsMut<::objc2::runtime::AnyObject>
            for NSString {
                #[inline]
                fn as_mut(&mut self) -> &mut ::objc2::runtime::AnyObject {
                    &mut *self
                }
            }
            impl ::objc2::__macro_helpers::Borrow<::objc2::runtime::AnyObject>
            for NSString {
                #[inline]
                fn borrow(&self) -> &::objc2::runtime::AnyObject {
                    &*self
                }
            }
            impl ::objc2::__macro_helpers::BorrowMut<::objc2::runtime::AnyObject>
            for NSString {
                #[inline]
                fn borrow_mut(&mut self) -> &mut ::objc2::runtime::AnyObject {
                    &mut *self
                }
            }
            #[cfg(feature = "Foundation_NSString")]
            unsafe impl ClassType for NSString {
                type Super = NSObject;
                type Mutability = ImmutableWithMutableSubclass<NSMutableString>;
                const NAME: &'static ::objc2::__macro_helpers::str = "NSString";
                #[inline]
                fn class() -> &'static ::objc2::runtime::AnyClass {
                    ::objc2::__macro_helpers::assert_mutability_matches_superclass_mutability::<
                        Self,
                    >();
                    {
                        static CACHED_CLASS: ::objc2::__macro_helpers::CachedClass = ::objc2::__macro_helpers::CachedClass::new();
                        #[allow(unused_unsafe)]
                        unsafe { CACHED_CLASS.get("NSString\u{0}") }
                    }
                }
                #[inline]
                fn as_super(&self) -> &Self::Super {
                    &self.__superclass
                }
                #[inline]
                fn as_super_mut(&mut self) -> &mut Self::Super {
                    &mut self.__superclass
                }
            }
            #[cfg(feature = "Foundation_NSString")]
            const _: () = {
                if ::objc2::__macro_helpers::size_of::<NSString>() != 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("the struct NSString is not zero-sized!"),
                        );
                    }
                }
            };
            #[cfg(feature = "Foundation_NSString")]
            unsafe impl NSCoding for NSString {}
            #[cfg(feature = "Foundation_NSString")]
            unsafe impl NSCopying for NSString {}
            #[cfg(feature = "Foundation_NSString")]
            unsafe impl NSMutableCopying for NSString {}
            #[cfg(feature = "Foundation_NSString")]
            unsafe impl NSObjectProtocol for NSString {}
            #[cfg(feature = "Foundation_NSString")]
            unsafe impl NSSecureCoding for NSString {}
            #[cfg(feature = "Foundation_NSString")]
            impl NSString {
                pub fn length(&self) -> NSUInteger {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("length\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn characterAtIndex(&self, index: NSUInteger) -> unichar {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("characterAtIndex:\u{0}") }
                                    }
                                },
                                (index,),
                            );
                            result
                        }
                    }
                }
                pub fn init(this: Allocated<Self>) -> Id<Self> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Init as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                this,
                                { ::objc2::__macro_helpers::init_sel() },
                                (),
                            )
                        }
                    }
                }
            }
            /// Methods declared on superclass `NSObject`
            #[cfg(feature = "Foundation_NSString")]
            impl NSString {
                pub fn new() -> Id<Self> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::New as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                <Self as ::objc2::ClassType>::class(),
                                { ::objc2::__macro_helpers::new_sel() },
                                (),
                            )
                        }
                    }
                }
            }
            #[cfg(feature = "Foundation_NSString")]
            impl DefaultId for NSString {
                #[inline]
                fn default_id() -> Id<Self> {
                    Self::new()
                }
            }
            #[repr(transparent)]
            pub struct NSStringEnumerationOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSStringEnumerationOptions {
                #[inline]
                fn clone(&self) -> NSStringEnumerationOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSStringEnumerationOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSStringEnumerationOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSStringEnumerationOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSStringEnumerationOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSStringEnumerationOptions {
                #[inline]
                fn eq(&self, other: &NSStringEnumerationOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSStringEnumerationOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSStringEnumerationOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSStringEnumerationOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSStringEnumerationOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSStringEnumerationOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSStringEnumerationOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSStringEnumerationOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSStringEnumerationOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSStringEnumerationOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSStringEnumerationOptions {
                #[allow(non_upper_case_globals)]
                pub const NSStringEnumerationByLines: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSStringEnumerationByParagraphs: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSStringEnumerationByComposedCharacterSequences: Self = Self(
                    2,
                );
                #[allow(non_upper_case_globals)]
                pub const NSStringEnumerationByWords: Self = Self(3);
                #[allow(non_upper_case_globals)]
                pub const NSStringEnumerationBySentences: Self = Self(4);
                #[allow(non_upper_case_globals)]
                pub const NSStringEnumerationByCaretPositions: Self = Self(5);
                #[allow(non_upper_case_globals)]
                pub const NSStringEnumerationByDeletionClusters: Self = Self(6);
                #[allow(non_upper_case_globals)]
                pub const NSStringEnumerationReverse: Self = Self(1 << 8);
                #[allow(non_upper_case_globals)]
                pub const NSStringEnumerationSubstringNotRequired: Self = Self(1 << 9);
                #[allow(non_upper_case_globals)]
                pub const NSStringEnumerationLocalized: Self = Self(1 << 10);
            }
            pub type NSStringTransform = NSString;
            extern "C" {
                pub static NSStringTransformLatinToKatakana: &'static NSStringTransform;
            }
            extern "C" {
                pub static NSStringTransformLatinToHiragana: &'static NSStringTransform;
            }
            extern "C" {
                pub static NSStringTransformLatinToHangul: &'static NSStringTransform;
            }
            extern "C" {
                pub static NSStringTransformLatinToArabic: &'static NSStringTransform;
            }
            extern "C" {
                pub static NSStringTransformLatinToHebrew: &'static NSStringTransform;
            }
            extern "C" {
                pub static NSStringTransformLatinToThai: &'static NSStringTransform;
            }
            extern "C" {
                pub static NSStringTransformLatinToCyrillic: &'static NSStringTransform;
            }
            extern "C" {
                pub static NSStringTransformLatinToGreek: &'static NSStringTransform;
            }
            extern "C" {
                pub static NSStringTransformToLatin: &'static NSStringTransform;
            }
            extern "C" {
                pub static NSStringTransformMandarinToLatin: &'static NSStringTransform;
            }
            extern "C" {
                pub static NSStringTransformHiraganaToKatakana: &'static NSStringTransform;
            }
            extern "C" {
                pub static NSStringTransformFullwidthToHalfwidth: &'static NSStringTransform;
            }
            extern "C" {
                pub static NSStringTransformToXMLHex: &'static NSStringTransform;
            }
            extern "C" {
                pub static NSStringTransformToUnicodeName: &'static NSStringTransform;
            }
            extern "C" {
                pub static NSStringTransformStripCombiningMarks: &'static NSStringTransform;
            }
            extern "C" {
                pub static NSStringTransformStripDiacritics: &'static NSStringTransform;
            }
            /// NSStringExtensionMethods
            #[cfg(feature = "Foundation_NSString")]
            impl NSString {
                pub unsafe fn substringFromIndex(
                    &self,
                    from: NSUInteger,
                ) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("substringFromIndex:\u{0}") }
                                    }
                                },
                                (from,),
                            )
                        }
                    }
                }
                pub unsafe fn substringToIndex(&self, to: NSUInteger) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("substringToIndex:\u{0}") }
                                    }
                                },
                                (to,),
                            )
                        }
                    }
                }
                pub unsafe fn substringWithRange(&self, range: NSRange) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("substringWithRange:\u{0}") }
                                    }
                                },
                                (range,),
                            )
                        }
                    }
                }
                pub unsafe fn getCharacters_range(
                    &self,
                    buffer: NonNull<unichar>,
                    range: NSRange,
                ) {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("getCharacters:range:\u{0}") }
                                    }
                                },
                                (buffer, range),
                            );
                            result
                        }
                    }
                }
                pub fn compare(&self, string: &NSString) -> NSComparisonResult {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("compare:\u{0}") }
                                    }
                                },
                                (string,),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn compare_options(
                    &self,
                    string: &NSString,
                    mask: NSStringCompareOptions,
                ) -> NSComparisonResult {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("compare:options:\u{0}") }
                                    }
                                },
                                (string, mask),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn compare_options_range(
                    &self,
                    string: &NSString,
                    mask: NSStringCompareOptions,
                    range_of_receiver_to_compare: NSRange,
                ) -> NSComparisonResult {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("compare:options:range:\u{0}") }
                                    }
                                },
                                (string, mask, range_of_receiver_to_compare),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn compare_options_range_locale(
                    &self,
                    string: &NSString,
                    mask: NSStringCompareOptions,
                    range_of_receiver_to_compare: NSRange,
                    locale: Option<&AnyObject>,
                ) -> NSComparisonResult {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("compare:options:range:locale:\u{0}")
                                        }
                                    }
                                },
                                (string, mask, range_of_receiver_to_compare, locale),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn caseInsensitiveCompare(
                    &self,
                    string: &NSString,
                ) -> NSComparisonResult {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("caseInsensitiveCompare:\u{0}") }
                                    }
                                },
                                (string,),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn localizedCompare(
                    &self,
                    string: &NSString,
                ) -> NSComparisonResult {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("localizedCompare:\u{0}") }
                                    }
                                },
                                (string,),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn localizedCaseInsensitiveCompare(
                    &self,
                    string: &NSString,
                ) -> NSComparisonResult {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("localizedCaseInsensitiveCompare:\u{0}")
                                        }
                                    }
                                },
                                (string,),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn localizedStandardCompare(
                    &self,
                    string: &NSString,
                ) -> NSComparisonResult {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("localizedStandardCompare:\u{0}") }
                                    }
                                },
                                (string,),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn isEqualToString(&self, a_string: &NSString) -> bool {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("isEqualToString:\u{0}") }
                                    }
                                },
                                (a_string,),
                            );
                            result
                        }
                    }
                }
                pub fn hasPrefix(&self, str: &NSString) -> bool {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("hasPrefix:\u{0}") }
                                    }
                                },
                                (str,),
                            );
                            result
                        }
                    }
                }
                pub fn hasSuffix(&self, str: &NSString) -> bool {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("hasSuffix:\u{0}") }
                                    }
                                },
                                (str,),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn commonPrefixWithString_options(
                    &self,
                    str: &NSString,
                    mask: NSStringCompareOptions,
                ) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("commonPrefixWithString:options:\u{0}")
                                        }
                                    }
                                },
                                (str, mask),
                            )
                        }
                    }
                }
                pub unsafe fn containsString(&self, str: &NSString) -> bool {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("containsString:\u{0}") }
                                    }
                                },
                                (str,),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn localizedCaseInsensitiveContainsString(
                    &self,
                    str: &NSString,
                ) -> bool {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("localizedCaseInsensitiveContainsString:\u{0}")
                                        }
                                    }
                                },
                                (str,),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn localizedStandardContainsString(
                    &self,
                    str: &NSString,
                ) -> bool {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("localizedStandardContainsString:\u{0}")
                                        }
                                    }
                                },
                                (str,),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn localizedStandardRangeOfString(
                    &self,
                    str: &NSString,
                ) -> NSRange {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("localizedStandardRangeOfString:\u{0}")
                                        }
                                    }
                                },
                                (str,),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn rangeOfString(&self, search_string: &NSString) -> NSRange {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("rangeOfString:\u{0}") }
                                    }
                                },
                                (search_string,),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn rangeOfString_options(
                    &self,
                    search_string: &NSString,
                    mask: NSStringCompareOptions,
                ) -> NSRange {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("rangeOfString:options:\u{0}") }
                                    }
                                },
                                (search_string, mask),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn rangeOfString_options_range(
                    &self,
                    search_string: &NSString,
                    mask: NSStringCompareOptions,
                    range_of_receiver_to_search: NSRange,
                ) -> NSRange {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("rangeOfString:options:range:\u{0}")
                                        }
                                    }
                                },
                                (search_string, mask, range_of_receiver_to_search),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn rangeOfComposedCharacterSequenceAtIndex(
                    &self,
                    index: NSUInteger,
                ) -> NSRange {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("rangeOfComposedCharacterSequenceAtIndex:\u{0}")
                                        }
                                    }
                                },
                                (index,),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn rangeOfComposedCharacterSequencesForRange(
                    &self,
                    range: NSRange,
                ) -> NSRange {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("rangeOfComposedCharacterSequencesForRange:\u{0}")
                                        }
                                    }
                                },
                                (range,),
                            );
                            result
                        }
                    }
                }
                pub fn stringByAppendingString(
                    &self,
                    a_string: &NSString,
                ) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("stringByAppendingString:\u{0}") }
                                    }
                                },
                                (a_string,),
                            )
                        }
                    }
                }
                pub unsafe fn doubleValue(&self) -> c_double {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("doubleValue\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn floatValue(&self) -> c_float {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("floatValue\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn intValue(&self) -> c_int {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("intValue\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn integerValue(&self) -> NSInteger {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("integerValue\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn longLongValue(&self) -> c_longlong {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("longLongValue\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn boolValue(&self) -> bool {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("boolValue\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn uppercaseString(&self) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("uppercaseString\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn lowercaseString(&self) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("lowercaseString\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn capitalizedString(&self) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("capitalizedString\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn localizedUppercaseString(&self) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("localizedUppercaseString\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn localizedLowercaseString(&self) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("localizedLowercaseString\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn localizedCapitalizedString(&self) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("localizedCapitalizedString\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn getLineStart_end_contentsEnd_forRange(
                    &self,
                    start_ptr: *mut NSUInteger,
                    line_end_ptr: *mut NSUInteger,
                    contents_end_ptr: *mut NSUInteger,
                    range: NSRange,
                ) {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("getLineStart:end:contentsEnd:forRange:\u{0}")
                                        }
                                    }
                                },
                                (start_ptr, line_end_ptr, contents_end_ptr, range),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn lineRangeForRange(&self, range: NSRange) -> NSRange {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("lineRangeForRange:\u{0}") }
                                    }
                                },
                                (range,),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn getParagraphStart_end_contentsEnd_forRange(
                    &self,
                    start_ptr: *mut NSUInteger,
                    par_end_ptr: *mut NSUInteger,
                    contents_end_ptr: *mut NSUInteger,
                    range: NSRange,
                ) {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("getParagraphStart:end:contentsEnd:forRange:\u{0}")
                                        }
                                    }
                                },
                                (start_ptr, par_end_ptr, contents_end_ptr, range),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn paragraphRangeForRange(&self, range: NSRange) -> NSRange {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("paragraphRangeForRange:\u{0}") }
                                    }
                                },
                                (range,),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn enumerateSubstringsInRange_options_usingBlock(
                    &self,
                    range: NSRange,
                    opts: NSStringEnumerationOptions,
                    block: &Block<dyn Fn(*mut NSString, NSRange, NSRange, NonNull<Bool>)>,
                ) {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("enumerateSubstringsInRange:options:usingBlock:\u{0}")
                                        }
                                    }
                                },
                                (range, opts, block),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn enumerateLinesUsingBlock(
                    &self,
                    block: &Block<dyn Fn(NonNull<NSString>, NonNull<Bool>)>,
                ) {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("enumerateLinesUsingBlock:\u{0}") }
                                    }
                                },
                                (block,),
                            );
                            result
                        }
                    }
                }
                pub fn UTF8String(&self) -> *mut c_char {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("UTF8String\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn fastestEncoding(&self) -> NSStringEncoding {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("fastestEncoding\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn smallestEncoding(&self) -> NSStringEncoding {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("smallestEncoding\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn canBeConvertedToEncoding(
                    &self,
                    encoding: NSStringEncoding,
                ) -> bool {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("canBeConvertedToEncoding:\u{0}") }
                                    }
                                },
                                (encoding,),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn cStringUsingEncoding(
                    &self,
                    encoding: NSStringEncoding,
                ) -> *mut c_char {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("cStringUsingEncoding:\u{0}") }
                                    }
                                },
                                (encoding,),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn getCString_maxLength_encoding(
                    &self,
                    buffer: NonNull<c_char>,
                    max_buffer_count: NSUInteger,
                    encoding: NSStringEncoding,
                ) -> bool {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("getCString:maxLength:encoding:\u{0}")
                                        }
                                    }
                                },
                                (buffer, max_buffer_count, encoding),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn getBytes_maxLength_usedLength_encoding_options_range_remainingRange(
                    &self,
                    buffer: *mut c_void,
                    max_buffer_count: NSUInteger,
                    used_buffer_count: *mut NSUInteger,
                    encoding: NSStringEncoding,
                    options: NSStringEncodingConversionOptions,
                    range: NSRange,
                    leftover: NSRangePointer,
                ) -> bool {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get(
                                                    "getBytes:maxLength:usedLength:encoding:options:range:remainingRange:\u{0}",
                                                )
                                        }
                                    }
                                },
                                (
                                    buffer,
                                    max_buffer_count,
                                    used_buffer_count,
                                    encoding,
                                    options,
                                    range,
                                    leftover,
                                ),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn maximumLengthOfBytesUsingEncoding(
                    &self,
                    enc: NSStringEncoding,
                ) -> NSUInteger {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("maximumLengthOfBytesUsingEncoding:\u{0}")
                                        }
                                    }
                                },
                                (enc,),
                            );
                            result
                        }
                    }
                }
                pub fn lengthOfBytesUsingEncoding(
                    &self,
                    enc: NSStringEncoding,
                ) -> NSUInteger {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("lengthOfBytesUsingEncoding:\u{0}")
                                        }
                                    }
                                },
                                (enc,),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn availableStringEncodings() -> NonNull<NSStringEncoding> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("availableStringEncodings\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn localizedNameOfStringEncoding(
                    encoding: NSStringEncoding,
                ) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("localizedNameOfStringEncoding:\u{0}")
                                        }
                                    }
                                },
                                (encoding,),
                            )
                        }
                    }
                }
                pub unsafe fn defaultCStringEncoding() -> NSStringEncoding {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("defaultCStringEncoding\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn decomposedStringWithCanonicalMapping(
                    &self,
                ) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("decomposedStringWithCanonicalMapping\u{0}")
                                        }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn precomposedStringWithCanonicalMapping(
                    &self,
                ) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("precomposedStringWithCanonicalMapping\u{0}")
                                        }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn decomposedStringWithCompatibilityMapping(
                    &self,
                ) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("decomposedStringWithCompatibilityMapping\u{0}")
                                        }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn precomposedStringWithCompatibilityMapping(
                    &self,
                ) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("precomposedStringWithCompatibilityMapping\u{0}")
                                        }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn stringByPaddingToLength_withString_startingAtIndex(
                    &self,
                    new_length: NSUInteger,
                    pad_string: &NSString,
                    pad_index: NSUInteger,
                ) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get(
                                                    "stringByPaddingToLength:withString:startingAtIndex:\u{0}",
                                                )
                                        }
                                    }
                                },
                                (new_length, pad_string, pad_index),
                            )
                        }
                    }
                }
                pub unsafe fn stringByReplacingOccurrencesOfString_withString_options_range(
                    &self,
                    target: &NSString,
                    replacement: &NSString,
                    options: NSStringCompareOptions,
                    search_range: NSRange,
                ) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get(
                                                    "stringByReplacingOccurrencesOfString:withString:options:range:\u{0}",
                                                )
                                        }
                                    }
                                },
                                (target, replacement, options, search_range),
                            )
                        }
                    }
                }
                pub unsafe fn stringByReplacingOccurrencesOfString_withString(
                    &self,
                    target: &NSString,
                    replacement: &NSString,
                ) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get(
                                                    "stringByReplacingOccurrencesOfString:withString:\u{0}",
                                                )
                                        }
                                    }
                                },
                                (target, replacement),
                            )
                        }
                    }
                }
                pub unsafe fn stringByReplacingCharactersInRange_withString(
                    &self,
                    range: NSRange,
                    replacement: &NSString,
                ) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("stringByReplacingCharactersInRange:withString:\u{0}")
                                        }
                                    }
                                },
                                (range, replacement),
                            )
                        }
                    }
                }
                pub unsafe fn stringByApplyingTransform_reverse(
                    &self,
                    transform: &NSStringTransform,
                    reverse: bool,
                ) -> Option<Id<NSString>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("stringByApplyingTransform:reverse:\u{0}")
                                        }
                                    }
                                },
                                (transform, reverse),
                            )
                        }
                    }
                }
                pub unsafe fn description(&self) -> Id<NSString> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("description\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub unsafe fn hash(&self) -> NSUInteger {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("hash\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                pub unsafe fn initWithCharactersNoCopy_length_freeWhenDone(
                    this: Allocated<Self>,
                    characters: NonNull<unichar>,
                    length: NSUInteger,
                    free_buffer: bool,
                ) -> Id<Self> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Init as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                this,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("initWithCharactersNoCopy:length:freeWhenDone:\u{0}")
                                        }
                                    }
                                },
                                (characters, length, free_buffer),
                            )
                        }
                    }
                }
                pub unsafe fn initWithCharactersNoCopy_length_deallocator(
                    this: Allocated<Self>,
                    chars: NonNull<unichar>,
                    len: NSUInteger,
                    deallocator: Option<&Block<dyn Fn(NonNull<unichar>, NSUInteger)>>,
                ) -> Id<Self> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Init as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                this,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("initWithCharactersNoCopy:length:deallocator:\u{0}")
                                        }
                                    }
                                },
                                (chars, len, deallocator),
                            )
                        }
                    }
                }
                pub unsafe fn initWithCharacters_length(
                    this: Allocated<Self>,
                    characters: NonNull<unichar>,
                    length: NSUInteger,
                ) -> Id<Self> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Init as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                this,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("initWithCharacters:length:\u{0}") }
                                    }
                                },
                                (characters, length),
                            )
                        }
                    }
                }
                pub unsafe fn initWithUTF8String(
                    this: Allocated<Self>,
                    null_terminated_c_string: NonNull<c_char>,
                ) -> Option<Id<Self>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Init as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                this,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("initWithUTF8String:\u{0}") }
                                    }
                                },
                                (null_terminated_c_string,),
                            )
                        }
                    }
                }
                pub fn initWithString(
                    this: Allocated<Self>,
                    a_string: &NSString,
                ) -> Id<Self> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Init as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                this,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("initWithString:\u{0}") }
                                    }
                                },
                                (a_string,),
                            )
                        }
                    }
                }
                pub unsafe fn initWithBytes_length_encoding(
                    this: Allocated<Self>,
                    bytes: NonNull<c_void>,
                    len: NSUInteger,
                    encoding: NSStringEncoding,
                ) -> Option<Id<Self>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Init as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                this,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("initWithBytes:length:encoding:\u{0}")
                                        }
                                    }
                                },
                                (bytes, len, encoding),
                            )
                        }
                    }
                }
                pub unsafe fn initWithBytesNoCopy_length_encoding_freeWhenDone(
                    this: Allocated<Self>,
                    bytes: NonNull<c_void>,
                    len: NSUInteger,
                    encoding: NSStringEncoding,
                    free_buffer: bool,
                ) -> Option<Id<Self>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Init as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                this,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get(
                                                    "initWithBytesNoCopy:length:encoding:freeWhenDone:\u{0}",
                                                )
                                        }
                                    }
                                },
                                (bytes, len, encoding, free_buffer),
                            )
                        }
                    }
                }
                pub unsafe fn initWithBytesNoCopy_length_encoding_deallocator(
                    this: Allocated<Self>,
                    bytes: NonNull<c_void>,
                    len: NSUInteger,
                    encoding: NSStringEncoding,
                    deallocator: Option<&Block<dyn Fn(NonNull<c_void>, NSUInteger)>>,
                ) -> Option<Id<Self>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Init as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                this,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get(
                                                    "initWithBytesNoCopy:length:encoding:deallocator:\u{0}",
                                                )
                                        }
                                    }
                                },
                                (bytes, len, encoding, deallocator),
                            )
                        }
                    }
                }
                pub unsafe fn string() -> Id<Self> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("string\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                pub fn stringWithString(string: &NSString) -> Id<Self> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("stringWithString:\u{0}") }
                                    }
                                },
                                (string,),
                            )
                        }
                    }
                }
                pub unsafe fn stringWithCharacters_length(
                    characters: NonNull<unichar>,
                    length: NSUInteger,
                ) -> Id<Self> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("stringWithCharacters:length:\u{0}")
                                        }
                                    }
                                },
                                (characters, length),
                            )
                        }
                    }
                }
                pub unsafe fn stringWithUTF8String(
                    null_terminated_c_string: NonNull<c_char>,
                ) -> Option<Id<Self>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("stringWithUTF8String:\u{0}") }
                                    }
                                },
                                (null_terminated_c_string,),
                            )
                        }
                    }
                }
                pub unsafe fn initWithCString_encoding(
                    this: Allocated<Self>,
                    null_terminated_c_string: NonNull<c_char>,
                    encoding: NSStringEncoding,
                ) -> Option<Id<Self>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Init as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                this,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("initWithCString:encoding:\u{0}") }
                                    }
                                },
                                (null_terminated_c_string, encoding),
                            )
                        }
                    }
                }
                pub unsafe fn stringWithCString_encoding(
                    c_string: NonNull<c_char>,
                    enc: NSStringEncoding,
                ) -> Option<Id<Self>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("stringWithCString:encoding:\u{0}")
                                        }
                                    }
                                },
                                (c_string, enc),
                            )
                        }
                    }
                }
            }
            pub type NSStringEncodingDetectionOptionsKey = NSString;
            extern "C" {
                pub static NSStringEncodingDetectionSuggestedEncodingsKey: &'static NSStringEncodingDetectionOptionsKey;
            }
            extern "C" {
                pub static NSStringEncodingDetectionDisallowedEncodingsKey: &'static NSStringEncodingDetectionOptionsKey;
            }
            extern "C" {
                pub static NSStringEncodingDetectionUseOnlySuggestedEncodingsKey: &'static NSStringEncodingDetectionOptionsKey;
            }
            extern "C" {
                pub static NSStringEncodingDetectionAllowLossyKey: &'static NSStringEncodingDetectionOptionsKey;
            }
            extern "C" {
                pub static NSStringEncodingDetectionFromWindowsKey: &'static NSStringEncodingDetectionOptionsKey;
            }
            extern "C" {
                pub static NSStringEncodingDetectionLossySubstitutionKey: &'static NSStringEncodingDetectionOptionsKey;
            }
            extern "C" {
                pub static NSStringEncodingDetectionLikelyLanguageKey: &'static NSStringEncodingDetectionOptionsKey;
            }
            /// NSStringEncodingDetection
            #[cfg(feature = "Foundation_NSString")]
            impl NSString {}
            /// NSItemProvider
            #[cfg(feature = "Foundation_NSString")]
            impl NSString {}
            #[cfg(feature = "Foundation_NSString")]
            unsafe impl NSItemProviderReading for NSString {}
            #[cfg(feature = "Foundation_NSString")]
            unsafe impl NSItemProviderWriting for NSString {}
            #[cfg(feature = "Foundation_NSString")]
            #[repr(C)]
            pub struct NSMutableString {
                __superclass: NSString,
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSMutableString {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSMutableString {
                #[inline]
                fn eq(&self, other: &NSMutableString) -> bool {
                    self.__superclass == other.__superclass
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSMutableString {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSMutableString {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSString>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSMutableString {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.__superclass, state)
                }
            }
            #[cfg(feature = "Foundation_NSString")]
            unsafe impl ::objc2::RefEncode for NSMutableString {
                const ENCODING_REF: ::objc2::Encoding = <NSString as ::objc2::RefEncode>::ENCODING_REF;
            }
            #[cfg(feature = "Foundation_NSString")]
            unsafe impl ::objc2::Message for NSMutableString {}
            #[cfg(feature = "Foundation_NSString")]
            impl ::objc2::__macro_helpers::Deref for NSMutableString {
                type Target = NSString;
                #[inline]
                fn deref(&self) -> &Self::Target {
                    &self.__superclass
                }
            }
            #[cfg(feature = "Foundation_NSString")]
            impl ::objc2::__macro_helpers::DerefMut for NSMutableString {
                #[inline]
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.__superclass
                }
            }
            #[cfg(feature = "Foundation_NSString")]
            impl ::objc2::__macro_helpers::AsRef<Self> for NSMutableString {
                #[inline]
                fn as_ref(&self) -> &Self {
                    self
                }
            }
            #[cfg(feature = "Foundation_NSString")]
            impl ::objc2::__macro_helpers::AsMut<Self> for NSMutableString {
                #[inline]
                fn as_mut(&mut self) -> &mut Self {
                    self
                }
            }
            impl ::objc2::__macro_helpers::AsRef<NSString> for NSMutableString {
                #[inline]
                fn as_ref(&self) -> &NSString {
                    &*self
                }
            }
            impl ::objc2::__macro_helpers::AsMut<NSString> for NSMutableString {
                #[inline]
                fn as_mut(&mut self) -> &mut NSString {
                    &mut *self
                }
            }
            impl ::objc2::__macro_helpers::Borrow<NSString> for NSMutableString {
                #[inline]
                fn borrow(&self) -> &NSString {
                    &*self
                }
            }
            impl ::objc2::__macro_helpers::BorrowMut<NSString> for NSMutableString {
                #[inline]
                fn borrow_mut(&mut self) -> &mut NSString {
                    &mut *self
                }
            }
            impl ::objc2::__macro_helpers::AsRef<NSObject> for NSMutableString {
                #[inline]
                fn as_ref(&self) -> &NSObject {
                    &*self
                }
            }
            impl ::objc2::__macro_helpers::AsMut<NSObject> for NSMutableString {
                #[inline]
                fn as_mut(&mut self) -> &mut NSObject {
                    &mut *self
                }
            }
            impl ::objc2::__macro_helpers::Borrow<NSObject> for NSMutableString {
                #[inline]
                fn borrow(&self) -> &NSObject {
                    &*self
                }
            }
            impl ::objc2::__macro_helpers::BorrowMut<NSObject> for NSMutableString {
                #[inline]
                fn borrow_mut(&mut self) -> &mut NSObject {
                    &mut *self
                }
            }
            impl ::objc2::__macro_helpers::AsRef<::objc2::runtime::AnyObject>
            for NSMutableString {
                #[inline]
                fn as_ref(&self) -> &::objc2::runtime::AnyObject {
                    &*self
                }
            }
            impl ::objc2::__macro_helpers::AsMut<::objc2::runtime::AnyObject>
            for NSMutableString {
                #[inline]
                fn as_mut(&mut self) -> &mut ::objc2::runtime::AnyObject {
                    &mut *self
                }
            }
            impl ::objc2::__macro_helpers::Borrow<::objc2::runtime::AnyObject>
            for NSMutableString {
                #[inline]
                fn borrow(&self) -> &::objc2::runtime::AnyObject {
                    &*self
                }
            }
            impl ::objc2::__macro_helpers::BorrowMut<::objc2::runtime::AnyObject>
            for NSMutableString {
                #[inline]
                fn borrow_mut(&mut self) -> &mut ::objc2::runtime::AnyObject {
                    &mut *self
                }
            }
            #[cfg(feature = "Foundation_NSString")]
            unsafe impl ClassType for NSMutableString {
                type Super = NSString;
                type Mutability = MutableWithImmutableSuperclass<NSString>;
                const NAME: &'static ::objc2::__macro_helpers::str = "NSMutableString";
                #[inline]
                fn class() -> &'static ::objc2::runtime::AnyClass {
                    ::objc2::__macro_helpers::assert_mutability_matches_superclass_mutability::<
                        Self,
                    >();
                    {
                        static CACHED_CLASS: ::objc2::__macro_helpers::CachedClass = ::objc2::__macro_helpers::CachedClass::new();
                        #[allow(unused_unsafe)]
                        unsafe { CACHED_CLASS.get("NSMutableString\u{0}") }
                    }
                }
                #[inline]
                fn as_super(&self) -> &Self::Super {
                    &self.__superclass
                }
                #[inline]
                fn as_super_mut(&mut self) -> &mut Self::Super {
                    &mut self.__superclass
                }
            }
            #[cfg(feature = "Foundation_NSString")]
            const _: () = {
                if ::objc2::__macro_helpers::size_of::<NSMutableString>() != 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("the struct NSMutableString is not zero-sized!"),
                        );
                    }
                }
            };
            extern "C" {
                pub static NSCharacterConversionException: &'static NSExceptionName;
            }
            extern "C" {
                pub static NSParseErrorException: &'static NSExceptionName;
            }
            /// NSExtendedStringPropertyListParsing
            #[cfg(feature = "Foundation_NSString")]
            impl NSString {
                pub unsafe fn propertyList(&self) -> Id<AnyObject> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("propertyList\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                #[cfg(feature = "Foundation_NSDictionary")]
                pub unsafe fn propertyListFromStringsFileFormat(
                    &self,
                ) -> Option<Id<NSDictionary>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("propertyListFromStringsFileFormat\u{0}")
                                        }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
            }
            /// NSStringDeprecated
            #[cfg(feature = "Foundation_NSString")]
            impl NSString {
                #[deprecated = "Use -cStringUsingEncoding: instead"]
                pub unsafe fn cString(&self) -> *mut c_char {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("cString\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                #[deprecated = "Use -cStringUsingEncoding: instead"]
                pub unsafe fn lossyCString(&self) -> *mut c_char {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("lossyCString\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                #[deprecated = "Use -lengthOfBytesUsingEncoding: instead"]
                pub unsafe fn cStringLength(&self) -> NSUInteger {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("cStringLength\u{0}") }
                                    }
                                },
                                (),
                            );
                            result
                        }
                    }
                }
                #[deprecated = "Use -getCString:maxLength:encoding: instead"]
                pub unsafe fn getCString(&self, bytes: NonNull<c_char>) {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("getCString:\u{0}") }
                                    }
                                },
                                (bytes,),
                            );
                            result
                        }
                    }
                }
                #[deprecated = "Use -getCString:maxLength:encoding: instead"]
                pub unsafe fn getCString_maxLength(
                    &self,
                    bytes: NonNull<c_char>,
                    max_length: NSUInteger,
                ) {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("getCString:maxLength:\u{0}") }
                                    }
                                },
                                (bytes, max_length),
                            );
                            result
                        }
                    }
                }
                #[deprecated = "Use -getCString:maxLength:encoding: instead"]
                pub unsafe fn getCString_maxLength_range_remainingRange(
                    &self,
                    bytes: NonNull<c_char>,
                    max_length: NSUInteger,
                    a_range: NSRange,
                    leftover_range: NSRangePointer,
                ) {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("getCString:maxLength:range:remainingRange:\u{0}")
                                        }
                                    }
                                },
                                (bytes, max_length, a_range, leftover_range),
                            );
                            result
                        }
                    }
                }
                #[deprecated = "Use -writeToFile:atomically:encoding:error: instead"]
                pub unsafe fn writeToFile_atomically(
                    &self,
                    path: &NSString,
                    use_auxiliary_file: bool,
                ) -> bool {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("writeToFile:atomically:\u{0}") }
                                    }
                                },
                                (path, use_auxiliary_file),
                            );
                            result
                        }
                    }
                }
                #[deprecated = "Use -initWithContentsOfFile:encoding:error: instead"]
                pub unsafe fn initWithContentsOfFile(
                    this: Allocated<Self>,
                    path: &NSString,
                ) -> Option<Id<Self>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Init as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                this,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("initWithContentsOfFile:\u{0}") }
                                    }
                                },
                                (path,),
                            )
                        }
                    }
                }
                #[deprecated = "Use +stringWithContentsOfFile:encoding:error: instead"]
                pub unsafe fn stringWithContentsOfFile(
                    path: &NSString,
                ) -> Option<Id<AnyObject>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("stringWithContentsOfFile:\u{0}") }
                                    }
                                },
                                (path,),
                            )
                        }
                    }
                }
                #[deprecated = "Use -initWithCString:encoding: instead"]
                pub unsafe fn initWithCStringNoCopy_length_freeWhenDone(
                    this: Allocated<Self>,
                    bytes: NonNull<c_char>,
                    length: NSUInteger,
                    free_buffer: bool,
                ) -> Option<Id<Self>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Init as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                this,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("initWithCStringNoCopy:length:freeWhenDone:\u{0}")
                                        }
                                    }
                                },
                                (bytes, length, free_buffer),
                            )
                        }
                    }
                }
                #[deprecated = "Use -initWithCString:encoding: instead"]
                pub unsafe fn initWithCString_length(
                    this: Allocated<Self>,
                    bytes: NonNull<c_char>,
                    length: NSUInteger,
                ) -> Option<Id<Self>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Init as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                this,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("initWithCString:length:\u{0}") }
                                    }
                                },
                                (bytes, length),
                            )
                        }
                    }
                }
                #[deprecated = "Use -initWithCString:encoding: instead"]
                pub unsafe fn initWithCString(
                    this: Allocated<Self>,
                    bytes: NonNull<c_char>,
                ) -> Option<Id<Self>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Init as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                this,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("initWithCString:\u{0}") }
                                    }
                                },
                                (bytes,),
                            )
                        }
                    }
                }
                #[deprecated = "Use +stringWithCString:encoding:"]
                pub unsafe fn stringWithCString_length(
                    bytes: NonNull<c_char>,
                    length: NSUInteger,
                ) -> Option<Id<AnyObject>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("stringWithCString:length:\u{0}") }
                                    }
                                },
                                (bytes, length),
                            )
                        }
                    }
                }
                #[deprecated = "Use +stringWithCString:encoding: instead"]
                pub unsafe fn stringWithCString(
                    bytes: NonNull<c_char>,
                ) -> Option<Id<AnyObject>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                <Self as ::objc2::ClassType>::class(),
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("stringWithCString:\u{0}") }
                                    }
                                },
                                (bytes,),
                            )
                        }
                    }
                }
                pub unsafe fn getCharacters(&self, buffer: NonNull<unichar>) {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("getCharacters:\u{0}") }
                                    }
                                },
                                (buffer,),
                            );
                            result
                        }
                    }
                }
            }
        }
        #[path = "NSTask.rs"]
        mod __NSTask {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSTaskTerminationReason(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSTaskTerminationReason {
                #[inline]
                fn clone(&self) -> NSTaskTerminationReason {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSTaskTerminationReason {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSTaskTerminationReason {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSTaskTerminationReason",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSTaskTerminationReason {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSTaskTerminationReason {
                #[inline]
                fn eq(&self, other: &NSTaskTerminationReason) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSTaskTerminationReason {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSTaskTerminationReason {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSTaskTerminationReason {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSTaskTerminationReason {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSTaskTerminationReason,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSTaskTerminationReason {
                #[inline]
                fn cmp(&self, other: &NSTaskTerminationReason) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSTaskTerminationReason {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSTaskTerminationReason {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSTaskTerminationReason {
                #[doc(alias = "NSTaskTerminationReasonExit")]
                #[allow(non_upper_case_globals)]
                pub const Exit: Self = Self(1);
                #[doc(alias = "NSTaskTerminationReasonUncaughtSignal")]
                #[allow(non_upper_case_globals)]
                pub const UncaughtSignal: Self = Self(2);
            }
            extern "C" {
                pub static NSTaskDidTerminateNotification: &'static NSNotificationName;
            }
        }
        #[path = "NSTermOfAddress.rs"]
        mod __NSTermOfAddress {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSTextCheckingResult.rs"]
        mod __NSTextCheckingResult {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSTextCheckingType(pub u64);
            #[automatically_derived]
            impl ::core::clone::Clone for NSTextCheckingType {
                #[inline]
                fn clone(&self) -> NSTextCheckingType {
                    let _: ::core::clone::AssertParamIsClone<u64>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSTextCheckingType {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSTextCheckingType {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSTextCheckingType",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSTextCheckingType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSTextCheckingType {
                #[inline]
                fn eq(&self, other: &NSTextCheckingType) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSTextCheckingType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSTextCheckingType {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u64>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSTextCheckingType {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSTextCheckingType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSTextCheckingType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSTextCheckingType {
                #[inline]
                fn cmp(&self, other: &NSTextCheckingType) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSTextCheckingType {
                const ENCODING: objc2::Encoding = <u64 as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSTextCheckingType {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSTextCheckingType {
                #[doc(alias = "NSTextCheckingTypeOrthography")]
                #[allow(non_upper_case_globals)]
                pub const Orthography: Self = Self(1 << 0);
                #[doc(alias = "NSTextCheckingTypeSpelling")]
                #[allow(non_upper_case_globals)]
                pub const Spelling: Self = Self(1 << 1);
                #[doc(alias = "NSTextCheckingTypeGrammar")]
                #[allow(non_upper_case_globals)]
                pub const Grammar: Self = Self(1 << 2);
                #[doc(alias = "NSTextCheckingTypeDate")]
                #[allow(non_upper_case_globals)]
                pub const Date: Self = Self(1 << 3);
                #[doc(alias = "NSTextCheckingTypeAddress")]
                #[allow(non_upper_case_globals)]
                pub const Address: Self = Self(1 << 4);
                #[doc(alias = "NSTextCheckingTypeLink")]
                #[allow(non_upper_case_globals)]
                pub const Link: Self = Self(1 << 5);
                #[doc(alias = "NSTextCheckingTypeQuote")]
                #[allow(non_upper_case_globals)]
                pub const Quote: Self = Self(1 << 6);
                #[doc(alias = "NSTextCheckingTypeDash")]
                #[allow(non_upper_case_globals)]
                pub const Dash: Self = Self(1 << 7);
                #[doc(alias = "NSTextCheckingTypeReplacement")]
                #[allow(non_upper_case_globals)]
                pub const Replacement: Self = Self(1 << 8);
                #[doc(alias = "NSTextCheckingTypeCorrection")]
                #[allow(non_upper_case_globals)]
                pub const Correction: Self = Self(1 << 9);
                #[doc(alias = "NSTextCheckingTypeRegularExpression")]
                #[allow(non_upper_case_globals)]
                pub const RegularExpression: Self = Self(1 << 10);
                #[doc(alias = "NSTextCheckingTypePhoneNumber")]
                #[allow(non_upper_case_globals)]
                pub const PhoneNumber: Self = Self(1 << 11);
                #[doc(alias = "NSTextCheckingTypeTransitInformation")]
                #[allow(non_upper_case_globals)]
                pub const TransitInformation: Self = Self(1 << 12);
            }
            pub type NSTextCheckingTypes = u64;
            pub const NSTextCheckingAllSystemTypes: NSTextCheckingTypes = 0xffffffff;
            pub const NSTextCheckingAllCustomTypes: NSTextCheckingTypes = 0xffffffff
                << 32;
            pub const NSTextCheckingAllTypes: NSTextCheckingTypes = NSTextCheckingAllSystemTypes
                | NSTextCheckingAllCustomTypes;
            pub type NSTextCheckingKey = NSString;
            extern "C" {
                pub static NSTextCheckingNameKey: &'static NSTextCheckingKey;
            }
            extern "C" {
                pub static NSTextCheckingJobTitleKey: &'static NSTextCheckingKey;
            }
            extern "C" {
                pub static NSTextCheckingOrganizationKey: &'static NSTextCheckingKey;
            }
            extern "C" {
                pub static NSTextCheckingStreetKey: &'static NSTextCheckingKey;
            }
            extern "C" {
                pub static NSTextCheckingCityKey: &'static NSTextCheckingKey;
            }
            extern "C" {
                pub static NSTextCheckingStateKey: &'static NSTextCheckingKey;
            }
            extern "C" {
                pub static NSTextCheckingZIPKey: &'static NSTextCheckingKey;
            }
            extern "C" {
                pub static NSTextCheckingCountryKey: &'static NSTextCheckingKey;
            }
            extern "C" {
                pub static NSTextCheckingPhoneKey: &'static NSTextCheckingKey;
            }
            extern "C" {
                pub static NSTextCheckingAirlineKey: &'static NSTextCheckingKey;
            }
            extern "C" {
                pub static NSTextCheckingFlightKey: &'static NSTextCheckingKey;
            }
        }
        #[path = "NSThread.rs"]
        mod __NSThread {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSWillBecomeMultiThreadedNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSDidBecomeSingleThreadedNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSThreadWillExitNotification: &'static NSNotificationName;
            }
            /// Category "NSThreadPerformAdditions" on [`NSObject`].
            #[doc(alias = "NSThreadPerformAdditions")]
            pub unsafe trait NSObjectNSThreadPerformAdditions: ClassType {
                unsafe fn performSelectorOnMainThread_withObject_waitUntilDone(
                    &self,
                    a_selector: Sel,
                    arg: Option<&AnyObject>,
                    wait: bool,
                )
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get(
                                                    "performSelectorOnMainThread:withObject:waitUntilDone:\u{0}",
                                                )
                                        }
                                    }
                                },
                                (a_selector, arg, wait),
                            );
                            result
                        }
                    }
                }
                unsafe fn performSelectorInBackground_withObject(
                    &self,
                    a_selector: Sel,
                    arg: Option<&AnyObject>,
                )
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            let result;
                            result = ::objc2::__macro_helpers::MsgSend::send_message::<
                                _,
                                _,
                            >(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("performSelectorInBackground:withObject:\u{0}")
                                        }
                                    }
                                },
                                (a_selector, arg),
                            );
                            result
                        }
                    }
                }
                #[doc(hidden)]
                const __UNSAFE_INNER: ();
            }
            unsafe impl NSObjectNSThreadPerformAdditions for NSObject {
                const __UNSAFE_INNER: () = ();
            }
        }
        #[path = "NSTimeZone.rs"]
        mod __NSTimeZone {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSTimeZoneNameStyle(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSTimeZoneNameStyle {
                #[inline]
                fn clone(&self) -> NSTimeZoneNameStyle {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSTimeZoneNameStyle {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSTimeZoneNameStyle {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSTimeZoneNameStyle",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSTimeZoneNameStyle {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSTimeZoneNameStyle {
                #[inline]
                fn eq(&self, other: &NSTimeZoneNameStyle) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSTimeZoneNameStyle {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSTimeZoneNameStyle {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSTimeZoneNameStyle {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSTimeZoneNameStyle {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSTimeZoneNameStyle,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSTimeZoneNameStyle {
                #[inline]
                fn cmp(&self, other: &NSTimeZoneNameStyle) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSTimeZoneNameStyle {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSTimeZoneNameStyle {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSTimeZoneNameStyle {
                #[doc(alias = "NSTimeZoneNameStyleStandard")]
                #[allow(non_upper_case_globals)]
                pub const Standard: Self = Self(0);
                #[doc(alias = "NSTimeZoneNameStyleShortStandard")]
                #[allow(non_upper_case_globals)]
                pub const ShortStandard: Self = Self(1);
                #[doc(alias = "NSTimeZoneNameStyleDaylightSaving")]
                #[allow(non_upper_case_globals)]
                pub const DaylightSaving: Self = Self(2);
                #[doc(alias = "NSTimeZoneNameStyleShortDaylightSaving")]
                #[allow(non_upper_case_globals)]
                pub const ShortDaylightSaving: Self = Self(3);
                #[doc(alias = "NSTimeZoneNameStyleGeneric")]
                #[allow(non_upper_case_globals)]
                pub const Generic: Self = Self(4);
                #[doc(alias = "NSTimeZoneNameStyleShortGeneric")]
                #[allow(non_upper_case_globals)]
                pub const ShortGeneric: Self = Self(5);
            }
            extern "C" {
                pub static NSSystemTimeZoneDidChangeNotification: &'static NSNotificationName;
            }
        }
        #[path = "NSTimer.rs"]
        mod __NSTimer {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSURL.rs"]
        mod __NSURL {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub type NSURLResourceKey = NSString;
            extern "C" {
                pub static NSURLFileScheme: &'static NSString;
            }
            extern "C" {
                pub static NSURLKeysOfUnsetValuesKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLNameKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLLocalizedNameKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLIsRegularFileKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLIsDirectoryKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLIsSymbolicLinkKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLIsVolumeKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLIsPackageKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLIsApplicationKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLApplicationIsScriptableKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLIsSystemImmutableKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLIsUserImmutableKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLIsHiddenKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLHasHiddenExtensionKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLCreationDateKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLContentAccessDateKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLContentModificationDateKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLAttributeModificationDateKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLLinkCountKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLParentDirectoryURLKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeURLKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLTypeIdentifierKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLContentTypeKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLLocalizedTypeDescriptionKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLLabelNumberKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLLabelColorKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLLocalizedLabelKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLEffectiveIconKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLCustomIconKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLFileResourceIdentifierKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeIdentifierKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLPreferredIOBlockSizeKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLIsReadableKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLIsWritableKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLIsExecutableKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLFileSecurityKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLIsExcludedFromBackupKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLTagNamesKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLPathKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLCanonicalPathKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLIsMountTriggerKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLGenerationIdentifierKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLDocumentIdentifierKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLAddedToDirectoryDateKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLQuarantinePropertiesKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLFileResourceTypeKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLFileIdentifierKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLFileContentIdentifierKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLMayShareFileContentKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLMayHaveExtendedAttributesKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLIsPurgeableKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLIsSparseKey: &'static NSURLResourceKey;
            }
            pub type NSURLFileResourceType = NSString;
            extern "C" {
                pub static NSURLFileResourceTypeNamedPipe: &'static NSURLFileResourceType;
            }
            extern "C" {
                pub static NSURLFileResourceTypeCharacterSpecial: &'static NSURLFileResourceType;
            }
            extern "C" {
                pub static NSURLFileResourceTypeDirectory: &'static NSURLFileResourceType;
            }
            extern "C" {
                pub static NSURLFileResourceTypeBlockSpecial: &'static NSURLFileResourceType;
            }
            extern "C" {
                pub static NSURLFileResourceTypeRegular: &'static NSURLFileResourceType;
            }
            extern "C" {
                pub static NSURLFileResourceTypeSymbolicLink: &'static NSURLFileResourceType;
            }
            extern "C" {
                pub static NSURLFileResourceTypeSocket: &'static NSURLFileResourceType;
            }
            extern "C" {
                pub static NSURLFileResourceTypeUnknown: &'static NSURLFileResourceType;
            }
            extern "C" {
                pub static NSURLThumbnailDictionaryKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLThumbnailKey: &'static NSURLResourceKey;
            }
            pub type NSURLThumbnailDictionaryItem = NSString;
            extern "C" {
                pub static NSThumbnail1024x1024SizeKey: &'static NSURLThumbnailDictionaryItem;
            }
            extern "C" {
                pub static NSURLFileSizeKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLFileAllocatedSizeKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLTotalFileSizeKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLTotalFileAllocatedSizeKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLIsAliasFileKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLFileProtectionKey: &'static NSURLResourceKey;
            }
            pub type NSURLFileProtectionType = NSString;
            extern "C" {
                pub static NSURLFileProtectionNone: &'static NSURLFileProtectionType;
            }
            extern "C" {
                pub static NSURLFileProtectionComplete: &'static NSURLFileProtectionType;
            }
            extern "C" {
                pub static NSURLFileProtectionCompleteUnlessOpen: &'static NSURLFileProtectionType;
            }
            extern "C" {
                pub static NSURLFileProtectionCompleteUntilFirstUserAuthentication: &'static NSURLFileProtectionType;
            }
            extern "C" {
                pub static NSURLFileProtectionCompleteWhenUserInactive: &'static NSURLFileProtectionType;
            }
            extern "C" {
                pub static NSURLDirectoryEntryCountKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeLocalizedFormatDescriptionKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeTotalCapacityKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeAvailableCapacityKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeResourceCountKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeSupportsPersistentIDsKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeSupportsSymbolicLinksKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeSupportsHardLinksKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeSupportsJournalingKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeIsJournalingKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeSupportsSparseFilesKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeSupportsZeroRunsKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeSupportsCaseSensitiveNamesKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeSupportsCasePreservedNamesKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeSupportsRootDirectoryDatesKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeSupportsVolumeSizesKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeSupportsRenamingKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeSupportsAdvisoryFileLockingKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeSupportsExtendedSecurityKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeIsBrowsableKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeMaximumFileSizeKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeIsEjectableKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeIsRemovableKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeIsInternalKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeIsAutomountedKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeIsLocalKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeIsReadOnlyKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeCreationDateKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeURLForRemountingKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeUUIDStringKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeNameKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeLocalizedNameKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeIsEncryptedKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeIsRootFileSystemKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeSupportsCompressionKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeSupportsFileCloningKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeSupportsSwapRenamingKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeSupportsExclusiveRenamingKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeSupportsImmutableFilesKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeSupportsAccessPermissionsKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeSupportsFileProtectionKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeAvailableCapacityForImportantUsageKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeAvailableCapacityForOpportunisticUsageKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeTypeNameKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeSubtypeKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLVolumeMountFromLocationKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLIsUbiquitousItemKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLUbiquitousItemHasUnresolvedConflictsKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLUbiquitousItemIsDownloadedKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLUbiquitousItemIsDownloadingKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLUbiquitousItemIsUploadedKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLUbiquitousItemIsUploadingKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLUbiquitousItemPercentDownloadedKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLUbiquitousItemPercentUploadedKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLUbiquitousItemDownloadingStatusKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLUbiquitousItemDownloadingErrorKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLUbiquitousItemUploadingErrorKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLUbiquitousItemDownloadRequestedKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLUbiquitousItemContainerDisplayNameKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLUbiquitousItemIsExcludedFromSyncKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLUbiquitousItemIsSharedKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLUbiquitousSharedItemCurrentUserRoleKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLUbiquitousSharedItemCurrentUserPermissionsKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLUbiquitousSharedItemOwnerNameComponentsKey: &'static NSURLResourceKey;
            }
            extern "C" {
                pub static NSURLUbiquitousSharedItemMostRecentEditorNameComponentsKey: &'static NSURLResourceKey;
            }
            pub type NSURLUbiquitousItemDownloadingStatus = NSString;
            extern "C" {
                pub static NSURLUbiquitousItemDownloadingStatusNotDownloaded: &'static NSURLUbiquitousItemDownloadingStatus;
            }
            extern "C" {
                pub static NSURLUbiquitousItemDownloadingStatusDownloaded: &'static NSURLUbiquitousItemDownloadingStatus;
            }
            extern "C" {
                pub static NSURLUbiquitousItemDownloadingStatusCurrent: &'static NSURLUbiquitousItemDownloadingStatus;
            }
            pub type NSURLUbiquitousSharedItemRole = NSString;
            extern "C" {
                pub static NSURLUbiquitousSharedItemRoleOwner: &'static NSURLUbiquitousSharedItemRole;
            }
            extern "C" {
                pub static NSURLUbiquitousSharedItemRoleParticipant: &'static NSURLUbiquitousSharedItemRole;
            }
            pub type NSURLUbiquitousSharedItemPermissions = NSString;
            extern "C" {
                pub static NSURLUbiquitousSharedItemPermissionsReadOnly: &'static NSURLUbiquitousSharedItemPermissions;
            }
            extern "C" {
                pub static NSURLUbiquitousSharedItemPermissionsReadWrite: &'static NSURLUbiquitousSharedItemPermissions;
            }
            #[repr(transparent)]
            pub struct NSURLBookmarkCreationOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSURLBookmarkCreationOptions {
                #[inline]
                fn clone(&self) -> NSURLBookmarkCreationOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSURLBookmarkCreationOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSURLBookmarkCreationOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSURLBookmarkCreationOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSURLBookmarkCreationOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSURLBookmarkCreationOptions {
                #[inline]
                fn eq(&self, other: &NSURLBookmarkCreationOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSURLBookmarkCreationOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSURLBookmarkCreationOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSURLBookmarkCreationOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSURLBookmarkCreationOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSURLBookmarkCreationOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSURLBookmarkCreationOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSURLBookmarkCreationOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSURLBookmarkCreationOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSURLBookmarkCreationOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSURLBookmarkCreationOptions {
                #[deprecated = "Not supported"]
                #[allow(non_upper_case_globals)]
                pub const NSURLBookmarkCreationPreferFileIDResolution: Self = Self(
                    1 << 8,
                );
                #[allow(non_upper_case_globals)]
                pub const NSURLBookmarkCreationMinimalBookmark: Self = Self(1 << 9);
                #[allow(non_upper_case_globals)]
                pub const NSURLBookmarkCreationSuitableForBookmarkFile: Self = Self(
                    1 << 10,
                );
                #[allow(non_upper_case_globals)]
                pub const NSURLBookmarkCreationWithSecurityScope: Self = Self(1 << 11);
                #[allow(non_upper_case_globals)]
                pub const NSURLBookmarkCreationSecurityScopeAllowOnlyReadAccess: Self = Self(
                    1 << 12,
                );
                #[allow(non_upper_case_globals)]
                pub const NSURLBookmarkCreationWithoutImplicitSecurityScope: Self = Self(
                    1 << 29,
                );
            }
            #[repr(transparent)]
            pub struct NSURLBookmarkResolutionOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSURLBookmarkResolutionOptions {
                #[inline]
                fn clone(&self) -> NSURLBookmarkResolutionOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSURLBookmarkResolutionOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSURLBookmarkResolutionOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSURLBookmarkResolutionOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSURLBookmarkResolutionOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSURLBookmarkResolutionOptions {
                #[inline]
                fn eq(&self, other: &NSURLBookmarkResolutionOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSURLBookmarkResolutionOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSURLBookmarkResolutionOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSURLBookmarkResolutionOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSURLBookmarkResolutionOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSURLBookmarkResolutionOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSURLBookmarkResolutionOptions {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSURLBookmarkResolutionOptions,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSURLBookmarkResolutionOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSURLBookmarkResolutionOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSURLBookmarkResolutionOptions {
                #[allow(non_upper_case_globals)]
                pub const NSURLBookmarkResolutionWithoutUI: Self = Self(1 << 8);
                #[allow(non_upper_case_globals)]
                pub const NSURLBookmarkResolutionWithoutMounting: Self = Self(1 << 9);
                #[allow(non_upper_case_globals)]
                pub const NSURLBookmarkResolutionWithSecurityScope: Self = Self(1 << 10);
                #[allow(non_upper_case_globals)]
                pub const NSURLBookmarkResolutionWithoutImplicitStartAccessing: Self = Self(
                    1 << 15,
                );
            }
            pub type NSURLBookmarkFileCreationOptions = NSUInteger;
            /// NSURLUtilities
            #[cfg(feature = "Foundation_NSString")]
            impl NSString {
                pub unsafe fn stringByRemovingPercentEncoding(
                    &self,
                ) -> Option<Id<NSString>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL.get("stringByRemovingPercentEncoding\u{0}")
                                        }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
                #[deprecated = "Use -stringByAddingPercentEncodingWithAllowedCharacters: instead, which always uses the recommended UTF-8 encoding, and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid."]
                pub unsafe fn stringByAddingPercentEscapesUsingEncoding(
                    &self,
                    enc: NSStringEncoding,
                ) -> Option<Id<NSString>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("stringByAddingPercentEscapesUsingEncoding:\u{0}")
                                        }
                                    }
                                },
                                (enc,),
                            )
                        }
                    }
                }
                #[deprecated = "Use -stringByRemovingPercentEncoding instead, which always uses the recommended UTF-8 encoding."]
                pub unsafe fn stringByReplacingPercentEscapesUsingEncoding(
                    &self,
                    enc: NSStringEncoding,
                ) -> Option<Id<NSString>> {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe {
                                            CACHED_SEL
                                                .get("stringByReplacingPercentEscapesUsingEncoding:\u{0}")
                                        }
                                    }
                                },
                                (enc,),
                            )
                        }
                    }
                }
            }
        }
        #[path = "NSURLAuthenticationChallenge.rs"]
        mod __NSURLAuthenticationChallenge {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub unsafe trait NSURLAuthenticationChallengeSender: NSObjectProtocol {}
            unsafe impl<T> NSURLAuthenticationChallengeSender
            for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSURLAuthenticationChallengeSender,
            {}
            unsafe impl ProtocolType for dyn NSURLAuthenticationChallengeSender {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSURLAuthenticationChallengeSender";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSURLAuthenticationChallengeSender
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSURLAuthenticationChallengeSender,
            {
                const __INNER: () = ();
            }
        }
        #[path = "NSURLCache.rs"]
        mod __NSURLCache {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSURLCacheStoragePolicy(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSURLCacheStoragePolicy {
                #[inline]
                fn clone(&self) -> NSURLCacheStoragePolicy {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSURLCacheStoragePolicy {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSURLCacheStoragePolicy {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSURLCacheStoragePolicy",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSURLCacheStoragePolicy {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSURLCacheStoragePolicy {
                #[inline]
                fn eq(&self, other: &NSURLCacheStoragePolicy) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSURLCacheStoragePolicy {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSURLCacheStoragePolicy {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSURLCacheStoragePolicy {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSURLCacheStoragePolicy {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSURLCacheStoragePolicy,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSURLCacheStoragePolicy {
                #[inline]
                fn cmp(&self, other: &NSURLCacheStoragePolicy) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSURLCacheStoragePolicy {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSURLCacheStoragePolicy {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSURLCacheStoragePolicy {
                #[allow(non_upper_case_globals)]
                pub const NSURLCacheStorageAllowed: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSURLCacheStorageAllowedInMemoryOnly: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSURLCacheStorageNotAllowed: Self = Self(2);
            }
        }
        #[path = "NSURLConnection.rs"]
        mod __NSURLConnection {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub unsafe trait NSURLConnectionDelegate: NSObjectProtocol {}
            unsafe impl<T> NSURLConnectionDelegate
            for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSURLConnectionDelegate,
            {}
            unsafe impl ProtocolType for dyn NSURLConnectionDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSURLConnectionDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSURLConnectionDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSURLConnectionDelegate,
            {
                const __INNER: () = ();
            }
            pub unsafe trait NSURLConnectionDataDelegate: NSURLConnectionDelegate {}
            unsafe impl<T> NSURLConnectionDataDelegate
            for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSURLConnectionDataDelegate,
            {}
            unsafe impl ProtocolType for dyn NSURLConnectionDataDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSURLConnectionDataDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSURLConnectionDataDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSURLConnectionDataDelegate,
            {
                const __INNER: () = ();
            }
            pub unsafe trait NSURLConnectionDownloadDelegate: NSURLConnectionDelegate {}
            unsafe impl<T> NSURLConnectionDownloadDelegate
            for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSURLConnectionDownloadDelegate,
            {}
            unsafe impl ProtocolType for dyn NSURLConnectionDownloadDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSURLConnectionDownloadDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSURLConnectionDownloadDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSURLConnectionDownloadDelegate,
            {
                const __INNER: () = ();
            }
        }
        #[path = "NSURLCredential.rs"]
        mod __NSURLCredential {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSURLCredentialPersistence(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSURLCredentialPersistence {
                #[inline]
                fn clone(&self) -> NSURLCredentialPersistence {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSURLCredentialPersistence {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSURLCredentialPersistence {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSURLCredentialPersistence",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSURLCredentialPersistence {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSURLCredentialPersistence {
                #[inline]
                fn eq(&self, other: &NSURLCredentialPersistence) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSURLCredentialPersistence {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSURLCredentialPersistence {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSURLCredentialPersistence {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSURLCredentialPersistence {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSURLCredentialPersistence,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSURLCredentialPersistence {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSURLCredentialPersistence,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSURLCredentialPersistence {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSURLCredentialPersistence {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSURLCredentialPersistence {
                #[doc(alias = "NSURLCredentialPersistenceNone")]
                #[allow(non_upper_case_globals)]
                pub const None: Self = Self(0);
                #[doc(alias = "NSURLCredentialPersistenceForSession")]
                #[allow(non_upper_case_globals)]
                pub const ForSession: Self = Self(1);
                #[doc(alias = "NSURLCredentialPersistencePermanent")]
                #[allow(non_upper_case_globals)]
                pub const Permanent: Self = Self(2);
                #[doc(alias = "NSURLCredentialPersistenceSynchronizable")]
                #[allow(non_upper_case_globals)]
                pub const Synchronizable: Self = Self(3);
            }
        }
        #[path = "NSURLCredentialStorage.rs"]
        mod __NSURLCredentialStorage {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSURLCredentialStorageChangedNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSURLCredentialStorageRemoveSynchronizableCredentials: &'static NSString;
            }
        }
        #[path = "NSURLDownload.rs"]
        mod __NSURLDownload {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub unsafe trait NSURLDownloadDelegate: NSObjectProtocol {}
            unsafe impl<T> NSURLDownloadDelegate for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSURLDownloadDelegate,
            {}
            unsafe impl ProtocolType for dyn NSURLDownloadDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSURLDownloadDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSURLDownloadDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSURLDownloadDelegate,
            {
                const __INNER: () = ();
            }
        }
        #[path = "NSURLError.rs"]
        mod __NSURLError {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSURLErrorDomain: &'static NSErrorDomain;
            }
            extern "C" {
                pub static NSURLErrorFailingURLErrorKey: &'static NSString;
            }
            extern "C" {
                pub static NSURLErrorFailingURLStringErrorKey: &'static NSString;
            }
            extern "C" {
                pub static NSErrorFailingURLStringKey: &'static NSString;
            }
            extern "C" {
                pub static NSURLErrorFailingURLPeerTrustErrorKey: &'static NSString;
            }
            extern "C" {
                pub static NSURLErrorBackgroundTaskCancelledReasonKey: &'static NSString;
            }
            pub const NSURLErrorCancelledReasonUserForceQuitApplication: NSInteger = 0;
            pub const NSURLErrorCancelledReasonBackgroundUpdatesDisabled: NSInteger = 1;
            pub const NSURLErrorCancelledReasonInsufficientSystemResources: NSInteger = 2;
            extern "C" {
                pub static NSURLErrorNetworkUnavailableReasonKey: &'static NSErrorUserInfoKey;
            }
            #[repr(transparent)]
            pub struct NSURLErrorNetworkUnavailableReason(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSURLErrorNetworkUnavailableReason {
                #[inline]
                fn clone(&self) -> NSURLErrorNetworkUnavailableReason {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSURLErrorNetworkUnavailableReason {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSURLErrorNetworkUnavailableReason {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSURLErrorNetworkUnavailableReason",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSURLErrorNetworkUnavailableReason {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSURLErrorNetworkUnavailableReason {
                #[inline]
                fn eq(&self, other: &NSURLErrorNetworkUnavailableReason) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSURLErrorNetworkUnavailableReason {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSURLErrorNetworkUnavailableReason {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSURLErrorNetworkUnavailableReason {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSURLErrorNetworkUnavailableReason {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSURLErrorNetworkUnavailableReason,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSURLErrorNetworkUnavailableReason {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSURLErrorNetworkUnavailableReason,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSURLErrorNetworkUnavailableReason {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSURLErrorNetworkUnavailableReason {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSURLErrorNetworkUnavailableReason {
                #[doc(alias = "NSURLErrorNetworkUnavailableReasonCellular")]
                #[allow(non_upper_case_globals)]
                pub const Cellular: Self = Self(0);
                #[doc(alias = "NSURLErrorNetworkUnavailableReasonExpensive")]
                #[allow(non_upper_case_globals)]
                pub const Expensive: Self = Self(1);
                #[doc(alias = "NSURLErrorNetworkUnavailableReasonConstrained")]
                #[allow(non_upper_case_globals)]
                pub const Constrained: Self = Self(2);
            }
            pub const NSURLErrorUnknown: NSInteger = -1;
            pub const NSURLErrorCancelled: NSInteger = -999;
            pub const NSURLErrorBadURL: NSInteger = -1000;
            pub const NSURLErrorTimedOut: NSInteger = -1001;
            pub const NSURLErrorUnsupportedURL: NSInteger = -1002;
            pub const NSURLErrorCannotFindHost: NSInteger = -1003;
            pub const NSURLErrorCannotConnectToHost: NSInteger = -1004;
            pub const NSURLErrorNetworkConnectionLost: NSInteger = -1005;
            pub const NSURLErrorDNSLookupFailed: NSInteger = -1006;
            pub const NSURLErrorHTTPTooManyRedirects: NSInteger = -1007;
            pub const NSURLErrorResourceUnavailable: NSInteger = -1008;
            pub const NSURLErrorNotConnectedToInternet: NSInteger = -1009;
            pub const NSURLErrorRedirectToNonExistentLocation: NSInteger = -1010;
            pub const NSURLErrorBadServerResponse: NSInteger = -1011;
            pub const NSURLErrorUserCancelledAuthentication: NSInteger = -1012;
            pub const NSURLErrorUserAuthenticationRequired: NSInteger = -1013;
            pub const NSURLErrorZeroByteResource: NSInteger = -1014;
            pub const NSURLErrorCannotDecodeRawData: NSInteger = -1015;
            pub const NSURLErrorCannotDecodeContentData: NSInteger = -1016;
            pub const NSURLErrorCannotParseResponse: NSInteger = -1017;
            pub const NSURLErrorAppTransportSecurityRequiresSecureConnection: NSInteger = -1022;
            pub const NSURLErrorFileDoesNotExist: NSInteger = -1100;
            pub const NSURLErrorFileIsDirectory: NSInteger = -1101;
            pub const NSURLErrorNoPermissionsToReadFile: NSInteger = -1102;
            pub const NSURLErrorDataLengthExceedsMaximum: NSInteger = -1103;
            pub const NSURLErrorFileOutsideSafeArea: NSInteger = -1104;
            pub const NSURLErrorSecureConnectionFailed: NSInteger = -1200;
            pub const NSURLErrorServerCertificateHasBadDate: NSInteger = -1201;
            pub const NSURLErrorServerCertificateUntrusted: NSInteger = -1202;
            pub const NSURLErrorServerCertificateHasUnknownRoot: NSInteger = -1203;
            pub const NSURLErrorServerCertificateNotYetValid: NSInteger = -1204;
            pub const NSURLErrorClientCertificateRejected: NSInteger = -1205;
            pub const NSURLErrorClientCertificateRequired: NSInteger = -1206;
            pub const NSURLErrorCannotLoadFromNetwork: NSInteger = -2000;
            pub const NSURLErrorCannotCreateFile: NSInteger = -3000;
            pub const NSURLErrorCannotOpenFile: NSInteger = -3001;
            pub const NSURLErrorCannotCloseFile: NSInteger = -3002;
            pub const NSURLErrorCannotWriteToFile: NSInteger = -3003;
            pub const NSURLErrorCannotRemoveFile: NSInteger = -3004;
            pub const NSURLErrorCannotMoveFile: NSInteger = -3005;
            pub const NSURLErrorDownloadDecodingFailedMidStream: NSInteger = -3006;
            pub const NSURLErrorDownloadDecodingFailedToComplete: NSInteger = -3007;
            pub const NSURLErrorInternationalRoamingOff: NSInteger = -1018;
            pub const NSURLErrorCallIsActive: NSInteger = -1019;
            pub const NSURLErrorDataNotAllowed: NSInteger = -1020;
            pub const NSURLErrorRequestBodyStreamExhausted: NSInteger = -1021;
            pub const NSURLErrorBackgroundSessionRequiresSharedContainer: NSInteger = -995;
            pub const NSURLErrorBackgroundSessionInUseByAnotherProcess: NSInteger = -996;
            pub const NSURLErrorBackgroundSessionWasDisconnected: NSInteger = -997;
        }
        #[path = "NSURLHandle.rs"]
        mod __NSURLHandle {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSHTTPPropertyStatusCodeKey: Option<&'static NSString>;
            }
            extern "C" {
                pub static NSHTTPPropertyStatusReasonKey: Option<&'static NSString>;
            }
            extern "C" {
                pub static NSHTTPPropertyServerHTTPVersionKey: Option<&'static NSString>;
            }
            extern "C" {
                pub static NSHTTPPropertyRedirectionHeadersKey: Option<
                    &'static NSString,
                >;
            }
            extern "C" {
                pub static NSHTTPPropertyErrorPageDataKey: Option<&'static NSString>;
            }
            extern "C" {
                pub static NSHTTPPropertyHTTPProxy: Option<&'static NSString>;
            }
            extern "C" {
                pub static NSFTPPropertyUserLoginKey: Option<&'static NSString>;
            }
            extern "C" {
                pub static NSFTPPropertyUserPasswordKey: Option<&'static NSString>;
            }
            extern "C" {
                pub static NSFTPPropertyActiveTransferModeKey: Option<&'static NSString>;
            }
            extern "C" {
                pub static NSFTPPropertyFileOffsetKey: Option<&'static NSString>;
            }
            extern "C" {
                pub static NSFTPPropertyFTPProxy: Option<&'static NSString>;
            }
            #[repr(transparent)]
            pub struct NSURLHandleStatus(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSURLHandleStatus {
                #[inline]
                fn clone(&self) -> NSURLHandleStatus {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSURLHandleStatus {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSURLHandleStatus {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSURLHandleStatus",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSURLHandleStatus {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSURLHandleStatus {
                #[inline]
                fn eq(&self, other: &NSURLHandleStatus) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSURLHandleStatus {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSURLHandleStatus {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSURLHandleStatus {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSURLHandleStatus {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSURLHandleStatus,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSURLHandleStatus {
                #[inline]
                fn cmp(&self, other: &NSURLHandleStatus) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSURLHandleStatus {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSURLHandleStatus {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSURLHandleStatus {
                #[allow(non_upper_case_globals)]
                pub const NSURLHandleNotLoaded: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSURLHandleLoadSucceeded: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSURLHandleLoadInProgress: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSURLHandleLoadFailed: Self = Self(3);
            }
            #[deprecated]
            pub unsafe trait NSURLHandleClient {}
            unsafe impl<T> NSURLHandleClient for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSURLHandleClient,
            {}
            unsafe impl ProtocolType for dyn NSURLHandleClient {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSURLHandleClient";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T> for dyn NSURLHandleClient
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSURLHandleClient,
            {
                const __INNER: () = ();
            }
        }
        #[path = "NSURLProtectionSpace.rs"]
        mod __NSURLProtectionSpace {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSURLProtectionSpaceHTTP: &'static NSString;
            }
            extern "C" {
                pub static NSURLProtectionSpaceHTTPS: &'static NSString;
            }
            extern "C" {
                pub static NSURLProtectionSpaceFTP: &'static NSString;
            }
            extern "C" {
                pub static NSURLProtectionSpaceHTTPProxy: &'static NSString;
            }
            extern "C" {
                pub static NSURLProtectionSpaceHTTPSProxy: &'static NSString;
            }
            extern "C" {
                pub static NSURLProtectionSpaceFTPProxy: &'static NSString;
            }
            extern "C" {
                pub static NSURLProtectionSpaceSOCKSProxy: &'static NSString;
            }
            extern "C" {
                pub static NSURLAuthenticationMethodDefault: &'static NSString;
            }
            extern "C" {
                pub static NSURLAuthenticationMethodHTTPBasic: &'static NSString;
            }
            extern "C" {
                pub static NSURLAuthenticationMethodHTTPDigest: &'static NSString;
            }
            extern "C" {
                pub static NSURLAuthenticationMethodHTMLForm: &'static NSString;
            }
            extern "C" {
                pub static NSURLAuthenticationMethodNTLM: &'static NSString;
            }
            extern "C" {
                pub static NSURLAuthenticationMethodNegotiate: &'static NSString;
            }
            extern "C" {
                pub static NSURLAuthenticationMethodClientCertificate: &'static NSString;
            }
            extern "C" {
                pub static NSURLAuthenticationMethodServerTrust: &'static NSString;
            }
        }
        #[path = "NSURLProtocol.rs"]
        mod __NSURLProtocol {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub unsafe trait NSURLProtocolClient: NSObjectProtocol {}
            unsafe impl<T> NSURLProtocolClient for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSURLProtocolClient,
            {}
            unsafe impl ProtocolType for dyn NSURLProtocolClient {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSURLProtocolClient";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T> for dyn NSURLProtocolClient
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSURLProtocolClient,
            {
                const __INNER: () = ();
            }
        }
        #[path = "NSURLRequest.rs"]
        mod __NSURLRequest {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSURLRequestCachePolicy(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSURLRequestCachePolicy {
                #[inline]
                fn clone(&self) -> NSURLRequestCachePolicy {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSURLRequestCachePolicy {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSURLRequestCachePolicy {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSURLRequestCachePolicy",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSURLRequestCachePolicy {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSURLRequestCachePolicy {
                #[inline]
                fn eq(&self, other: &NSURLRequestCachePolicy) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSURLRequestCachePolicy {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSURLRequestCachePolicy {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSURLRequestCachePolicy {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSURLRequestCachePolicy {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSURLRequestCachePolicy,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSURLRequestCachePolicy {
                #[inline]
                fn cmp(&self, other: &NSURLRequestCachePolicy) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSURLRequestCachePolicy {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSURLRequestCachePolicy {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSURLRequestCachePolicy {
                #[allow(non_upper_case_globals)]
                pub const NSURLRequestUseProtocolCachePolicy: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSURLRequestReloadIgnoringLocalCacheData: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSURLRequestReloadIgnoringLocalAndRemoteCacheData: Self = Self(
                    4,
                );
                #[allow(non_upper_case_globals)]
                pub const NSURLRequestReloadIgnoringCacheData: Self = Self(
                    NSURLRequestCachePolicy::NSURLRequestReloadIgnoringLocalCacheData.0,
                );
                #[allow(non_upper_case_globals)]
                pub const NSURLRequestReturnCacheDataElseLoad: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSURLRequestReturnCacheDataDontLoad: Self = Self(3);
                #[allow(non_upper_case_globals)]
                pub const NSURLRequestReloadRevalidatingCacheData: Self = Self(5);
            }
            #[repr(transparent)]
            pub struct NSURLRequestNetworkServiceType(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSURLRequestNetworkServiceType {
                #[inline]
                fn clone(&self) -> NSURLRequestNetworkServiceType {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSURLRequestNetworkServiceType {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSURLRequestNetworkServiceType {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSURLRequestNetworkServiceType",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSURLRequestNetworkServiceType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSURLRequestNetworkServiceType {
                #[inline]
                fn eq(&self, other: &NSURLRequestNetworkServiceType) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSURLRequestNetworkServiceType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSURLRequestNetworkServiceType {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSURLRequestNetworkServiceType {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSURLRequestNetworkServiceType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSURLRequestNetworkServiceType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSURLRequestNetworkServiceType {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSURLRequestNetworkServiceType,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSURLRequestNetworkServiceType {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSURLRequestNetworkServiceType {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSURLRequestNetworkServiceType {
                #[allow(non_upper_case_globals)]
                pub const NSURLNetworkServiceTypeDefault: Self = Self(0);
                #[deprecated = "Use PushKit for VoIP control purposes"]
                #[allow(non_upper_case_globals)]
                pub const NSURLNetworkServiceTypeVoIP: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSURLNetworkServiceTypeVideo: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSURLNetworkServiceTypeBackground: Self = Self(3);
                #[allow(non_upper_case_globals)]
                pub const NSURLNetworkServiceTypeVoice: Self = Self(4);
                #[allow(non_upper_case_globals)]
                pub const NSURLNetworkServiceTypeResponsiveData: Self = Self(6);
                #[allow(non_upper_case_globals)]
                pub const NSURLNetworkServiceTypeAVStreaming: Self = Self(8);
                #[allow(non_upper_case_globals)]
                pub const NSURLNetworkServiceTypeResponsiveAV: Self = Self(9);
                #[allow(non_upper_case_globals)]
                pub const NSURLNetworkServiceTypeCallSignaling: Self = Self(11);
            }
            #[repr(transparent)]
            pub struct NSURLRequestAttribution(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSURLRequestAttribution {
                #[inline]
                fn clone(&self) -> NSURLRequestAttribution {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSURLRequestAttribution {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSURLRequestAttribution {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSURLRequestAttribution",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSURLRequestAttribution {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSURLRequestAttribution {
                #[inline]
                fn eq(&self, other: &NSURLRequestAttribution) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSURLRequestAttribution {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSURLRequestAttribution {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSURLRequestAttribution {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSURLRequestAttribution {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSURLRequestAttribution,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSURLRequestAttribution {
                #[inline]
                fn cmp(&self, other: &NSURLRequestAttribution) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSURLRequestAttribution {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSURLRequestAttribution {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSURLRequestAttribution {
                #[doc(alias = "NSURLRequestAttributionDeveloper")]
                #[allow(non_upper_case_globals)]
                pub const Developer: Self = Self(0);
                #[doc(alias = "NSURLRequestAttributionUser")]
                #[allow(non_upper_case_globals)]
                pub const User: Self = Self(1);
            }
        }
        #[path = "NSURLResponse.rs"]
        mod __NSURLResponse {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSURLSession.rs"]
        mod __NSURLSession {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSURLSessionTransferSizeUnknown: i64;
            }
            #[repr(transparent)]
            pub struct NSURLSessionTaskState(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSURLSessionTaskState {
                #[inline]
                fn clone(&self) -> NSURLSessionTaskState {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSURLSessionTaskState {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSURLSessionTaskState {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSURLSessionTaskState",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSURLSessionTaskState {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSURLSessionTaskState {
                #[inline]
                fn eq(&self, other: &NSURLSessionTaskState) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSURLSessionTaskState {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSURLSessionTaskState {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSURLSessionTaskState {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSURLSessionTaskState {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSURLSessionTaskState,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSURLSessionTaskState {
                #[inline]
                fn cmp(&self, other: &NSURLSessionTaskState) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSURLSessionTaskState {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSURLSessionTaskState {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSURLSessionTaskState {
                #[doc(alias = "NSURLSessionTaskStateRunning")]
                #[allow(non_upper_case_globals)]
                pub const Running: Self = Self(0);
                #[doc(alias = "NSURLSessionTaskStateSuspended")]
                #[allow(non_upper_case_globals)]
                pub const Suspended: Self = Self(1);
                #[doc(alias = "NSURLSessionTaskStateCanceling")]
                #[allow(non_upper_case_globals)]
                pub const Canceling: Self = Self(2);
                #[doc(alias = "NSURLSessionTaskStateCompleted")]
                #[allow(non_upper_case_globals)]
                pub const Completed: Self = Self(3);
            }
            extern "C" {
                pub static NSURLSessionTaskPriorityDefault: c_float;
            }
            extern "C" {
                pub static NSURLSessionTaskPriorityLow: c_float;
            }
            extern "C" {
                pub static NSURLSessionTaskPriorityHigh: c_float;
            }
            #[repr(transparent)]
            pub struct NSURLSessionWebSocketMessageType(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSURLSessionWebSocketMessageType {
                #[inline]
                fn clone(&self) -> NSURLSessionWebSocketMessageType {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSURLSessionWebSocketMessageType {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSURLSessionWebSocketMessageType {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSURLSessionWebSocketMessageType",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSURLSessionWebSocketMessageType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSURLSessionWebSocketMessageType {
                #[inline]
                fn eq(&self, other: &NSURLSessionWebSocketMessageType) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSURLSessionWebSocketMessageType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSURLSessionWebSocketMessageType {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSURLSessionWebSocketMessageType {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSURLSessionWebSocketMessageType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSURLSessionWebSocketMessageType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSURLSessionWebSocketMessageType {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSURLSessionWebSocketMessageType,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSURLSessionWebSocketMessageType {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSURLSessionWebSocketMessageType {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSURLSessionWebSocketMessageType {
                #[doc(alias = "NSURLSessionWebSocketMessageTypeData")]
                #[allow(non_upper_case_globals)]
                pub const Data: Self = Self(0);
                #[doc(alias = "NSURLSessionWebSocketMessageTypeString")]
                #[allow(non_upper_case_globals)]
                pub const String: Self = Self(1);
            }
            #[repr(transparent)]
            pub struct NSURLSessionWebSocketCloseCode(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSURLSessionWebSocketCloseCode {
                #[inline]
                fn clone(&self) -> NSURLSessionWebSocketCloseCode {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSURLSessionWebSocketCloseCode {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSURLSessionWebSocketCloseCode {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSURLSessionWebSocketCloseCode",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSURLSessionWebSocketCloseCode {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSURLSessionWebSocketCloseCode {
                #[inline]
                fn eq(&self, other: &NSURLSessionWebSocketCloseCode) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSURLSessionWebSocketCloseCode {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSURLSessionWebSocketCloseCode {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSURLSessionWebSocketCloseCode {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSURLSessionWebSocketCloseCode {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSURLSessionWebSocketCloseCode,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSURLSessionWebSocketCloseCode {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSURLSessionWebSocketCloseCode,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSURLSessionWebSocketCloseCode {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSURLSessionWebSocketCloseCode {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSURLSessionWebSocketCloseCode {
                #[doc(alias = "NSURLSessionWebSocketCloseCodeInvalid")]
                #[allow(non_upper_case_globals)]
                pub const Invalid: Self = Self(0);
                #[doc(alias = "NSURLSessionWebSocketCloseCodeNormalClosure")]
                #[allow(non_upper_case_globals)]
                pub const NormalClosure: Self = Self(1000);
                #[doc(alias = "NSURLSessionWebSocketCloseCodeGoingAway")]
                #[allow(non_upper_case_globals)]
                pub const GoingAway: Self = Self(1001);
                #[doc(alias = "NSURLSessionWebSocketCloseCodeProtocolError")]
                #[allow(non_upper_case_globals)]
                pub const ProtocolError: Self = Self(1002);
                #[doc(alias = "NSURLSessionWebSocketCloseCodeUnsupportedData")]
                #[allow(non_upper_case_globals)]
                pub const UnsupportedData: Self = Self(1003);
                #[doc(alias = "NSURLSessionWebSocketCloseCodeNoStatusReceived")]
                #[allow(non_upper_case_globals)]
                pub const NoStatusReceived: Self = Self(1005);
                #[doc(alias = "NSURLSessionWebSocketCloseCodeAbnormalClosure")]
                #[allow(non_upper_case_globals)]
                pub const AbnormalClosure: Self = Self(1006);
                #[doc(alias = "NSURLSessionWebSocketCloseCodeInvalidFramePayloadData")]
                #[allow(non_upper_case_globals)]
                pub const InvalidFramePayloadData: Self = Self(1007);
                #[doc(alias = "NSURLSessionWebSocketCloseCodePolicyViolation")]
                #[allow(non_upper_case_globals)]
                pub const PolicyViolation: Self = Self(1008);
                #[doc(alias = "NSURLSessionWebSocketCloseCodeMessageTooBig")]
                #[allow(non_upper_case_globals)]
                pub const MessageTooBig: Self = Self(1009);
                #[doc(alias = "NSURLSessionWebSocketCloseCodeMandatoryExtensionMissing")]
                #[allow(non_upper_case_globals)]
                pub const MandatoryExtensionMissing: Self = Self(1010);
                #[doc(alias = "NSURLSessionWebSocketCloseCodeInternalServerError")]
                #[allow(non_upper_case_globals)]
                pub const InternalServerError: Self = Self(1011);
                #[doc(alias = "NSURLSessionWebSocketCloseCodeTLSHandshakeFailure")]
                #[allow(non_upper_case_globals)]
                pub const TLSHandshakeFailure: Self = Self(1015);
            }
            #[repr(transparent)]
            pub struct NSURLSessionMultipathServiceType(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSURLSessionMultipathServiceType {
                #[inline]
                fn clone(&self) -> NSURLSessionMultipathServiceType {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSURLSessionMultipathServiceType {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSURLSessionMultipathServiceType {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSURLSessionMultipathServiceType",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSURLSessionMultipathServiceType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSURLSessionMultipathServiceType {
                #[inline]
                fn eq(&self, other: &NSURLSessionMultipathServiceType) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSURLSessionMultipathServiceType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSURLSessionMultipathServiceType {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSURLSessionMultipathServiceType {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSURLSessionMultipathServiceType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSURLSessionMultipathServiceType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSURLSessionMultipathServiceType {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSURLSessionMultipathServiceType,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSURLSessionMultipathServiceType {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSURLSessionMultipathServiceType {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSURLSessionMultipathServiceType {
                #[doc(alias = "NSURLSessionMultipathServiceTypeNone")]
                #[allow(non_upper_case_globals)]
                pub const None: Self = Self(0);
                #[doc(alias = "NSURLSessionMultipathServiceTypeHandover")]
                #[allow(non_upper_case_globals)]
                pub const Handover: Self = Self(1);
                #[doc(alias = "NSURLSessionMultipathServiceTypeInteractive")]
                #[allow(non_upper_case_globals)]
                pub const Interactive: Self = Self(2);
                #[doc(alias = "NSURLSessionMultipathServiceTypeAggregate")]
                #[allow(non_upper_case_globals)]
                pub const Aggregate: Self = Self(3);
            }
            #[repr(transparent)]
            pub struct NSURLSessionDelayedRequestDisposition(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSURLSessionDelayedRequestDisposition {
                #[inline]
                fn clone(&self) -> NSURLSessionDelayedRequestDisposition {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSURLSessionDelayedRequestDisposition {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSURLSessionDelayedRequestDisposition {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSURLSessionDelayedRequestDisposition",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSURLSessionDelayedRequestDisposition {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSURLSessionDelayedRequestDisposition {
                #[inline]
                fn eq(&self, other: &NSURLSessionDelayedRequestDisposition) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSURLSessionDelayedRequestDisposition {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSURLSessionDelayedRequestDisposition {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSURLSessionDelayedRequestDisposition {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSURLSessionDelayedRequestDisposition {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSURLSessionDelayedRequestDisposition,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSURLSessionDelayedRequestDisposition {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSURLSessionDelayedRequestDisposition,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSURLSessionDelayedRequestDisposition {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSURLSessionDelayedRequestDisposition {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSURLSessionDelayedRequestDisposition {
                #[allow(non_upper_case_globals)]
                pub const NSURLSessionDelayedRequestContinueLoading: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSURLSessionDelayedRequestUseNewRequest: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSURLSessionDelayedRequestCancel: Self = Self(2);
            }
            #[repr(transparent)]
            pub struct NSURLSessionAuthChallengeDisposition(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSURLSessionAuthChallengeDisposition {
                #[inline]
                fn clone(&self) -> NSURLSessionAuthChallengeDisposition {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSURLSessionAuthChallengeDisposition {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSURLSessionAuthChallengeDisposition {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSURLSessionAuthChallengeDisposition",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSURLSessionAuthChallengeDisposition {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSURLSessionAuthChallengeDisposition {
                #[inline]
                fn eq(&self, other: &NSURLSessionAuthChallengeDisposition) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSURLSessionAuthChallengeDisposition {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSURLSessionAuthChallengeDisposition {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSURLSessionAuthChallengeDisposition {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSURLSessionAuthChallengeDisposition {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSURLSessionAuthChallengeDisposition,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSURLSessionAuthChallengeDisposition {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSURLSessionAuthChallengeDisposition,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSURLSessionAuthChallengeDisposition {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSURLSessionAuthChallengeDisposition {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSURLSessionAuthChallengeDisposition {
                #[allow(non_upper_case_globals)]
                pub const NSURLSessionAuthChallengeUseCredential: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSURLSessionAuthChallengePerformDefaultHandling: Self = Self(
                    1,
                );
                #[allow(non_upper_case_globals)]
                pub const NSURLSessionAuthChallengeCancelAuthenticationChallenge: Self = Self(
                    2,
                );
                #[allow(non_upper_case_globals)]
                pub const NSURLSessionAuthChallengeRejectProtectionSpace: Self = Self(3);
            }
            #[repr(transparent)]
            pub struct NSURLSessionResponseDisposition(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSURLSessionResponseDisposition {
                #[inline]
                fn clone(&self) -> NSURLSessionResponseDisposition {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSURLSessionResponseDisposition {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSURLSessionResponseDisposition {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSURLSessionResponseDisposition",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSURLSessionResponseDisposition {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSURLSessionResponseDisposition {
                #[inline]
                fn eq(&self, other: &NSURLSessionResponseDisposition) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSURLSessionResponseDisposition {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSURLSessionResponseDisposition {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSURLSessionResponseDisposition {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSURLSessionResponseDisposition {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSURLSessionResponseDisposition,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSURLSessionResponseDisposition {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSURLSessionResponseDisposition,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSURLSessionResponseDisposition {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSURLSessionResponseDisposition {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSURLSessionResponseDisposition {
                #[allow(non_upper_case_globals)]
                pub const NSURLSessionResponseCancel: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSURLSessionResponseAllow: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSURLSessionResponseBecomeDownload: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSURLSessionResponseBecomeStream: Self = Self(3);
            }
            pub unsafe trait NSURLSessionDelegate: NSObjectProtocol {}
            unsafe impl<T> NSURLSessionDelegate for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSURLSessionDelegate,
            {}
            unsafe impl ProtocolType for dyn NSURLSessionDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSURLSessionDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSURLSessionDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSURLSessionDelegate,
            {
                const __INNER: () = ();
            }
            pub unsafe trait NSURLSessionTaskDelegate: NSURLSessionDelegate {}
            unsafe impl<T> NSURLSessionTaskDelegate
            for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSURLSessionTaskDelegate,
            {}
            unsafe impl ProtocolType for dyn NSURLSessionTaskDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSURLSessionTaskDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSURLSessionTaskDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSURLSessionTaskDelegate,
            {
                const __INNER: () = ();
            }
            pub unsafe trait NSURLSessionDataDelegate: NSURLSessionTaskDelegate {}
            unsafe impl<T> NSURLSessionDataDelegate
            for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSURLSessionDataDelegate,
            {}
            unsafe impl ProtocolType for dyn NSURLSessionDataDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSURLSessionDataDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSURLSessionDataDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSURLSessionDataDelegate,
            {
                const __INNER: () = ();
            }
            pub unsafe trait NSURLSessionDownloadDelegate: NSURLSessionTaskDelegate {}
            unsafe impl<T> NSURLSessionDownloadDelegate
            for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSURLSessionDownloadDelegate,
            {}
            unsafe impl ProtocolType for dyn NSURLSessionDownloadDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSURLSessionDownloadDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSURLSessionDownloadDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSURLSessionDownloadDelegate,
            {
                const __INNER: () = ();
            }
            pub unsafe trait NSURLSessionStreamDelegate: NSURLSessionTaskDelegate {}
            unsafe impl<T> NSURLSessionStreamDelegate
            for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSURLSessionStreamDelegate,
            {}
            unsafe impl ProtocolType for dyn NSURLSessionStreamDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSURLSessionStreamDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSURLSessionStreamDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSURLSessionStreamDelegate,
            {
                const __INNER: () = ();
            }
            pub unsafe trait NSURLSessionWebSocketDelegate: NSURLSessionTaskDelegate {}
            unsafe impl<T> NSURLSessionWebSocketDelegate
            for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSURLSessionWebSocketDelegate,
            {}
            unsafe impl ProtocolType for dyn NSURLSessionWebSocketDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSURLSessionWebSocketDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSURLSessionWebSocketDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSURLSessionWebSocketDelegate,
            {
                const __INNER: () = ();
            }
            extern "C" {
                pub static NSURLSessionDownloadTaskResumeData: &'static NSString;
            }
            extern "C" {
                pub static NSURLSessionUploadTaskResumeData: &'static NSString;
            }
            #[repr(transparent)]
            pub struct NSURLSessionTaskMetricsResourceFetchType(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSURLSessionTaskMetricsResourceFetchType {
                #[inline]
                fn clone(&self) -> NSURLSessionTaskMetricsResourceFetchType {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSURLSessionTaskMetricsResourceFetchType {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSURLSessionTaskMetricsResourceFetchType {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSURLSessionTaskMetricsResourceFetchType",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSURLSessionTaskMetricsResourceFetchType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSURLSessionTaskMetricsResourceFetchType {
                #[inline]
                fn eq(&self, other: &NSURLSessionTaskMetricsResourceFetchType) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq
            for NSURLSessionTaskMetricsResourceFetchType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSURLSessionTaskMetricsResourceFetchType {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSURLSessionTaskMetricsResourceFetchType {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSURLSessionTaskMetricsResourceFetchType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSURLSessionTaskMetricsResourceFetchType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSURLSessionTaskMetricsResourceFetchType {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSURLSessionTaskMetricsResourceFetchType,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSURLSessionTaskMetricsResourceFetchType {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSURLSessionTaskMetricsResourceFetchType {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSURLSessionTaskMetricsResourceFetchType {
                #[doc(alias = "NSURLSessionTaskMetricsResourceFetchTypeUnknown")]
                #[allow(non_upper_case_globals)]
                pub const Unknown: Self = Self(0);
                #[doc(alias = "NSURLSessionTaskMetricsResourceFetchTypeNetworkLoad")]
                #[allow(non_upper_case_globals)]
                pub const NetworkLoad: Self = Self(1);
                #[doc(alias = "NSURLSessionTaskMetricsResourceFetchTypeServerPush")]
                #[allow(non_upper_case_globals)]
                pub const ServerPush: Self = Self(2);
                #[doc(alias = "NSURLSessionTaskMetricsResourceFetchTypeLocalCache")]
                #[allow(non_upper_case_globals)]
                pub const LocalCache: Self = Self(3);
            }
            #[repr(transparent)]
            pub struct NSURLSessionTaskMetricsDomainResolutionProtocol(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone
            for NSURLSessionTaskMetricsDomainResolutionProtocol {
                #[inline]
                fn clone(&self) -> NSURLSessionTaskMetricsDomainResolutionProtocol {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy
            for NSURLSessionTaskMetricsDomainResolutionProtocol {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSURLSessionTaskMetricsDomainResolutionProtocol {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSURLSessionTaskMetricsDomainResolutionProtocol",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSURLSessionTaskMetricsDomainResolutionProtocol {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq
            for NSURLSessionTaskMetricsDomainResolutionProtocol {
                #[inline]
                fn eq(
                    &self,
                    other: &NSURLSessionTaskMetricsDomainResolutionProtocol,
                ) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq
            for NSURLSessionTaskMetricsDomainResolutionProtocol {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSURLSessionTaskMetricsDomainResolutionProtocol {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSURLSessionTaskMetricsDomainResolutionProtocol {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd
            for NSURLSessionTaskMetricsDomainResolutionProtocol {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSURLSessionTaskMetricsDomainResolutionProtocol,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSURLSessionTaskMetricsDomainResolutionProtocol {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSURLSessionTaskMetricsDomainResolutionProtocol,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode
            for NSURLSessionTaskMetricsDomainResolutionProtocol {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode
            for NSURLSessionTaskMetricsDomainResolutionProtocol {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSURLSessionTaskMetricsDomainResolutionProtocol {
                #[doc(alias = "NSURLSessionTaskMetricsDomainResolutionProtocolUnknown")]
                #[allow(non_upper_case_globals)]
                pub const Unknown: Self = Self(0);
                #[doc(alias = "NSURLSessionTaskMetricsDomainResolutionProtocolUDP")]
                #[allow(non_upper_case_globals)]
                pub const UDP: Self = Self(1);
                #[doc(alias = "NSURLSessionTaskMetricsDomainResolutionProtocolTCP")]
                #[allow(non_upper_case_globals)]
                pub const TCP: Self = Self(2);
                #[doc(alias = "NSURLSessionTaskMetricsDomainResolutionProtocolTLS")]
                #[allow(non_upper_case_globals)]
                pub const TLS: Self = Self(3);
                #[doc(alias = "NSURLSessionTaskMetricsDomainResolutionProtocolHTTPS")]
                #[allow(non_upper_case_globals)]
                pub const HTTPS: Self = Self(4);
            }
        }
        #[path = "NSUUID.rs"]
        mod __NSUUID {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSUbiquitousKeyValueStore.rs"]
        mod __NSUbiquitousKeyValueStore {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSUbiquitousKeyValueStoreDidChangeExternallyNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSUbiquitousKeyValueStoreChangeReasonKey: &'static NSString;
            }
            extern "C" {
                pub static NSUbiquitousKeyValueStoreChangedKeysKey: &'static NSString;
            }
            pub const NSUbiquitousKeyValueStoreServerChange: NSInteger = 0;
            pub const NSUbiquitousKeyValueStoreInitialSyncChange: NSInteger = 1;
            pub const NSUbiquitousKeyValueStoreQuotaViolationChange: NSInteger = 2;
            pub const NSUbiquitousKeyValueStoreAccountChange: NSInteger = 3;
        }
        #[path = "NSUndoManager.rs"]
        mod __NSUndoManager {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub static NSUndoCloseGroupingRunLoopOrdering: NSUInteger = 350000;
            extern "C" {
                pub static NSUndoManagerGroupIsDiscardableKey: &'static NSString;
            }
            extern "C" {
                pub static NSUndoManagerCheckpointNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSUndoManagerWillUndoChangeNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSUndoManagerWillRedoChangeNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSUndoManagerDidUndoChangeNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSUndoManagerDidRedoChangeNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSUndoManagerDidOpenUndoGroupNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSUndoManagerWillCloseUndoGroupNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSUndoManagerDidCloseUndoGroupNotification: &'static NSNotificationName;
            }
        }
        #[path = "NSUnit.rs"]
        mod __NSUnit {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSUserActivity.rs"]
        mod __NSUserActivity {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[cfg(feature = "Foundation_NSString")]
            pub type NSUserActivityPersistentIdentifier = NSString;
            extern "C" {
                pub static NSUserActivityTypeBrowsingWeb: &'static NSString;
            }
            pub unsafe trait NSUserActivityDelegate: NSObjectProtocol {}
            unsafe impl<T> NSUserActivityDelegate for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSUserActivityDelegate,
            {}
            unsafe impl ProtocolType for dyn NSUserActivityDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSUserActivityDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSUserActivityDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSUserActivityDelegate,
            {
                const __INNER: () = ();
            }
        }
        #[path = "NSUserDefaults.rs"]
        mod __NSUserDefaults {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub static NSGlobalDomain: &'static NSString;
            }
            extern "C" {
                pub static NSArgumentDomain: &'static NSString;
            }
            extern "C" {
                pub static NSRegistrationDomain: &'static NSString;
            }
            extern "C" {
                pub static NSUserDefaultsSizeLimitExceededNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSUbiquitousUserDefaultsNoCloudAccountNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSUbiquitousUserDefaultsDidChangeAccountsNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSUbiquitousUserDefaultsCompletedInitialSyncNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSUserDefaultsDidChangeNotification: &'static NSNotificationName;
            }
            extern "C" {
                pub static NSWeekDayNameArray: &'static NSString;
            }
            extern "C" {
                pub static NSShortWeekDayNameArray: &'static NSString;
            }
            extern "C" {
                pub static NSMonthNameArray: &'static NSString;
            }
            extern "C" {
                pub static NSShortMonthNameArray: &'static NSString;
            }
            extern "C" {
                pub static NSTimeFormatString: &'static NSString;
            }
            extern "C" {
                pub static NSDateFormatString: &'static NSString;
            }
            extern "C" {
                pub static NSTimeDateFormatString: &'static NSString;
            }
            extern "C" {
                pub static NSShortTimeDateFormatString: &'static NSString;
            }
            extern "C" {
                pub static NSCurrencySymbol: &'static NSString;
            }
            extern "C" {
                pub static NSDecimalSeparator: &'static NSString;
            }
            extern "C" {
                pub static NSThousandsSeparator: &'static NSString;
            }
            extern "C" {
                pub static NSDecimalDigits: &'static NSString;
            }
            extern "C" {
                pub static NSAMPMDesignation: &'static NSString;
            }
            extern "C" {
                pub static NSHourNameDesignations: &'static NSString;
            }
            extern "C" {
                pub static NSYearMonthWeekDesignations: &'static NSString;
            }
            extern "C" {
                pub static NSEarlierTimeDesignations: &'static NSString;
            }
            extern "C" {
                pub static NSLaterTimeDesignations: &'static NSString;
            }
            extern "C" {
                pub static NSThisDayDesignations: &'static NSString;
            }
            extern "C" {
                pub static NSNextDayDesignations: &'static NSString;
            }
            extern "C" {
                pub static NSNextNextDayDesignations: &'static NSString;
            }
            extern "C" {
                pub static NSPriorDayDesignations: &'static NSString;
            }
            extern "C" {
                pub static NSDateTimeOrdering: &'static NSString;
            }
            extern "C" {
                pub static NSInternationalCurrencyString: &'static NSString;
            }
            extern "C" {
                pub static NSShortDateFormatString: &'static NSString;
            }
            extern "C" {
                pub static NSPositiveCurrencyFormatString: &'static NSString;
            }
            extern "C" {
                pub static NSNegativeCurrencyFormatString: &'static NSString;
            }
        }
        #[path = "NSUserNotification.rs"]
        mod __NSUserNotification {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[deprecated = "All NSUserNotifications API should be replaced with UserNotifications.frameworks API"]
            #[repr(transparent)]
            pub struct NSUserNotificationActivationType(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSUserNotificationActivationType {
                #[inline]
                fn clone(&self) -> NSUserNotificationActivationType {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSUserNotificationActivationType {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSUserNotificationActivationType {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSUserNotificationActivationType",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSUserNotificationActivationType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSUserNotificationActivationType {
                #[inline]
                fn eq(&self, other: &NSUserNotificationActivationType) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSUserNotificationActivationType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSUserNotificationActivationType {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSUserNotificationActivationType {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSUserNotificationActivationType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSUserNotificationActivationType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSUserNotificationActivationType {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSUserNotificationActivationType,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSUserNotificationActivationType {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSUserNotificationActivationType {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSUserNotificationActivationType {
                #[deprecated = "All NSUserNotifications API should be replaced with UserNotifications.frameworks API"]
                #[doc(alias = "NSUserNotificationActivationTypeNone")]
                #[allow(non_upper_case_globals)]
                pub const None: Self = Self(0);
                #[deprecated = "All NSUserNotifications API should be replaced with UserNotifications.frameworks API"]
                #[doc(alias = "NSUserNotificationActivationTypeContentsClicked")]
                #[allow(non_upper_case_globals)]
                pub const ContentsClicked: Self = Self(1);
                #[deprecated = "All NSUserNotifications API should be replaced with UserNotifications.frameworks API"]
                #[doc(alias = "NSUserNotificationActivationTypeActionButtonClicked")]
                #[allow(non_upper_case_globals)]
                pub const ActionButtonClicked: Self = Self(2);
                #[doc(alias = "NSUserNotificationActivationTypeReplied")]
                #[allow(non_upper_case_globals)]
                pub const Replied: Self = Self(3);
                #[doc(alias = "NSUserNotificationActivationTypeAdditionalActionClicked")]
                #[allow(non_upper_case_globals)]
                pub const AdditionalActionClicked: Self = Self(4);
            }
            extern "C" {
                pub static NSUserNotificationDefaultSoundName: &'static NSString;
            }
            pub unsafe trait NSUserNotificationCenterDelegate: NSObjectProtocol {}
            unsafe impl<T> NSUserNotificationCenterDelegate
            for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSUserNotificationCenterDelegate,
            {}
            unsafe impl ProtocolType for dyn NSUserNotificationCenterDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSUserNotificationCenterDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSUserNotificationCenterDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSUserNotificationCenterDelegate,
            {
                const __INNER: () = ();
            }
        }
        #[path = "NSUserScriptTask.rs"]
        mod __NSUserScriptTask {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSValue.rs"]
        mod __NSValue {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSValueTransformer.rs"]
        mod __NSValueTransformer {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub type NSValueTransformerName = NSString;
            extern "C" {
                pub static NSNegateBooleanTransformerName: &'static NSValueTransformerName;
            }
            extern "C" {
                pub static NSIsNilTransformerName: &'static NSValueTransformerName;
            }
            extern "C" {
                pub static NSIsNotNilTransformerName: &'static NSValueTransformerName;
            }
            extern "C" {
                pub static NSUnarchiveFromDataTransformerName: &'static NSValueTransformerName;
            }
            extern "C" {
                pub static NSKeyedUnarchiveFromDataTransformerName: &'static NSValueTransformerName;
            }
            extern "C" {
                pub static NSSecureUnarchiveFromDataTransformerName: &'static NSValueTransformerName;
            }
        }
        #[path = "NSXMLDTD.rs"]
        mod __NSXMLDTD {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSXMLDTDNode.rs"]
        mod __NSXMLDTDNode {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSXMLDTDNodeKind(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSXMLDTDNodeKind {
                #[inline]
                fn clone(&self) -> NSXMLDTDNodeKind {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSXMLDTDNodeKind {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSXMLDTDNodeKind {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSXMLDTDNodeKind",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSXMLDTDNodeKind {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSXMLDTDNodeKind {
                #[inline]
                fn eq(&self, other: &NSXMLDTDNodeKind) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSXMLDTDNodeKind {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSXMLDTDNodeKind {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSXMLDTDNodeKind {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSXMLDTDNodeKind {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSXMLDTDNodeKind,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSXMLDTDNodeKind {
                #[inline]
                fn cmp(&self, other: &NSXMLDTDNodeKind) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSXMLDTDNodeKind {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSXMLDTDNodeKind {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSXMLDTDNodeKind {
                #[allow(non_upper_case_globals)]
                pub const NSXMLEntityGeneralKind: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSXMLEntityParsedKind: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSXMLEntityUnparsedKind: Self = Self(3);
                #[allow(non_upper_case_globals)]
                pub const NSXMLEntityParameterKind: Self = Self(4);
                #[allow(non_upper_case_globals)]
                pub const NSXMLEntityPredefined: Self = Self(5);
                #[allow(non_upper_case_globals)]
                pub const NSXMLAttributeCDATAKind: Self = Self(6);
                #[allow(non_upper_case_globals)]
                pub const NSXMLAttributeIDKind: Self = Self(7);
                #[allow(non_upper_case_globals)]
                pub const NSXMLAttributeIDRefKind: Self = Self(8);
                #[allow(non_upper_case_globals)]
                pub const NSXMLAttributeIDRefsKind: Self = Self(9);
                #[allow(non_upper_case_globals)]
                pub const NSXMLAttributeEntityKind: Self = Self(10);
                #[allow(non_upper_case_globals)]
                pub const NSXMLAttributeEntitiesKind: Self = Self(11);
                #[allow(non_upper_case_globals)]
                pub const NSXMLAttributeNMTokenKind: Self = Self(12);
                #[allow(non_upper_case_globals)]
                pub const NSXMLAttributeNMTokensKind: Self = Self(13);
                #[allow(non_upper_case_globals)]
                pub const NSXMLAttributeEnumerationKind: Self = Self(14);
                #[allow(non_upper_case_globals)]
                pub const NSXMLAttributeNotationKind: Self = Self(15);
                #[allow(non_upper_case_globals)]
                pub const NSXMLElementDeclarationUndefinedKind: Self = Self(16);
                #[allow(non_upper_case_globals)]
                pub const NSXMLElementDeclarationEmptyKind: Self = Self(17);
                #[allow(non_upper_case_globals)]
                pub const NSXMLElementDeclarationAnyKind: Self = Self(18);
                #[allow(non_upper_case_globals)]
                pub const NSXMLElementDeclarationMixedKind: Self = Self(19);
                #[allow(non_upper_case_globals)]
                pub const NSXMLElementDeclarationElementKind: Self = Self(20);
            }
        }
        #[path = "NSXMLDocument.rs"]
        mod __NSXMLDocument {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSXMLDocumentContentKind(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSXMLDocumentContentKind {
                #[inline]
                fn clone(&self) -> NSXMLDocumentContentKind {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSXMLDocumentContentKind {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSXMLDocumentContentKind {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSXMLDocumentContentKind",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSXMLDocumentContentKind {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSXMLDocumentContentKind {
                #[inline]
                fn eq(&self, other: &NSXMLDocumentContentKind) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSXMLDocumentContentKind {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSXMLDocumentContentKind {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSXMLDocumentContentKind {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSXMLDocumentContentKind {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSXMLDocumentContentKind,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSXMLDocumentContentKind {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSXMLDocumentContentKind,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSXMLDocumentContentKind {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSXMLDocumentContentKind {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSXMLDocumentContentKind {
                #[allow(non_upper_case_globals)]
                pub const NSXMLDocumentXMLKind: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSXMLDocumentXHTMLKind: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSXMLDocumentHTMLKind: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSXMLDocumentTextKind: Self = Self(3);
            }
        }
        #[path = "NSXMLElement.rs"]
        mod __NSXMLElement {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
        }
        #[path = "NSXMLNode.rs"]
        mod __NSXMLNode {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSXMLNodeKind(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSXMLNodeKind {
                #[inline]
                fn clone(&self) -> NSXMLNodeKind {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSXMLNodeKind {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSXMLNodeKind {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSXMLNodeKind",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSXMLNodeKind {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSXMLNodeKind {
                #[inline]
                fn eq(&self, other: &NSXMLNodeKind) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSXMLNodeKind {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSXMLNodeKind {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSXMLNodeKind {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSXMLNodeKind {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSXMLNodeKind,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSXMLNodeKind {
                #[inline]
                fn cmp(&self, other: &NSXMLNodeKind) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSXMLNodeKind {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSXMLNodeKind {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSXMLNodeKind {
                #[allow(non_upper_case_globals)]
                pub const NSXMLInvalidKind: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSXMLDocumentKind: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSXMLElementKind: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSXMLAttributeKind: Self = Self(3);
                #[allow(non_upper_case_globals)]
                pub const NSXMLNamespaceKind: Self = Self(4);
                #[allow(non_upper_case_globals)]
                pub const NSXMLProcessingInstructionKind: Self = Self(5);
                #[allow(non_upper_case_globals)]
                pub const NSXMLCommentKind: Self = Self(6);
                #[allow(non_upper_case_globals)]
                pub const NSXMLTextKind: Self = Self(7);
                #[allow(non_upper_case_globals)]
                pub const NSXMLDTDKind: Self = Self(8);
                #[allow(non_upper_case_globals)]
                pub const NSXMLEntityDeclarationKind: Self = Self(9);
                #[allow(non_upper_case_globals)]
                pub const NSXMLAttributeDeclarationKind: Self = Self(10);
                #[allow(non_upper_case_globals)]
                pub const NSXMLElementDeclarationKind: Self = Self(11);
                #[allow(non_upper_case_globals)]
                pub const NSXMLNotationDeclarationKind: Self = Self(12);
            }
        }
        #[path = "NSXMLNodeOptions.rs"]
        mod __NSXMLNodeOptions {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSXMLNodeOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSXMLNodeOptions {
                #[inline]
                fn clone(&self) -> NSXMLNodeOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSXMLNodeOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSXMLNodeOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSXMLNodeOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSXMLNodeOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSXMLNodeOptions {
                #[inline]
                fn eq(&self, other: &NSXMLNodeOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSXMLNodeOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSXMLNodeOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSXMLNodeOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSXMLNodeOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSXMLNodeOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSXMLNodeOptions {
                #[inline]
                fn cmp(&self, other: &NSXMLNodeOptions) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSXMLNodeOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSXMLNodeOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSXMLNodeOptions {
                #[doc(alias = "NSXMLNodeOptionsNone")]
                #[allow(non_upper_case_globals)]
                pub const None: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSXMLNodeIsCDATA: Self = Self(1 << 0);
                #[allow(non_upper_case_globals)]
                pub const NSXMLNodeExpandEmptyElement: Self = Self(1 << 1);
                #[allow(non_upper_case_globals)]
                pub const NSXMLNodeCompactEmptyElement: Self = Self(1 << 2);
                #[allow(non_upper_case_globals)]
                pub const NSXMLNodeUseSingleQuotes: Self = Self(1 << 3);
                #[allow(non_upper_case_globals)]
                pub const NSXMLNodeUseDoubleQuotes: Self = Self(1 << 4);
                #[allow(non_upper_case_globals)]
                pub const NSXMLNodeNeverEscapeContents: Self = Self(1 << 5);
                #[allow(non_upper_case_globals)]
                pub const NSXMLDocumentTidyHTML: Self = Self(1 << 9);
                #[allow(non_upper_case_globals)]
                pub const NSXMLDocumentTidyXML: Self = Self(1 << 10);
                #[allow(non_upper_case_globals)]
                pub const NSXMLDocumentValidate: Self = Self(1 << 13);
                #[allow(non_upper_case_globals)]
                pub const NSXMLNodeLoadExternalEntitiesAlways: Self = Self(1 << 14);
                #[allow(non_upper_case_globals)]
                pub const NSXMLNodeLoadExternalEntitiesSameOriginOnly: Self = Self(
                    1 << 15,
                );
                #[allow(non_upper_case_globals)]
                pub const NSXMLNodeLoadExternalEntitiesNever: Self = Self(1 << 19);
                #[allow(non_upper_case_globals)]
                pub const NSXMLDocumentXInclude: Self = Self(1 << 16);
                #[allow(non_upper_case_globals)]
                pub const NSXMLNodePrettyPrint: Self = Self(1 << 17);
                #[allow(non_upper_case_globals)]
                pub const NSXMLDocumentIncludeContentTypeDeclaration: Self = Self(
                    1 << 18,
                );
                #[allow(non_upper_case_globals)]
                pub const NSXMLNodePreserveNamespaceOrder: Self = Self(1 << 20);
                #[allow(non_upper_case_globals)]
                pub const NSXMLNodePreserveAttributeOrder: Self = Self(1 << 21);
                #[allow(non_upper_case_globals)]
                pub const NSXMLNodePreserveEntities: Self = Self(1 << 22);
                #[allow(non_upper_case_globals)]
                pub const NSXMLNodePreservePrefixes: Self = Self(1 << 23);
                #[allow(non_upper_case_globals)]
                pub const NSXMLNodePreserveCDATA: Self = Self(1 << 24);
                #[allow(non_upper_case_globals)]
                pub const NSXMLNodePreserveWhitespace: Self = Self(1 << 25);
                #[allow(non_upper_case_globals)]
                pub const NSXMLNodePreserveDTD: Self = Self(1 << 26);
                #[allow(non_upper_case_globals)]
                pub const NSXMLNodePreserveCharacterReferences: Self = Self(1 << 27);
                #[allow(non_upper_case_globals)]
                pub const NSXMLNodePromoteSignificantWhitespace: Self = Self(1 << 28);
                #[allow(non_upper_case_globals)]
                pub const NSXMLNodePreserveEmptyElements: Self = Self(
                    NSXMLNodeOptions::NSXMLNodeExpandEmptyElement.0
                        | NSXMLNodeOptions::NSXMLNodeCompactEmptyElement.0,
                );
                #[allow(non_upper_case_globals)]
                pub const NSXMLNodePreserveQuotes: Self = Self(
                    NSXMLNodeOptions::NSXMLNodeUseSingleQuotes.0
                        | NSXMLNodeOptions::NSXMLNodeUseDoubleQuotes.0,
                );
                #[allow(non_upper_case_globals)]
                pub const NSXMLNodePreserveAll: Self = Self(
                    NSXMLNodeOptions::NSXMLNodePreserveNamespaceOrder.0
                        | NSXMLNodeOptions::NSXMLNodePreserveAttributeOrder.0
                        | NSXMLNodeOptions::NSXMLNodePreserveEntities.0
                        | NSXMLNodeOptions::NSXMLNodePreservePrefixes.0
                        | NSXMLNodeOptions::NSXMLNodePreserveCDATA.0
                        | NSXMLNodeOptions::NSXMLNodePreserveEmptyElements.0
                        | NSXMLNodeOptions::NSXMLNodePreserveQuotes.0
                        | NSXMLNodeOptions::NSXMLNodePreserveWhitespace.0
                        | NSXMLNodeOptions::NSXMLNodePreserveDTD.0
                        | NSXMLNodeOptions::NSXMLNodePreserveCharacterReferences.0
                        | 0xFFF00000,
                );
            }
        }
        #[path = "NSXMLParser.rs"]
        mod __NSXMLParser {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            #[repr(transparent)]
            pub struct NSXMLParserExternalEntityResolvingPolicy(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSXMLParserExternalEntityResolvingPolicy {
                #[inline]
                fn clone(&self) -> NSXMLParserExternalEntityResolvingPolicy {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSXMLParserExternalEntityResolvingPolicy {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSXMLParserExternalEntityResolvingPolicy {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSXMLParserExternalEntityResolvingPolicy",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for NSXMLParserExternalEntityResolvingPolicy {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSXMLParserExternalEntityResolvingPolicy {
                #[inline]
                fn eq(&self, other: &NSXMLParserExternalEntityResolvingPolicy) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq
            for NSXMLParserExternalEntityResolvingPolicy {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSXMLParserExternalEntityResolvingPolicy {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSXMLParserExternalEntityResolvingPolicy {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSXMLParserExternalEntityResolvingPolicy {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSXMLParserExternalEntityResolvingPolicy,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSXMLParserExternalEntityResolvingPolicy {
                #[inline]
                fn cmp(
                    &self,
                    other: &NSXMLParserExternalEntityResolvingPolicy,
                ) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSXMLParserExternalEntityResolvingPolicy {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSXMLParserExternalEntityResolvingPolicy {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSXMLParserExternalEntityResolvingPolicy {
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserResolveExternalEntitiesNever: Self = Self(0);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserResolveExternalEntitiesNoNetwork: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserResolveExternalEntitiesSameOriginOnly: Self = Self(
                    2,
                );
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserResolveExternalEntitiesAlways: Self = Self(3);
            }
            pub unsafe trait NSXMLParserDelegate: NSObjectProtocol {}
            unsafe impl<T> NSXMLParserDelegate for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSXMLParserDelegate,
            {}
            unsafe impl ProtocolType for dyn NSXMLParserDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSXMLParserDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T> for dyn NSXMLParserDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSXMLParserDelegate,
            {
                const __INNER: () = ();
            }
            extern "C" {
                pub static NSXMLParserErrorDomain: &'static NSErrorDomain;
            }
            #[repr(transparent)]
            pub struct NSXMLParserError(pub NSInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSXMLParserError {
                #[inline]
                fn clone(&self) -> NSXMLParserError {
                    let _: ::core::clone::AssertParamIsClone<NSInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSXMLParserError {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSXMLParserError {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSXMLParserError",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSXMLParserError {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSXMLParserError {
                #[inline]
                fn eq(&self, other: &NSXMLParserError) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSXMLParserError {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSXMLParserError {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSXMLParserError {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSXMLParserError {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSXMLParserError,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSXMLParserError {
                #[inline]
                fn cmp(&self, other: &NSXMLParserError) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSXMLParserError {
                const ENCODING: objc2::Encoding = <NSInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSXMLParserError {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSXMLParserError {
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserInternalError: Self = Self(1);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserOutOfMemoryError: Self = Self(2);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserDocumentStartError: Self = Self(3);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserEmptyDocumentError: Self = Self(4);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserPrematureDocumentEndError: Self = Self(5);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserInvalidHexCharacterRefError: Self = Self(6);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserInvalidDecimalCharacterRefError: Self = Self(7);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserInvalidCharacterRefError: Self = Self(8);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserInvalidCharacterError: Self = Self(9);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserCharacterRefAtEOFError: Self = Self(10);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserCharacterRefInPrologError: Self = Self(11);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserCharacterRefInEpilogError: Self = Self(12);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserCharacterRefInDTDError: Self = Self(13);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserEntityRefAtEOFError: Self = Self(14);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserEntityRefInPrologError: Self = Self(15);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserEntityRefInEpilogError: Self = Self(16);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserEntityRefInDTDError: Self = Self(17);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserParsedEntityRefAtEOFError: Self = Self(18);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserParsedEntityRefInPrologError: Self = Self(19);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserParsedEntityRefInEpilogError: Self = Self(20);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserParsedEntityRefInInternalSubsetError: Self = Self(
                    21,
                );
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserEntityReferenceWithoutNameError: Self = Self(22);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserEntityReferenceMissingSemiError: Self = Self(23);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserParsedEntityRefNoNameError: Self = Self(24);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserParsedEntityRefMissingSemiError: Self = Self(25);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserUndeclaredEntityError: Self = Self(26);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserUnparsedEntityError: Self = Self(28);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserEntityIsExternalError: Self = Self(29);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserEntityIsParameterError: Self = Self(30);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserUnknownEncodingError: Self = Self(31);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserEncodingNotSupportedError: Self = Self(32);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserStringNotStartedError: Self = Self(33);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserStringNotClosedError: Self = Self(34);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserNamespaceDeclarationError: Self = Self(35);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserEntityNotStartedError: Self = Self(36);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserEntityNotFinishedError: Self = Self(37);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserLessThanSymbolInAttributeError: Self = Self(38);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserAttributeNotStartedError: Self = Self(39);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserAttributeNotFinishedError: Self = Self(40);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserAttributeHasNoValueError: Self = Self(41);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserAttributeRedefinedError: Self = Self(42);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserLiteralNotStartedError: Self = Self(43);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserLiteralNotFinishedError: Self = Self(44);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserCommentNotFinishedError: Self = Self(45);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserProcessingInstructionNotStartedError: Self = Self(
                    46,
                );
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserProcessingInstructionNotFinishedError: Self = Self(
                    47,
                );
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserNotationNotStartedError: Self = Self(48);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserNotationNotFinishedError: Self = Self(49);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserAttributeListNotStartedError: Self = Self(50);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserAttributeListNotFinishedError: Self = Self(51);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserMixedContentDeclNotStartedError: Self = Self(52);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserMixedContentDeclNotFinishedError: Self = Self(53);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserElementContentDeclNotStartedError: Self = Self(54);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserElementContentDeclNotFinishedError: Self = Self(55);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserXMLDeclNotStartedError: Self = Self(56);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserXMLDeclNotFinishedError: Self = Self(57);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserConditionalSectionNotStartedError: Self = Self(58);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserConditionalSectionNotFinishedError: Self = Self(59);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserExternalSubsetNotFinishedError: Self = Self(60);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserDOCTYPEDeclNotFinishedError: Self = Self(61);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserMisplacedCDATAEndStringError: Self = Self(62);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserCDATANotFinishedError: Self = Self(63);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserMisplacedXMLDeclarationError: Self = Self(64);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserSpaceRequiredError: Self = Self(65);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserSeparatorRequiredError: Self = Self(66);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserNMTOKENRequiredError: Self = Self(67);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserNAMERequiredError: Self = Self(68);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserPCDATARequiredError: Self = Self(69);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserURIRequiredError: Self = Self(70);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserPublicIdentifierRequiredError: Self = Self(71);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserLTRequiredError: Self = Self(72);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserGTRequiredError: Self = Self(73);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserLTSlashRequiredError: Self = Self(74);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserEqualExpectedError: Self = Self(75);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserTagNameMismatchError: Self = Self(76);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserUnfinishedTagError: Self = Self(77);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserStandaloneValueError: Self = Self(78);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserInvalidEncodingNameError: Self = Self(79);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserCommentContainsDoubleHyphenError: Self = Self(80);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserInvalidEncodingError: Self = Self(81);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserExternalStandaloneEntityError: Self = Self(82);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserInvalidConditionalSectionError: Self = Self(83);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserEntityValueRequiredError: Self = Self(84);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserNotWellBalancedError: Self = Self(85);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserExtraContentError: Self = Self(86);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserInvalidCharacterInEntityError: Self = Self(87);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserParsedEntityRefInInternalError: Self = Self(88);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserEntityRefLoopError: Self = Self(89);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserEntityBoundaryError: Self = Self(90);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserInvalidURIError: Self = Self(91);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserURIFragmentError: Self = Self(92);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserNoDTDError: Self = Self(94);
                #[allow(non_upper_case_globals)]
                pub const NSXMLParserDelegateAbortedParseError: Self = Self(512);
            }
        }
        #[path = "NSXPCConnection.rs"]
        mod __NSXPCConnection {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            pub unsafe trait NSXPCProxyCreating {
                unsafe fn remoteObjectProxy(&self) -> Id<AnyObject>
                where
                    Self: ::objc2::__macro_helpers::Sized + ::objc2::Message,
                {
                    #[allow(unused_unsafe)]
                    unsafe {
                        {
                            <::objc2::__macro_helpers::Other as ::objc2::__macro_helpers::MsgSendId<
                                _,
                                _,
                            >>::send_message_id(
                                self,
                                {
                                    {
                                        static CACHED_SEL: ::objc2::__macro_helpers::CachedSel = ::objc2::__macro_helpers::CachedSel::new();
                                        #[allow(unused_unsafe)]
                                        unsafe { CACHED_SEL.get("remoteObjectProxy\u{0}") }
                                    }
                                },
                                (),
                            )
                        }
                    }
                }
            }
            unsafe impl<T> NSXPCProxyCreating for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSXPCProxyCreating,
            {}
            unsafe impl ProtocolType for dyn NSXPCProxyCreating {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSXPCProxyCreating";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T> for dyn NSXPCProxyCreating
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSXPCProxyCreating,
            {
                const __INNER: () = ();
            }
            #[repr(transparent)]
            pub struct NSXPCConnectionOptions(pub NSUInteger);
            #[automatically_derived]
            impl ::core::clone::Clone for NSXPCConnectionOptions {
                #[inline]
                fn clone(&self) -> NSXPCConnectionOptions {
                    let _: ::core::clone::AssertParamIsClone<NSUInteger>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NSXPCConnectionOptions {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NSXPCConnectionOptions {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NSXPCConnectionOptions",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NSXPCConnectionOptions {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NSXPCConnectionOptions {
                #[inline]
                fn eq(&self, other: &NSXPCConnectionOptions) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NSXPCConnectionOptions {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NSXPCConnectionOptions {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<NSUInteger>;
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NSXPCConnectionOptions {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NSXPCConnectionOptions {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NSXPCConnectionOptions,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NSXPCConnectionOptions {
                #[inline]
                fn cmp(&self, other: &NSXPCConnectionOptions) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::Encode for NSXPCConnectionOptions {
                const ENCODING: objc2::Encoding = <NSUInteger as objc2::Encode>::ENCODING;
            }
            #[cfg(feature = "objc2")]
            unsafe impl objc2::RefEncode for NSXPCConnectionOptions {
                const ENCODING_REF: objc2::Encoding = objc2::Encoding::Pointer(
                    &<Self as objc2::Encode>::ENCODING,
                );
            }
            impl NSXPCConnectionOptions {
                #[allow(non_upper_case_globals)]
                pub const NSXPCConnectionPrivileged: Self = Self(1 << 12);
            }
            pub unsafe trait NSXPCListenerDelegate: NSObjectProtocol {}
            unsafe impl<T> NSXPCListenerDelegate for ::objc2::runtime::ProtocolObject<T>
            where
                T: ?::objc2::__macro_helpers::Sized + NSXPCListenerDelegate,
            {}
            unsafe impl ProtocolType for dyn NSXPCListenerDelegate {
                const NAME: &'static ::objc2::__macro_helpers::str = "NSXPCListenerDelegate";
                const __INNER: () = ();
            }
            unsafe impl<T> ::objc2::runtime::ImplementedBy<T>
            for dyn NSXPCListenerDelegate
            where
                T: ?::objc2::__macro_helpers::Sized + ::objc2::Message
                    + NSXPCListenerDelegate,
            {
                const __INNER: () = ();
            }
        }
        #[path = "NSZone.rs"]
        mod __NSZone {
            //! This file has been automatically generated by `objc2`'s `header-translator`.
            //! DO NOT EDIT
            use crate::common::*;
            use crate::Foundation::*;
            extern "C" {
                pub fn NSDefaultMallocZone() -> NonNull<NSZone>;
            }
            extern "C" {
                pub fn NSCreateZone(
                    start_size: NSUInteger,
                    granularity: NSUInteger,
                    can_free: Bool,
                ) -> NonNull<NSZone>;
            }
            extern "C" {
                pub fn NSRecycleZone(zone: NonNull<NSZone>);
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSSetZoneName(zone: *mut NSZone, name: &NSString);
            }
            #[cfg(feature = "Foundation_NSString")]
            extern "C" {
                pub fn NSZoneName(zone: *mut NSZone) -> NonNull<NSString>;
            }
            extern "C" {
                pub fn NSZoneFromPointer(ptr: NonNull<c_void>) -> *mut NSZone;
            }
            extern "C" {
                pub fn NSZoneMalloc(
                    zone: *mut NSZone,
                    size: NSUInteger,
                ) -> NonNull<c_void>;
            }
            extern "C" {
                pub fn NSZoneCalloc(
                    zone: *mut NSZone,
                    num_elems: NSUInteger,
                    byte_size: NSUInteger,
                ) -> NonNull<c_void>;
            }
            extern "C" {
                pub fn NSZoneRealloc(
                    zone: *mut NSZone,
                    ptr: *mut c_void,
                    size: NSUInteger,
                ) -> NonNull<c_void>;
            }
            extern "C" {
                pub fn NSZoneFree(zone: *mut NSZone, ptr: NonNull<c_void>);
            }
            pub const NSScannedOption: NSUInteger = 1 << 0;
            pub const NSCollectorDisabledOption: NSUInteger = 1 << 1;
            extern "C" {
                pub fn NSAllocateCollectable(
                    size: NSUInteger,
                    options: NSUInteger,
                ) -> NonNull<c_void>;
            }
            extern "C" {
                pub fn NSReallocateCollectable(
                    ptr: *mut c_void,
                    size: NSUInteger,
                    options: NSUInteger,
                ) -> NonNull<c_void>;
            }
            extern "C" {
                pub fn NSPageSize() -> NSUInteger;
            }
            extern "C" {
                pub fn NSLogPageSize() -> NSUInteger;
            }
            extern "C" {
                pub fn NSRoundUpToMultipleOfPageSize(bytes: NSUInteger) -> NSUInteger;
            }
            extern "C" {
                pub fn NSRoundDownToMultipleOfPageSize(bytes: NSUInteger) -> NSUInteger;
            }
            extern "C" {
                pub fn NSAllocateMemoryPages(bytes: NSUInteger) -> NonNull<c_void>;
            }
            extern "C" {
                pub fn NSDeallocateMemoryPages(ptr: NonNull<c_void>, bytes: NSUInteger);
            }
            extern "C" {
                pub fn NSCopyMemoryPages(
                    source: NonNull<c_void>,
                    dest: NonNull<c_void>,
                    bytes: NSUInteger,
                );
            }
            #[deprecated = "Use NSProcessInfo instead"]
            extern "C" {
                pub fn NSRealMemoryAvailable() -> NSUInteger;
            }
        }
        pub use self::__FoundationErrors::NSBundleErrorMaximum;
        pub use self::__FoundationErrors::NSBundleErrorMinimum;
        pub use self::__FoundationErrors::NSBundleOnDemandResourceExceededMaximumSizeError;
        pub use self::__FoundationErrors::NSBundleOnDemandResourceInvalidTagError;
        pub use self::__FoundationErrors::NSBundleOnDemandResourceOutOfSpaceError;
        pub use self::__FoundationErrors::NSCloudSharingConflictError;
        pub use self::__FoundationErrors::NSCloudSharingErrorMaximum;
        pub use self::__FoundationErrors::NSCloudSharingErrorMinimum;
        pub use self::__FoundationErrors::NSCloudSharingNetworkFailureError;
        pub use self::__FoundationErrors::NSCloudSharingNoPermissionError;
        pub use self::__FoundationErrors::NSCloudSharingOtherError;
        pub use self::__FoundationErrors::NSCloudSharingQuotaExceededError;
        pub use self::__FoundationErrors::NSCloudSharingTooManyParticipantsError;
        pub use self::__FoundationErrors::NSCoderErrorMaximum;
        pub use self::__FoundationErrors::NSCoderErrorMinimum;
        pub use self::__FoundationErrors::NSCoderInvalidValueError;
        pub use self::__FoundationErrors::NSCoderReadCorruptError;
        pub use self::__FoundationErrors::NSCoderValueNotFoundError;
        pub use self::__FoundationErrors::NSCompressionErrorMaximum;
        pub use self::__FoundationErrors::NSCompressionErrorMinimum;
        pub use self::__FoundationErrors::NSCompressionFailedError;
        pub use self::__FoundationErrors::NSDecompressionFailedError;
        pub use self::__FoundationErrors::NSExecutableArchitectureMismatchError;
        pub use self::__FoundationErrors::NSExecutableErrorMaximum;
        pub use self::__FoundationErrors::NSExecutableErrorMinimum;
        pub use self::__FoundationErrors::NSExecutableLinkError;
        pub use self::__FoundationErrors::NSExecutableLoadError;
        pub use self::__FoundationErrors::NSExecutableNotLoadableError;
        pub use self::__FoundationErrors::NSExecutableRuntimeMismatchError;
        pub use self::__FoundationErrors::NSFeatureUnsupportedError;
        pub use self::__FoundationErrors::NSFileErrorMaximum;
        pub use self::__FoundationErrors::NSFileErrorMinimum;
        pub use self::__FoundationErrors::NSFileLockingError;
        pub use self::__FoundationErrors::NSFileManagerUnmountBusyError;
        pub use self::__FoundationErrors::NSFileManagerUnmountUnknownError;
        pub use self::__FoundationErrors::NSFileNoSuchFileError;
        pub use self::__FoundationErrors::NSFileReadCorruptFileError;
        pub use self::__FoundationErrors::NSFileReadInapplicableStringEncodingError;
        pub use self::__FoundationErrors::NSFileReadInvalidFileNameError;
        pub use self::__FoundationErrors::NSFileReadNoPermissionError;
        pub use self::__FoundationErrors::NSFileReadNoSuchFileError;
        pub use self::__FoundationErrors::NSFileReadTooLargeError;
        pub use self::__FoundationErrors::NSFileReadUnknownError;
        pub use self::__FoundationErrors::NSFileReadUnknownStringEncodingError;
        pub use self::__FoundationErrors::NSFileReadUnsupportedSchemeError;
        pub use self::__FoundationErrors::NSFileWriteFileExistsError;
        pub use self::__FoundationErrors::NSFileWriteInapplicableStringEncodingError;
        pub use self::__FoundationErrors::NSFileWriteInvalidFileNameError;
        pub use self::__FoundationErrors::NSFileWriteNoPermissionError;
        pub use self::__FoundationErrors::NSFileWriteOutOfSpaceError;
        pub use self::__FoundationErrors::NSFileWriteUnknownError;
        pub use self::__FoundationErrors::NSFileWriteUnsupportedSchemeError;
        pub use self::__FoundationErrors::NSFileWriteVolumeReadOnlyError;
        pub use self::__FoundationErrors::NSFormattingError;
        pub use self::__FoundationErrors::NSFormattingErrorMaximum;
        pub use self::__FoundationErrors::NSFormattingErrorMinimum;
        pub use self::__FoundationErrors::NSKeyValueValidationError;
        pub use self::__FoundationErrors::NSPropertyListErrorMaximum;
        pub use self::__FoundationErrors::NSPropertyListErrorMinimum;
        pub use self::__FoundationErrors::NSPropertyListReadCorruptError;
        pub use self::__FoundationErrors::NSPropertyListReadStreamError;
        pub use self::__FoundationErrors::NSPropertyListReadUnknownVersionError;
        pub use self::__FoundationErrors::NSPropertyListWriteInvalidError;
        pub use self::__FoundationErrors::NSPropertyListWriteStreamError;
        pub use self::__FoundationErrors::NSUbiquitousFileErrorMaximum;
        pub use self::__FoundationErrors::NSUbiquitousFileErrorMinimum;
        pub use self::__FoundationErrors::NSUbiquitousFileNotUploadedDueToQuotaError;
        pub use self::__FoundationErrors::NSUbiquitousFileUbiquityServerNotAvailable;
        pub use self::__FoundationErrors::NSUbiquitousFileUnavailableError;
        pub use self::__FoundationErrors::NSUserActivityConnectionUnavailableError;
        pub use self::__FoundationErrors::NSUserActivityErrorMaximum;
        pub use self::__FoundationErrors::NSUserActivityErrorMinimum;
        pub use self::__FoundationErrors::NSUserActivityHandoffFailedError;
        pub use self::__FoundationErrors::NSUserActivityHandoffUserInfoTooLargeError;
        pub use self::__FoundationErrors::NSUserActivityRemoteApplicationTimedOutError;
        pub use self::__FoundationErrors::NSUserCancelledError;
        pub use self::__FoundationErrors::NSValidationErrorMaximum;
        pub use self::__FoundationErrors::NSValidationErrorMinimum;
        pub use self::__FoundationErrors::NSXPCConnectionCodeSigningRequirementFailure;
        pub use self::__FoundationErrors::NSXPCConnectionErrorMaximum;
        pub use self::__FoundationErrors::NSXPCConnectionErrorMinimum;
        pub use self::__FoundationErrors::NSXPCConnectionInterrupted;
        pub use self::__FoundationErrors::NSXPCConnectionInvalid;
        pub use self::__FoundationErrors::NSXPCConnectionReplyInvalid;
        pub use self::__NSAffineTransform::NSAffineTransformStruct;
        pub use self::__NSAppleEventDescriptor::NSAppleEventSendOptions;
        pub use self::__NSAppleEventManager::NSAppleEventManagerSuspensionID;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSAppleEventManager::NSAppleEventManagerWillProcessFirstEventNotification;
        pub use self::__NSAppleEventManager::NSAppleEventTimeOutDefault;
        pub use self::__NSAppleEventManager::NSAppleEventTimeOutNone;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSAppleScript::NSAppleScriptErrorAppName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSAppleScript::NSAppleScriptErrorBriefMessage;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSAppleScript::NSAppleScriptErrorMessage;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSAppleScript::NSAppleScriptErrorNumber;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSAppleScript::NSAppleScriptErrorRange;
        pub use self::__NSArchiver::NSObjectNSArchiverCallback;
        pub use self::__NSArray::NSBinarySearchingOptions;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSAttributedString::NSAlternateDescriptionAttributeName;
        pub use self::__NSAttributedString::NSAttributedStringEnumerationOptions;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSAttributedString::NSAttributedStringFormattingContextKey;
        pub use self::__NSAttributedString::NSAttributedStringFormattingOptions;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSAttributedString::NSAttributedStringKey;
        pub use self::__NSAttributedString::NSAttributedStringMarkdownInterpretedSyntax;
        pub use self::__NSAttributedString::NSAttributedStringMarkdownParsingFailurePolicy;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSAttributedString::NSImageURLAttributeName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSAttributedString::NSInflectionAgreementArgumentAttributeName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSAttributedString::NSInflectionAgreementConceptAttributeName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSAttributedString::NSInflectionAlternativeAttributeName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSAttributedString::NSInflectionConceptsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSAttributedString::NSInflectionReferentConceptAttributeName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSAttributedString::NSInflectionRuleAttributeName;
        pub use self::__NSAttributedString::NSInlinePresentationIntent;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSAttributedString::NSInlinePresentationIntentAttributeName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSAttributedString::NSLanguageIdentifierAttributeName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSAttributedString::NSMarkdownSourcePositionAttributeName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSAttributedString::NSMorphologyAttributeName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSAttributedString::NSPresentationIntentAttributeName;
        pub use self::__NSAttributedString::NSPresentationIntentKind;
        pub use self::__NSAttributedString::NSPresentationIntentTableColumnAlignment;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSAttributedString::NSReplacementIndexAttributeName;
        pub use self::__NSBackgroundActivityScheduler::NSBackgroundActivityCompletionHandler;
        pub use self::__NSBackgroundActivityScheduler::NSBackgroundActivityResult;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSBundle::NSBundleDidLoadNotification;
        pub use self::__NSBundle::NSBundleExecutableArchitectureARM64;
        pub use self::__NSBundle::NSBundleExecutableArchitectureI386;
        pub use self::__NSBundle::NSBundleExecutableArchitecturePPC;
        pub use self::__NSBundle::NSBundleExecutableArchitecturePPC64;
        pub use self::__NSBundle::NSBundleExecutableArchitectureX86_64;
        pub use self::__NSBundle::NSBundleResourceRequestLoadingPriorityUrgent;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSBundle::NSBundleResourceRequestLowDiskSpaceNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSBundle::NSLoadedClasses;
        pub use self::__NSByteCountFormatter::NSByteCountFormatterCountStyle;
        pub use self::__NSByteCountFormatter::NSByteCountFormatterUnits;
        pub use self::__NSByteOrder::NSSwappedDouble;
        pub use self::__NSByteOrder::NSSwappedFloat;
        pub use self::__NSCache::NSCacheDelegate;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSCalendar::NSCalendarDayChangedNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSCalendar::NSCalendarIdentifier;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSCalendar::NSCalendarIdentifierBuddhist;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSCalendar::NSCalendarIdentifierChinese;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSCalendar::NSCalendarIdentifierCoptic;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSCalendar::NSCalendarIdentifierEthiopicAmeteAlem;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSCalendar::NSCalendarIdentifierEthiopicAmeteMihret;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSCalendar::NSCalendarIdentifierGregorian;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSCalendar::NSCalendarIdentifierHebrew;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSCalendar::NSCalendarIdentifierISO8601;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSCalendar::NSCalendarIdentifierIndian;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSCalendar::NSCalendarIdentifierIslamic;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSCalendar::NSCalendarIdentifierIslamicCivil;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSCalendar::NSCalendarIdentifierIslamicTabular;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSCalendar::NSCalendarIdentifierIslamicUmmAlQura;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSCalendar::NSCalendarIdentifierJapanese;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSCalendar::NSCalendarIdentifierPersian;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSCalendar::NSCalendarIdentifierRepublicOfChina;
        pub use self::__NSCalendar::NSCalendarOptions;
        pub use self::__NSCalendar::NSCalendarUnit;
        pub use self::__NSCalendar::NSDateComponentUndefined;
        pub use self::__NSCalendar::NSUndefinedDateComponent;
        pub use self::__NSCharacterSet::NSOpenStepUnicodeReservedBase;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSClassDescription::NSClassDescriptionNeededForClassNotification;
        pub use self::__NSClassDescription::NSObjectNSClassDescriptionPrimitives;
        pub use self::__NSCoder::NSDecodingFailurePolicy;
        pub use self::__NSComparisonPredicate::NSComparisonPredicateModifier;
        pub use self::__NSComparisonPredicate::NSComparisonPredicateOptions;
        pub use self::__NSComparisonPredicate::NSPredicateOperatorType;
        pub use self::__NSCompoundPredicate::NSCompoundPredicateType;
        pub use self::__NSConnection::NSConnectionDelegate;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSConnection::NSConnectionDidDieNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSConnection::NSConnectionDidInitializeNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSConnection::NSConnectionReplyMode;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSConnection::NSFailedAuthenticationException;
        pub use self::__NSData::NSDataBase64DecodingOptions;
        pub use self::__NSData::NSDataBase64EncodingOptions;
        pub use self::__NSData::NSDataCompressionAlgorithm;
        pub use self::__NSData::NSDataReadingOptions;
        pub use self::__NSData::NSDataSearchOptions;
        pub use self::__NSData::NSDataWritingOptions;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSDate::NSSystemClockDidChangeNotification;
        pub use self::__NSDate::NSTimeInterval;
        pub use self::__NSDateComponentsFormatter::NSDateComponentsFormatterUnitsStyle;
        pub use self::__NSDateComponentsFormatter::NSDateComponentsFormatterZeroFormattingBehavior;
        pub use self::__NSDateFormatter::NSDateFormatterBehavior;
        pub use self::__NSDateFormatter::NSDateFormatterStyle;
        pub use self::__NSDateIntervalFormatter::NSDateIntervalFormatterStyle;
        pub use self::__NSDecimal::NSCalculationError;
        pub use self::__NSDecimal::NSDecimalAdd;
        pub use self::__NSDecimal::NSDecimalCompact;
        pub use self::__NSDecimal::NSDecimalCompare;
        pub use self::__NSDecimal::NSDecimalCopy;
        pub use self::__NSDecimal::NSDecimalDivide;
        pub use self::__NSDecimal::NSDecimalMultiply;
        pub use self::__NSDecimal::NSDecimalMultiplyByPowerOf10;
        pub use self::__NSDecimal::NSDecimalNormalize;
        pub use self::__NSDecimal::NSDecimalPower;
        pub use self::__NSDecimal::NSDecimalRound;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSDecimal::NSDecimalString;
        pub use self::__NSDecimal::NSDecimalSubtract;
        pub use self::__NSDecimal::NSRoundingMode;
        pub use self::__NSDecimalNumber::NSDecimalNumberBehaviors;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSDecimalNumber::NSDecimalNumberDivideByZeroException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSDecimalNumber::NSDecimalNumberExactnessException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSDecimalNumber::NSDecimalNumberOverflowException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSDecimalNumber::NSDecimalNumberUnderflowException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSDistributedNotificationCenter::NSDistributedNotificationCenterType;
        pub use self::__NSDistributedNotificationCenter::NSDistributedNotificationOptions;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSDistributedNotificationCenter::NSLocalNotificationCenterType;
        pub use self::__NSDistributedNotificationCenter::NSNotificationDeliverImmediately;
        pub use self::__NSDistributedNotificationCenter::NSNotificationPostToAllSessions;
        pub use self::__NSDistributedNotificationCenter::NSNotificationSuspensionBehavior;
        pub use self::__NSEnergyFormatter::NSEnergyFormatterUnit;
        pub use self::__NSEnumerator::NSFastEnumeration;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSError::NSCocoaErrorDomain;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSError::NSDebugDescriptionErrorKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSError::NSErrorDomain;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSError::NSErrorUserInfoKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSError::NSFilePathErrorKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSError::NSHelpAnchorErrorKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSError::NSLocalizedDescriptionKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSError::NSLocalizedFailureErrorKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSError::NSLocalizedFailureReasonErrorKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSError::NSLocalizedRecoveryOptionsErrorKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSError::NSLocalizedRecoverySuggestionErrorKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSError::NSMachErrorDomain;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSError::NSMultipleUnderlyingErrorsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSError::NSOSStatusErrorDomain;
        pub use self::__NSError::NSObjectNSErrorRecoveryAttempting;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSError::NSPOSIXErrorDomain;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSError::NSRecoveryAttempterErrorKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSError::NSStringEncodingErrorKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSError::NSURLErrorKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSError::NSUnderlyingErrorKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSException::NSAssertionHandlerKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSException::NSDestinationInvalidException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSException::NSGenericException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSException::NSInconsistentArchiveException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSException::NSInternalInconsistencyException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSException::NSInvalidArgumentException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSException::NSInvalidReceivePortException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSException::NSInvalidSendPortException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSException::NSMallocException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSException::NSObjectInaccessibleException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSException::NSObjectNotAvailableException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSException::NSOldStyleException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSException::NSPortReceiveException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSException::NSPortSendException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSException::NSPortTimeoutException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSException::NSRangeException;
        pub use self::__NSExpression::NSExpressionType;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSExtensionContext::NSExtensionHostDidBecomeActiveNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSExtensionContext::NSExtensionHostDidEnterBackgroundNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSExtensionContext::NSExtensionHostWillEnterForegroundNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSExtensionContext::NSExtensionHostWillResignActiveNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSExtensionContext::NSExtensionItemsAndErrorsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSExtensionItem::NSExtensionItemAttachmentsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSExtensionItem::NSExtensionItemAttributedContentTextKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSExtensionItem::NSExtensionItemAttributedTitleKey;
        pub use self::__NSExtensionRequestHandling::NSExtensionRequestHandling;
        pub use self::__NSFileCoordinator::NSFileCoordinatorReadingOptions;
        pub use self::__NSFileCoordinator::NSFileCoordinatorWritingOptions;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileHandle::NSFileHandleConnectionAcceptedNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileHandle::NSFileHandleDataAvailableNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileHandle::NSFileHandleNotificationDataItem;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileHandle::NSFileHandleNotificationFileHandleItem;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileHandle::NSFileHandleNotificationMonitorModes;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileHandle::NSFileHandleOperationException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileHandle::NSFileHandleReadCompletionNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileHandle::NSFileHandleReadToEndOfFileCompletionNotification;
        pub use self::__NSFileManager::NSDirectoryEnumerationOptions;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileAppendOnly;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileAttributeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileAttributeType;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileBusy;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileCreationDate;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileDeviceIdentifier;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileExtensionHidden;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileGroupOwnerAccountID;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileGroupOwnerAccountName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileHFSCreatorCode;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileHFSTypeCode;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileImmutable;
        pub use self::__NSFileManager::NSFileManagerDelegate;
        pub use self::__NSFileManager::NSFileManagerItemReplacementOptions;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileManagerUnmountDissentingProcessIdentifierErrorKey;
        pub use self::__NSFileManager::NSFileManagerUnmountOptions;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileModificationDate;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileOwnerAccountID;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileOwnerAccountName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFilePosixPermissions;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileProtectionComplete;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileProtectionCompleteUnlessOpen;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileProtectionCompleteUntilFirstUserAuthentication;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileProtectionCompleteWhenUserInactive;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileProtectionKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileProtectionNone;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileProtectionType;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileProviderServiceName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileReferenceCount;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileSize;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileSystemFileNumber;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileSystemFreeNodes;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileSystemFreeSize;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileSystemNodes;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileSystemNumber;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileSystemSize;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileType;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileTypeBlockSpecial;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileTypeCharacterSpecial;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileTypeDirectory;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileTypeRegular;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileTypeSocket;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileTypeSymbolicLink;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSFileTypeUnknown;
        pub use self::__NSFileManager::NSURLRelationship;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSFileManager::NSUbiquityIdentityDidChangeNotification;
        pub use self::__NSFileManager::NSVolumeEnumerationOptions;
        pub use self::__NSFilePresenter::NSFilePresenter;
        pub use self::__NSFileVersion::NSFileVersionAddingOptions;
        pub use self::__NSFileVersion::NSFileVersionReplacingOptions;
        pub use self::__NSFileWrapper::NSFileWrapperReadingOptions;
        pub use self::__NSFileWrapper::NSFileWrapperWritingOptions;
        pub use self::__NSFormatter::NSFormattingContext;
        pub use self::__NSFormatter::NSFormattingUnitStyle;
        pub use self::__NSGeometry::NSAlignmentOptions;
        pub use self::__NSGeometry::NSContainsRect;
        pub use self::__NSGeometry::NSDivideRect;
        pub use self::__NSGeometry::NSEdgeInsets;
        pub use self::__NSGeometry::NSEdgeInsetsEqual;
        pub use self::__NSGeometry::NSEdgeInsetsZero;
        pub use self::__NSGeometry::NSEqualPoints;
        pub use self::__NSGeometry::NSEqualRects;
        pub use self::__NSGeometry::NSEqualSizes;
        pub use self::__NSGeometry::NSInsetRect;
        pub use self::__NSGeometry::NSIntegralRect;
        pub use self::__NSGeometry::NSIntegralRectWithOptions;
        pub use self::__NSGeometry::NSIntersectionRect;
        pub use self::__NSGeometry::NSIntersectsRect;
        pub use self::__NSGeometry::NSIsEmptyRect;
        pub use self::__NSGeometry::NSMouseInRect;
        pub use self::__NSGeometry::NSOffsetRect;
        pub use self::__NSGeometry::NSPointArray;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSGeometry::NSPointFromString;
        pub use self::__NSGeometry::NSPointInRect;
        pub use self::__NSGeometry::NSPointPointer;
        pub use self::__NSGeometry::NSRectArray;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSGeometry::NSRectFromString;
        pub use self::__NSGeometry::NSRectPointer;
        pub use self::__NSGeometry::NSSizeArray;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSGeometry::NSSizeFromString;
        pub use self::__NSGeometry::NSSizePointer;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSGeometry::NSStringFromPoint;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSGeometry::NSStringFromRect;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSGeometry::NSStringFromSize;
        pub use self::__NSGeometry::NSUnionRect;
        pub use self::__NSGeometry::NSZeroPoint;
        pub use self::__NSGeometry::NSZeroRect;
        pub use self::__NSGeometry::NSZeroSize;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHFSFileTypes::NSFileTypeForHFSTypeCode;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHFSFileTypes::NSHFSTypeCodeFromFileType;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHFSFileTypes::NSHFSTypeOfFile;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHTTPCookie::NSHTTPCookieComment;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHTTPCookie::NSHTTPCookieCommentURL;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHTTPCookie::NSHTTPCookieDiscard;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHTTPCookie::NSHTTPCookieDomain;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHTTPCookie::NSHTTPCookieExpires;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHTTPCookie::NSHTTPCookieMaximumAge;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHTTPCookie::NSHTTPCookieName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHTTPCookie::NSHTTPCookieOriginURL;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHTTPCookie::NSHTTPCookiePath;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHTTPCookie::NSHTTPCookiePort;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHTTPCookie::NSHTTPCookiePropertyKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHTTPCookie::NSHTTPCookieSameSiteLax;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHTTPCookie::NSHTTPCookieSameSitePolicy;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHTTPCookie::NSHTTPCookieSameSiteStrict;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHTTPCookie::NSHTTPCookieSecure;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHTTPCookie::NSHTTPCookieStringPolicy;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHTTPCookie::NSHTTPCookieValue;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHTTPCookie::NSHTTPCookieVersion;
        pub use self::__NSHTTPCookieStorage::NSHTTPCookieAcceptPolicy;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHTTPCookieStorage::NSHTTPCookieManagerAcceptPolicyChangedNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSHTTPCookieStorage::NSHTTPCookieManagerCookiesChangedNotification;
        pub use self::__NSHashTable::NSEndHashTableEnumeration;
        pub use self::__NSHashTable::NSHashEnumerator;
        pub use self::__NSHashTable::NSHashTableCopyIn;
        pub use self::__NSHashTable::NSHashTableObjectPointerPersonality;
        pub use self::__NSHashTable::NSHashTableOptions;
        pub use self::__NSHashTable::NSHashTableStrongMemory;
        pub use self::__NSHashTable::NSHashTableWeakMemory;
        pub use self::__NSHashTable::NSHashTableZeroingWeakMemory;
        pub use self::__NSHashTable::NSNextHashEnumeratorItem;
        pub use self::__NSISO8601DateFormatter::NSISO8601DateFormatOptions;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSItemProvider::NSExtensionJavaScriptFinalizeArgumentKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSItemProvider::NSExtensionJavaScriptPreprocessingResultsKey;
        pub use self::__NSItemProvider::NSItemProviderErrorCode;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSItemProvider::NSItemProviderErrorDomain;
        pub use self::__NSItemProvider::NSItemProviderFileOptions;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSItemProvider::NSItemProviderPreferredImageSizeKey;
        pub use self::__NSItemProvider::NSItemProviderReading;
        pub use self::__NSItemProvider::NSItemProviderRepresentationVisibility;
        pub use self::__NSItemProvider::NSItemProviderWriting;
        pub use self::__NSJSONSerialization::NSJSONReadingOptions;
        pub use self::__NSJSONSerialization::NSJSONWritingOptions;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSKeyValueCoding::NSAverageKeyValueOperator;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSKeyValueCoding::NSCountKeyValueOperator;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSKeyValueCoding::NSDistinctUnionOfArraysKeyValueOperator;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSKeyValueCoding::NSDistinctUnionOfObjectsKeyValueOperator;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSKeyValueCoding::NSDistinctUnionOfSetsKeyValueOperator;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSKeyValueCoding::NSKeyValueOperator;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSKeyValueCoding::NSMaximumKeyValueOperator;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSKeyValueCoding::NSMinimumKeyValueOperator;
        pub use self::__NSKeyValueCoding::NSObjectNSKeyValueCoding;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSKeyValueCoding::NSSumKeyValueOperator;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSKeyValueCoding::NSUndefinedKeyException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSKeyValueCoding::NSUnionOfArraysKeyValueOperator;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSKeyValueCoding::NSUnionOfObjectsKeyValueOperator;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSKeyValueCoding::NSUnionOfSetsKeyValueOperator;
        pub use self::__NSKeyValueObserving::NSKeyValueChange;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSKeyValueObserving::NSKeyValueChangeIndexesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSKeyValueObserving::NSKeyValueChangeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSKeyValueObserving::NSKeyValueChangeKindKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSKeyValueObserving::NSKeyValueChangeNewKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSKeyValueObserving::NSKeyValueChangeNotificationIsPriorKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSKeyValueObserving::NSKeyValueChangeOldKey;
        pub use self::__NSKeyValueObserving::NSKeyValueObservingOptions;
        pub use self::__NSKeyValueObserving::NSKeyValueSetMutationKind;
        pub use self::__NSKeyValueObserving::NSObjectNSKeyValueObserverNotification;
        pub use self::__NSKeyValueObserving::NSObjectNSKeyValueObserverRegistration;
        pub use self::__NSKeyValueObserving::NSObjectNSKeyValueObserving;
        pub use self::__NSKeyValueObserving::NSObjectNSKeyValueObservingCustomization;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSKeyedArchiver::NSInvalidArchiveOperationException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSKeyedArchiver::NSInvalidUnarchiveOperationException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSKeyedArchiver::NSKeyedArchiveRootObjectKey;
        pub use self::__NSKeyedArchiver::NSKeyedArchiverDelegate;
        pub use self::__NSKeyedArchiver::NSKeyedUnarchiverDelegate;
        pub use self::__NSKeyedArchiver::NSObjectNSKeyedArchiverObjectSubstitution;
        pub use self::__NSKeyedArchiver::NSObjectNSKeyedUnarchiverObjectSubstitution;
        pub use self::__NSLengthFormatter::NSLengthFormatterUnit;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTag;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagAdjective;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagAdverb;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagClassifier;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagCloseParenthesis;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagCloseQuote;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagConjunction;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagDash;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagDeterminer;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagIdiom;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagInterjection;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagNoun;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagNumber;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagOpenParenthesis;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagOpenQuote;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagOrganizationName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagOther;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagOtherPunctuation;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagOtherWhitespace;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagOtherWord;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagParagraphBreak;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagParticle;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagPersonalName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagPlaceName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagPreposition;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagPronoun;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagPunctuation;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagScheme;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagSchemeLanguage;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagSchemeLemma;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagSchemeLexicalClass;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagSchemeNameType;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagSchemeNameTypeOrLexicalClass;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagSchemeScript;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagSchemeTokenType;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagSentenceTerminator;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagVerb;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagWhitespace;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagWord;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLinguisticTagger::NSLinguisticTagWordJoiner;
        pub use self::__NSLinguisticTagger::NSLinguisticTaggerOptions;
        pub use self::__NSLinguisticTagger::NSLinguisticTaggerUnit;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSBuddhistCalendar;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSChineseCalendar;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSCurrentLocaleDidChangeNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSGregorianCalendar;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSHebrewCalendar;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSISO8601Calendar;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSIndianCalendar;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSIslamicCalendar;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSIslamicCivilCalendar;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSJapaneseCalendar;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSLocaleAlternateQuotationBeginDelimiterKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSLocaleAlternateQuotationEndDelimiterKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSLocaleCalendar;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSLocaleCollationIdentifier;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSLocaleCollatorIdentifier;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSLocaleCountryCode;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSLocaleCurrencyCode;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSLocaleCurrencySymbol;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSLocaleDecimalSeparator;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSLocaleExemplarCharacterSet;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSLocaleGroupingSeparator;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSLocaleIdentifier;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSLocaleKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSLocaleLanguageCode;
        pub use self::__NSLocale::NSLocaleLanguageDirection;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSLocaleMeasurementSystem;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSLocaleQuotationBeginDelimiterKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSLocaleQuotationEndDelimiterKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSLocaleScriptCode;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSLocaleUsesMetricSystem;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSLocaleVariantCode;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSPersianCalendar;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSLocale::NSRepublicOfChinaCalendar;
        pub use self::__NSLock::NSLocking;
        pub use self::__NSMapTable::NSEndMapTableEnumeration;
        pub use self::__NSMapTable::NSMapEnumerator;
        pub use self::__NSMapTable::NSMapTableCopyIn;
        pub use self::__NSMapTable::NSMapTableObjectPointerPersonality;
        pub use self::__NSMapTable::NSMapTableOptions;
        pub use self::__NSMapTable::NSMapTableStrongMemory;
        pub use self::__NSMapTable::NSMapTableWeakMemory;
        pub use self::__NSMapTable::NSMapTableZeroingWeakMemory;
        pub use self::__NSMapTable::NSNextMapEnumeratorPair;
        pub use self::__NSMassFormatter::NSMassFormatterUnit;
        pub use self::__NSMeasurementFormatter::NSMeasurementFormatterUnitOptions;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadata::NSMetadataQueryAccessibleUbiquitousExternalDocumentsScope;
        pub use self::__NSMetadata::NSMetadataQueryDelegate;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadata::NSMetadataQueryDidFinishGatheringNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadata::NSMetadataQueryDidStartGatheringNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadata::NSMetadataQueryDidUpdateNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadata::NSMetadataQueryGatheringProgressNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadata::NSMetadataQueryIndexedLocalComputerScope;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadata::NSMetadataQueryIndexedNetworkScope;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadata::NSMetadataQueryLocalComputerScope;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadata::NSMetadataQueryNetworkScope;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadata::NSMetadataQueryResultContentRelevanceAttribute;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadata::NSMetadataQueryUbiquitousDataScope;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadata::NSMetadataQueryUbiquitousDocumentsScope;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadata::NSMetadataQueryUpdateAddedItemsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadata::NSMetadataQueryUpdateChangedItemsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadata::NSMetadataQueryUpdateRemovedItemsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadata::NSMetadataQueryUserHomeScope;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemAcquisitionMakeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemAcquisitionModelKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemAlbumKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemAltitudeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemApertureKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemAppleLoopDescriptorsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemAppleLoopsKeyFilterTypeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemAppleLoopsLoopModeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemAppleLoopsRootKeyKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemApplicationCategoriesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemAttributeChangeDateKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemAudiencesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemAudioBitRateKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemAudioChannelCountKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemAudioEncodingApplicationKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemAudioSampleRateKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemAudioTrackNumberKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemAuthorAddressesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemAuthorEmailAddressesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemAuthorsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemBitsPerSampleKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemCFBundleIdentifierKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemCameraOwnerKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemCityKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemCodecsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemColorSpaceKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemCommentKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemComposerKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemContactKeywordsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemContentCreationDateKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemContentModificationDateKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemContentTypeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemContentTypeTreeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemContributorsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemCopyrightKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemCountryKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemCoverageKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemCreatorKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemDateAddedKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemDeliveryTypeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemDescriptionKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemDirectorKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemDisplayNameKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemDownloadedDateKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemDueDateKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemDurationSecondsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemEXIFGPSVersionKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemEXIFVersionKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemEditorsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemEmailAddressesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemEncodingApplicationsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemExecutableArchitecturesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemExecutablePlatformKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemExposureModeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemExposureProgramKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemExposureTimeSecondsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemExposureTimeStringKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemFNumberKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemFSContentChangeDateKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemFSCreationDateKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemFSNameKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemFSSizeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemFinderCommentKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemFlashOnOffKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemFocalLength35mmKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemFocalLengthKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemFontsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemGPSAreaInformationKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemGPSDOPKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemGPSDateStampKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemGPSDestBearingKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemGPSDestDistanceKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemGPSDestLatitudeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemGPSDestLongitudeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemGPSDifferentalKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemGPSMapDatumKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemGPSMeasureModeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemGPSProcessingMethodKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemGPSStatusKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemGPSTrackKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemGenreKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemHasAlphaChannelKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemHeadlineKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemISOSpeedKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemIdentifierKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemImageDirectionKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemInformationKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemInstantMessageAddressesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemInstructionsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemIsApplicationManagedKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemIsGeneralMIDISequenceKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemIsLikelyJunkKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemIsUbiquitousKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemKeySignatureKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemKeywordsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemKindKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemLanguagesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemLastUsedDateKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemLatitudeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemLayerNamesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemLensModelKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemLongitudeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemLyricistKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemMaxApertureKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemMediaTypesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemMeteringModeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemMusicalGenreKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemMusicalInstrumentCategoryKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemMusicalInstrumentNameKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemNamedLocationKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemNumberOfPagesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemOrganizationsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemOrientationKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemOriginalFormatKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemOriginalSourceKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemPageHeightKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemPageWidthKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemParticipantsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemPathKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemPerformersKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemPhoneNumbersKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemPixelCountKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemPixelHeightKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemPixelWidthKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemProducerKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemProfileNameKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemProjectsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemPublishersKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemRecipientAddressesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemRecipientEmailAddressesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemRecipientsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemRecordingDateKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemRecordingYearKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemRedEyeOnOffKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemResolutionHeightDPIKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemResolutionWidthDPIKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemRightsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemSecurityMethodKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemSpeedKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemStarRatingKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemStateOrProvinceKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemStreamableKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemSubjectKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemTempoKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemTextContentKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemThemeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemTimeSignatureKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemTimestampKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemTitleKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemTotalBitRateKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemURLKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemVersionKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemVideoBitRateKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemWhereFromsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataItemWhiteBalanceKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousItemContainerDisplayNameKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousItemDownloadRequestedKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousItemDownloadingErrorKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousItemDownloadingStatusCurrent;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousItemDownloadingStatusDownloaded;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousItemDownloadingStatusKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousItemDownloadingStatusNotDownloaded;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousItemHasUnresolvedConflictsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousItemIsDownloadedKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousItemIsDownloadingKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousItemIsExternalDocumentKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousItemIsSharedKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousItemIsUploadedKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousItemIsUploadingKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousItemPercentDownloadedKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousItemPercentUploadedKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousItemURLInLocalContainerKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousItemUploadingErrorKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousSharedItemCurrentUserPermissionsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousSharedItemCurrentUserRoleKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousSharedItemMostRecentEditorNameComponentsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousSharedItemOwnerNameComponentsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousSharedItemPermissionsReadOnly;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousSharedItemPermissionsReadWrite;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousSharedItemRoleOwner;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSMetadataAttributes::NSMetadataUbiquitousSharedItemRoleParticipant;
        pub use self::__NSMorphology::NSGrammaticalCase;
        pub use self::__NSMorphology::NSGrammaticalDefiniteness;
        pub use self::__NSMorphology::NSGrammaticalDetermination;
        pub use self::__NSMorphology::NSGrammaticalGender;
        pub use self::__NSMorphology::NSGrammaticalNumber;
        pub use self::__NSMorphology::NSGrammaticalPartOfSpeech;
        pub use self::__NSMorphology::NSGrammaticalPerson;
        pub use self::__NSMorphology::NSGrammaticalPronounType;
        pub use self::__NSNetServices::NSNetServiceBrowserDelegate;
        pub use self::__NSNetServices::NSNetServiceDelegate;
        pub use self::__NSNetServices::NSNetServiceOptions;
        pub use self::__NSNetServices::NSNetServicesError;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSNetServices::NSNetServicesErrorCode;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSNetServices::NSNetServicesErrorDomain;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSNotification::NSNotificationName;
        pub use self::__NSNotificationQueue::NSNotificationCoalescing;
        pub use self::__NSNotificationQueue::NSPostingStyle;
        pub use self::__NSNumberFormatter::NSNumberFormatterBehavior;
        pub use self::__NSNumberFormatter::NSNumberFormatterPadPosition;
        pub use self::__NSNumberFormatter::NSNumberFormatterRoundingMode;
        pub use self::__NSNumberFormatter::NSNumberFormatterStyle;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSObjCRuntime::NSClassFromString;
        pub use self::__NSObjCRuntime::NSComparator;
        pub use self::__NSObjCRuntime::NSEnumerationOptions;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSObjCRuntime::NSExceptionName;
        pub use self::__NSObjCRuntime::NSFoundationVersionNumber;
        pub use self::__NSObjCRuntime::NSGetSizeAndAlignment;
        pub use self::__NSObjCRuntime::NSNotFound;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSObjCRuntime::NSProtocolFromString;
        pub use self::__NSObjCRuntime::NSQualityOfService;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSObjCRuntime::NSRunLoopMode;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSObjCRuntime::NSSelectorFromString;
        pub use self::__NSObjCRuntime::NSSortOptions;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSObjCRuntime::NSStringFromClass;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSObjCRuntime::NSStringFromProtocol;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSObjCRuntime::NSStringFromSelector;
        pub use self::__NSObject::NSAllocateObject;
        pub use self::__NSObject::NSCoding;
        pub use self::__NSObject::NSCopyObject;
        pub use self::__NSObject::NSDeallocateObject;
        pub use self::__NSObject::NSDecrementExtraRefCountWasZero;
        pub use self::__NSObject::NSDiscardableContent;
        pub use self::__NSObject::NSExtraRefCount;
        pub use self::__NSObject::NSIncrementExtraRefCount;
        pub use self::__NSObject::NSObjectNSCoderMethods;
        pub use self::__NSObject::NSObjectNSDiscardableContentProxy;
        pub use self::__NSObject::NSSecureCoding;
        pub use self::__NSObject::NSShouldRetainWithZone;
        pub use self::__NSObjectScripting::NSObjectNSScripting;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSOperation::NSInvocationOperationCancelledException;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSOperation::NSInvocationOperationVoidResultException;
        pub use self::__NSOperation::NSOperationQueueDefaultMaxConcurrentOperationCount;
        pub use self::__NSOperation::NSOperationQueuePriority;
        pub use self::__NSOrderedCollectionChange::NSCollectionChangeType;
        pub use self::__NSOrderedCollectionDifference::NSOrderedCollectionDifferenceCalculationOptions;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSPathUtilities::NSFullUserName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSPathUtilities::NSHomeDirectory;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSPathUtilities::NSHomeDirectoryForUser;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSPathUtilities::NSOpenStepRootDirectory;
        pub use self::__NSPathUtilities::NSSearchPathDirectory;
        pub use self::__NSPathUtilities::NSSearchPathDomainMask;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSPathUtilities::NSTemporaryDirectory;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSPathUtilities::NSUserName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSPersonNameComponentsFormatter::NSPersonNameComponentDelimiter;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSPersonNameComponentsFormatter::NSPersonNameComponentFamilyName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSPersonNameComponentsFormatter::NSPersonNameComponentGivenName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSPersonNameComponentsFormatter::NSPersonNameComponentKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSPersonNameComponentsFormatter::NSPersonNameComponentMiddleName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSPersonNameComponentsFormatter::NSPersonNameComponentNickname;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSPersonNameComponentsFormatter::NSPersonNameComponentPrefix;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSPersonNameComponentsFormatter::NSPersonNameComponentSuffix;
        pub use self::__NSPersonNameComponentsFormatter::NSPersonNameComponentsFormatterOptions;
        pub use self::__NSPersonNameComponentsFormatter::NSPersonNameComponentsFormatterStyle;
        pub use self::__NSPointerFunctions::NSPointerFunctionsOptions;
        pub use self::__NSPort::NSMachPortDelegate;
        pub use self::__NSPort::NSMachPortOptions;
        pub use self::__NSPort::NSPortDelegate;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSPort::NSPortDidBecomeInvalidNotification;
        pub use self::__NSPort::NSSocketNativeHandle;
        pub use self::__NSProcessInfo::NSActivityOptions;
        pub use self::__NSProcessInfo::NSHPUXOperatingSystem;
        pub use self::__NSProcessInfo::NSMACHOperatingSystem;
        pub use self::__NSProcessInfo::NSOSF1OperatingSystem;
        pub use self::__NSProcessInfo::NSOperatingSystemVersion;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSProcessInfo::NSProcessInfoPowerStateDidChangeNotification;
        pub use self::__NSProcessInfo::NSProcessInfoThermalState;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSProcessInfo::NSProcessInfoThermalStateDidChangeNotification;
        pub use self::__NSProcessInfo::NSSolarisOperatingSystem;
        pub use self::__NSProcessInfo::NSSunOSOperatingSystem;
        pub use self::__NSProcessInfo::NSWindows95OperatingSystem;
        pub use self::__NSProcessInfo::NSWindowsNTOperatingSystem;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSProgress::NSProgressEstimatedTimeRemainingKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSProgress::NSProgressFileAnimationImageKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSProgress::NSProgressFileAnimationImageOriginalRectKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSProgress::NSProgressFileCompletedCountKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSProgress::NSProgressFileIconKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSProgress::NSProgressFileOperationKind;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSProgress::NSProgressFileOperationKindCopying;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSProgress::NSProgressFileOperationKindDecompressingAfterDownloading;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSProgress::NSProgressFileOperationKindDownloading;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSProgress::NSProgressFileOperationKindDuplicating;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSProgress::NSProgressFileOperationKindKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSProgress::NSProgressFileOperationKindReceiving;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSProgress::NSProgressFileOperationKindUploading;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSProgress::NSProgressFileTotalCountKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSProgress::NSProgressFileURLKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSProgress::NSProgressKind;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSProgress::NSProgressKindFile;
        pub use self::__NSProgress::NSProgressReporting;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSProgress::NSProgressThroughputKey;
        pub use self::__NSProgress::NSProgressUnpublishingHandler;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSProgress::NSProgressUserInfoKey;
        pub use self::__NSPropertyList::NSPropertyListFormat;
        pub use self::__NSPropertyList::NSPropertyListMutabilityOptions;
        pub use self::__NSPropertyList::NSPropertyListReadOptions;
        pub use self::__NSPropertyList::NSPropertyListWriteOptions;
        pub use self::__NSRange::NSIntersectionRange;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSRange::NSRangeFromString;
        pub use self::__NSRange::NSRangePointer;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSRange::NSStringFromRange;
        pub use self::__NSRange::NSUnionRange;
        pub use self::__NSRegularExpression::NSMatchingFlags;
        pub use self::__NSRegularExpression::NSMatchingOptions;
        pub use self::__NSRegularExpression::NSRegularExpressionOptions;
        pub use self::__NSRelativeDateTimeFormatter::NSRelativeDateTimeFormatterStyle;
        pub use self::__NSRelativeDateTimeFormatter::NSRelativeDateTimeFormatterUnitsStyle;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSRunLoop::NSDefaultRunLoopMode;
        pub use self::__NSRunLoop::NSObjectNSDelayedPerforming;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSRunLoop::NSRunLoopCommonModes;
        pub use self::__NSScriptClassDescription::NSObjectNSScriptClassDescription;
        pub use self::__NSScriptCommand::NSArgumentEvaluationScriptError;
        pub use self::__NSScriptCommand::NSArgumentsWrongScriptError;
        pub use self::__NSScriptCommand::NSCannotCreateScriptCommandError;
        pub use self::__NSScriptCommand::NSInternalScriptError;
        pub use self::__NSScriptCommand::NSKeySpecifierEvaluationScriptError;
        pub use self::__NSScriptCommand::NSNoScriptError;
        pub use self::__NSScriptCommand::NSOperationNotSupportedForKeyScriptError;
        pub use self::__NSScriptCommand::NSReceiverEvaluationScriptError;
        pub use self::__NSScriptCommand::NSReceiversCantHandleCommandScriptError;
        pub use self::__NSScriptCommand::NSRequiredArgumentsMissingScriptError;
        pub use self::__NSScriptCommand::NSUnknownKeyScriptError;
        pub use self::__NSScriptKeyValueCoding::NSObjectNSScriptKeyValueCoding;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSScriptKeyValueCoding::NSOperationNotSupportedForKeyException;
        pub use self::__NSScriptObjectSpecifiers::NSContainerSpecifierError;
        pub use self::__NSScriptObjectSpecifiers::NSInsertionPosition;
        pub use self::__NSScriptObjectSpecifiers::NSInternalSpecifierError;
        pub use self::__NSScriptObjectSpecifiers::NSInvalidIndexSpecifierError;
        pub use self::__NSScriptObjectSpecifiers::NSNoSpecifierError;
        pub use self::__NSScriptObjectSpecifiers::NSNoTopLevelContainersSpecifierError;
        pub use self::__NSScriptObjectSpecifiers::NSObjectNSScriptObjectSpecifiers;
        pub use self::__NSScriptObjectSpecifiers::NSOperationNotSupportedForKeySpecifierError;
        pub use self::__NSScriptObjectSpecifiers::NSRelativePosition;
        pub use self::__NSScriptObjectSpecifiers::NSUnknownKeySpecifierError;
        pub use self::__NSScriptObjectSpecifiers::NSWhoseSubelementIdentifier;
        pub use self::__NSScriptStandardSuiteCommands::NSSaveOptions;
        pub use self::__NSScriptWhoseTests::NSObjectNSComparisonMethods;
        pub use self::__NSScriptWhoseTests::NSObjectNSScriptingComparisonMethods;
        pub use self::__NSScriptWhoseTests::NSTestComparisonOperation;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSSpellServer::NSGrammarCorrections;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSSpellServer::NSGrammarRange;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSSpellServer::NSGrammarUserDescription;
        pub use self::__NSSpellServer::NSSpellServerDelegate;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamDataWrittenToMemoryStreamKey;
        pub use self::__NSStream::NSStreamDelegate;
        pub use self::__NSStream::NSStreamEvent;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamFileCurrentOffsetKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamNetworkServiceType;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamNetworkServiceTypeBackground;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamNetworkServiceTypeCallSignaling;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamNetworkServiceTypeValue;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamNetworkServiceTypeVideo;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamNetworkServiceTypeVoIP;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamNetworkServiceTypeVoice;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamPropertyKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamSOCKSErrorDomain;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamSOCKSProxyConfiguration;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamSOCKSProxyConfigurationKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamSOCKSProxyHostKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamSOCKSProxyPasswordKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamSOCKSProxyPortKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamSOCKSProxyUserKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamSOCKSProxyVersion;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamSOCKSProxyVersion4;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamSOCKSProxyVersion5;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamSOCKSProxyVersionKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamSocketSSLErrorDomain;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamSocketSecurityLevel;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamSocketSecurityLevelKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamSocketSecurityLevelNegotiatedSSL;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamSocketSecurityLevelNone;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamSocketSecurityLevelSSLv2;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamSocketSecurityLevelSSLv3;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSStream::NSStreamSocketSecurityLevelTLSv1;
        pub use self::__NSStream::NSStreamStatus;
        pub use self::__NSString::unichar;
        pub use self::__NSString::NSASCIIStringEncoding;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSCharacterConversionException;
        pub use self::__NSString::NSISO2022JPStringEncoding;
        pub use self::__NSString::NSISOLatin1StringEncoding;
        pub use self::__NSString::NSISOLatin2StringEncoding;
        pub use self::__NSString::NSJapaneseEUCStringEncoding;
        pub use self::__NSString::NSMacOSRomanStringEncoding;
        pub use self::__NSString::NSNEXTSTEPStringEncoding;
        pub use self::__NSString::NSNonLossyASCIIStringEncoding;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSParseErrorException;
        pub use self::__NSString::NSShiftJISStringEncoding;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSString;
        pub use self::__NSString::NSStringCompareOptions;
        pub use self::__NSString::NSStringEncoding;
        pub use self::__NSString::NSStringEncodingConversionOptions;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringEncodingDetectionAllowLossyKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringEncodingDetectionDisallowedEncodingsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringEncodingDetectionFromWindowsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringEncodingDetectionLikelyLanguageKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringEncodingDetectionLossySubstitutionKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringEncodingDetectionOptionsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringEncodingDetectionSuggestedEncodingsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringEncodingDetectionUseOnlySuggestedEncodingsKey;
        pub use self::__NSString::NSStringEnumerationOptions;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringTransform;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringTransformFullwidthToHalfwidth;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringTransformHiraganaToKatakana;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringTransformLatinToArabic;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringTransformLatinToCyrillic;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringTransformLatinToGreek;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringTransformLatinToHangul;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringTransformLatinToHebrew;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringTransformLatinToHiragana;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringTransformLatinToKatakana;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringTransformLatinToThai;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringTransformMandarinToLatin;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringTransformStripCombiningMarks;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringTransformStripDiacritics;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringTransformToLatin;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringTransformToUnicodeName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSString::NSStringTransformToXMLHex;
        pub use self::__NSString::NSSymbolStringEncoding;
        pub use self::__NSString::NSUTF16BigEndianStringEncoding;
        pub use self::__NSString::NSUTF16LittleEndianStringEncoding;
        pub use self::__NSString::NSUTF16StringEncoding;
        pub use self::__NSString::NSUTF32BigEndianStringEncoding;
        pub use self::__NSString::NSUTF32LittleEndianStringEncoding;
        pub use self::__NSString::NSUTF32StringEncoding;
        pub use self::__NSString::NSUTF8StringEncoding;
        pub use self::__NSString::NSUnicodeStringEncoding;
        pub use self::__NSString::NSWindowsCP1250StringEncoding;
        pub use self::__NSString::NSWindowsCP1251StringEncoding;
        pub use self::__NSString::NSWindowsCP1252StringEncoding;
        pub use self::__NSString::NSWindowsCP1253StringEncoding;
        pub use self::__NSString::NSWindowsCP1254StringEncoding;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSTask::NSTaskDidTerminateNotification;
        pub use self::__NSTask::NSTaskTerminationReason;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSTextCheckingResult::NSTextCheckingAirlineKey;
        pub use self::__NSTextCheckingResult::NSTextCheckingAllCustomTypes;
        pub use self::__NSTextCheckingResult::NSTextCheckingAllSystemTypes;
        pub use self::__NSTextCheckingResult::NSTextCheckingAllTypes;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSTextCheckingResult::NSTextCheckingCityKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSTextCheckingResult::NSTextCheckingCountryKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSTextCheckingResult::NSTextCheckingFlightKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSTextCheckingResult::NSTextCheckingJobTitleKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSTextCheckingResult::NSTextCheckingKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSTextCheckingResult::NSTextCheckingNameKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSTextCheckingResult::NSTextCheckingOrganizationKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSTextCheckingResult::NSTextCheckingPhoneKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSTextCheckingResult::NSTextCheckingStateKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSTextCheckingResult::NSTextCheckingStreetKey;
        pub use self::__NSTextCheckingResult::NSTextCheckingType;
        pub use self::__NSTextCheckingResult::NSTextCheckingTypes;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSTextCheckingResult::NSTextCheckingZIPKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSThread::NSDidBecomeSingleThreadedNotification;
        pub use self::__NSThread::NSObjectNSThreadPerformAdditions;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSThread::NSThreadWillExitNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSThread::NSWillBecomeMultiThreadedNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSTimeZone::NSSystemTimeZoneDidChangeNotification;
        pub use self::__NSTimeZone::NSTimeZoneNameStyle;
        pub use self::__NSURLAuthenticationChallenge::NSURLAuthenticationChallengeSender;
        pub use self::__NSURLCache::NSURLCacheStoragePolicy;
        pub use self::__NSURLConnection::NSURLConnectionDataDelegate;
        pub use self::__NSURLConnection::NSURLConnectionDelegate;
        pub use self::__NSURLConnection::NSURLConnectionDownloadDelegate;
        pub use self::__NSURLCredential::NSURLCredentialPersistence;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLCredentialStorage::NSURLCredentialStorageChangedNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLCredentialStorage::NSURLCredentialStorageRemoveSynchronizableCredentials;
        pub use self::__NSURLDownload::NSURLDownloadDelegate;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLError::NSErrorFailingURLStringKey;
        pub use self::__NSURLError::NSURLErrorAppTransportSecurityRequiresSecureConnection;
        pub use self::__NSURLError::NSURLErrorBackgroundSessionInUseByAnotherProcess;
        pub use self::__NSURLError::NSURLErrorBackgroundSessionRequiresSharedContainer;
        pub use self::__NSURLError::NSURLErrorBackgroundSessionWasDisconnected;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLError::NSURLErrorBackgroundTaskCancelledReasonKey;
        pub use self::__NSURLError::NSURLErrorBadServerResponse;
        pub use self::__NSURLError::NSURLErrorBadURL;
        pub use self::__NSURLError::NSURLErrorCallIsActive;
        pub use self::__NSURLError::NSURLErrorCancelled;
        pub use self::__NSURLError::NSURLErrorCancelledReasonBackgroundUpdatesDisabled;
        pub use self::__NSURLError::NSURLErrorCancelledReasonInsufficientSystemResources;
        pub use self::__NSURLError::NSURLErrorCancelledReasonUserForceQuitApplication;
        pub use self::__NSURLError::NSURLErrorCannotCloseFile;
        pub use self::__NSURLError::NSURLErrorCannotConnectToHost;
        pub use self::__NSURLError::NSURLErrorCannotCreateFile;
        pub use self::__NSURLError::NSURLErrorCannotDecodeContentData;
        pub use self::__NSURLError::NSURLErrorCannotDecodeRawData;
        pub use self::__NSURLError::NSURLErrorCannotFindHost;
        pub use self::__NSURLError::NSURLErrorCannotLoadFromNetwork;
        pub use self::__NSURLError::NSURLErrorCannotMoveFile;
        pub use self::__NSURLError::NSURLErrorCannotOpenFile;
        pub use self::__NSURLError::NSURLErrorCannotParseResponse;
        pub use self::__NSURLError::NSURLErrorCannotRemoveFile;
        pub use self::__NSURLError::NSURLErrorCannotWriteToFile;
        pub use self::__NSURLError::NSURLErrorClientCertificateRejected;
        pub use self::__NSURLError::NSURLErrorClientCertificateRequired;
        pub use self::__NSURLError::NSURLErrorDNSLookupFailed;
        pub use self::__NSURLError::NSURLErrorDataLengthExceedsMaximum;
        pub use self::__NSURLError::NSURLErrorDataNotAllowed;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLError::NSURLErrorDomain;
        pub use self::__NSURLError::NSURLErrorDownloadDecodingFailedMidStream;
        pub use self::__NSURLError::NSURLErrorDownloadDecodingFailedToComplete;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLError::NSURLErrorFailingURLErrorKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLError::NSURLErrorFailingURLPeerTrustErrorKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLError::NSURLErrorFailingURLStringErrorKey;
        pub use self::__NSURLError::NSURLErrorFileDoesNotExist;
        pub use self::__NSURLError::NSURLErrorFileIsDirectory;
        pub use self::__NSURLError::NSURLErrorFileOutsideSafeArea;
        pub use self::__NSURLError::NSURLErrorHTTPTooManyRedirects;
        pub use self::__NSURLError::NSURLErrorInternationalRoamingOff;
        pub use self::__NSURLError::NSURLErrorNetworkConnectionLost;
        pub use self::__NSURLError::NSURLErrorNetworkUnavailableReason;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLError::NSURLErrorNetworkUnavailableReasonKey;
        pub use self::__NSURLError::NSURLErrorNoPermissionsToReadFile;
        pub use self::__NSURLError::NSURLErrorNotConnectedToInternet;
        pub use self::__NSURLError::NSURLErrorRedirectToNonExistentLocation;
        pub use self::__NSURLError::NSURLErrorRequestBodyStreamExhausted;
        pub use self::__NSURLError::NSURLErrorResourceUnavailable;
        pub use self::__NSURLError::NSURLErrorSecureConnectionFailed;
        pub use self::__NSURLError::NSURLErrorServerCertificateHasBadDate;
        pub use self::__NSURLError::NSURLErrorServerCertificateHasUnknownRoot;
        pub use self::__NSURLError::NSURLErrorServerCertificateNotYetValid;
        pub use self::__NSURLError::NSURLErrorServerCertificateUntrusted;
        pub use self::__NSURLError::NSURLErrorTimedOut;
        pub use self::__NSURLError::NSURLErrorUnknown;
        pub use self::__NSURLError::NSURLErrorUnsupportedURL;
        pub use self::__NSURLError::NSURLErrorUserAuthenticationRequired;
        pub use self::__NSURLError::NSURLErrorUserCancelledAuthentication;
        pub use self::__NSURLError::NSURLErrorZeroByteResource;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLHandle::NSFTPPropertyActiveTransferModeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLHandle::NSFTPPropertyFTPProxy;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLHandle::NSFTPPropertyFileOffsetKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLHandle::NSFTPPropertyUserLoginKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLHandle::NSFTPPropertyUserPasswordKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLHandle::NSHTTPPropertyErrorPageDataKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLHandle::NSHTTPPropertyHTTPProxy;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLHandle::NSHTTPPropertyRedirectionHeadersKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLHandle::NSHTTPPropertyServerHTTPVersionKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLHandle::NSHTTPPropertyStatusCodeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLHandle::NSHTTPPropertyStatusReasonKey;
        pub use self::__NSURLHandle::NSURLHandleClient;
        pub use self::__NSURLHandle::NSURLHandleStatus;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLProtectionSpace::NSURLAuthenticationMethodClientCertificate;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLProtectionSpace::NSURLAuthenticationMethodDefault;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLProtectionSpace::NSURLAuthenticationMethodHTMLForm;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLProtectionSpace::NSURLAuthenticationMethodHTTPBasic;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLProtectionSpace::NSURLAuthenticationMethodHTTPDigest;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLProtectionSpace::NSURLAuthenticationMethodNTLM;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLProtectionSpace::NSURLAuthenticationMethodNegotiate;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLProtectionSpace::NSURLAuthenticationMethodServerTrust;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLProtectionSpace::NSURLProtectionSpaceFTP;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLProtectionSpace::NSURLProtectionSpaceFTPProxy;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLProtectionSpace::NSURLProtectionSpaceHTTP;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLProtectionSpace::NSURLProtectionSpaceHTTPProxy;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLProtectionSpace::NSURLProtectionSpaceHTTPS;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLProtectionSpace::NSURLProtectionSpaceHTTPSProxy;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLProtectionSpace::NSURLProtectionSpaceSOCKSProxy;
        pub use self::__NSURLProtocol::NSURLProtocolClient;
        pub use self::__NSURLRequest::NSURLRequestAttribution;
        pub use self::__NSURLRequest::NSURLRequestCachePolicy;
        pub use self::__NSURLRequest::NSURLRequestNetworkServiceType;
        pub use self::__NSURLSession::NSURLSessionAuthChallengeDisposition;
        pub use self::__NSURLSession::NSURLSessionDataDelegate;
        pub use self::__NSURLSession::NSURLSessionDelayedRequestDisposition;
        pub use self::__NSURLSession::NSURLSessionDelegate;
        pub use self::__NSURLSession::NSURLSessionDownloadDelegate;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLSession::NSURLSessionDownloadTaskResumeData;
        pub use self::__NSURLSession::NSURLSessionMultipathServiceType;
        pub use self::__NSURLSession::NSURLSessionResponseDisposition;
        pub use self::__NSURLSession::NSURLSessionStreamDelegate;
        pub use self::__NSURLSession::NSURLSessionTaskDelegate;
        pub use self::__NSURLSession::NSURLSessionTaskMetricsDomainResolutionProtocol;
        pub use self::__NSURLSession::NSURLSessionTaskMetricsResourceFetchType;
        pub use self::__NSURLSession::NSURLSessionTaskPriorityDefault;
        pub use self::__NSURLSession::NSURLSessionTaskPriorityHigh;
        pub use self::__NSURLSession::NSURLSessionTaskPriorityLow;
        pub use self::__NSURLSession::NSURLSessionTaskState;
        pub use self::__NSURLSession::NSURLSessionTransferSizeUnknown;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURLSession::NSURLSessionUploadTaskResumeData;
        pub use self::__NSURLSession::NSURLSessionWebSocketCloseCode;
        pub use self::__NSURLSession::NSURLSessionWebSocketDelegate;
        pub use self::__NSURLSession::NSURLSessionWebSocketMessageType;
        pub use self::__NSUbiquitousKeyValueStore::NSUbiquitousKeyValueStoreAccountChange;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUbiquitousKeyValueStore::NSUbiquitousKeyValueStoreChangeReasonKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUbiquitousKeyValueStore::NSUbiquitousKeyValueStoreChangedKeysKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUbiquitousKeyValueStore::NSUbiquitousKeyValueStoreDidChangeExternallyNotification;
        pub use self::__NSUbiquitousKeyValueStore::NSUbiquitousKeyValueStoreInitialSyncChange;
        pub use self::__NSUbiquitousKeyValueStore::NSUbiquitousKeyValueStoreQuotaViolationChange;
        pub use self::__NSUbiquitousKeyValueStore::NSUbiquitousKeyValueStoreServerChange;
        pub use self::__NSUndoManager::NSUndoCloseGroupingRunLoopOrdering;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUndoManager::NSUndoManagerCheckpointNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUndoManager::NSUndoManagerDidCloseUndoGroupNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUndoManager::NSUndoManagerDidOpenUndoGroupNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUndoManager::NSUndoManagerDidRedoChangeNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUndoManager::NSUndoManagerDidUndoChangeNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUndoManager::NSUndoManagerGroupIsDiscardableKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUndoManager::NSUndoManagerWillCloseUndoGroupNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUndoManager::NSUndoManagerWillRedoChangeNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUndoManager::NSUndoManagerWillUndoChangeNotification;
        pub use self::__NSUserActivity::NSUserActivityDelegate;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserActivity::NSUserActivityPersistentIdentifier;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserActivity::NSUserActivityTypeBrowsingWeb;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSAMPMDesignation;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSArgumentDomain;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSCurrencySymbol;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSDateFormatString;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSDateTimeOrdering;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSDecimalDigits;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSDecimalSeparator;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSEarlierTimeDesignations;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSGlobalDomain;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSHourNameDesignations;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSInternationalCurrencyString;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSLaterTimeDesignations;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSMonthNameArray;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSNegativeCurrencyFormatString;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSNextDayDesignations;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSNextNextDayDesignations;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSPositiveCurrencyFormatString;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSPriorDayDesignations;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSRegistrationDomain;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSShortDateFormatString;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSShortMonthNameArray;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSShortTimeDateFormatString;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSShortWeekDayNameArray;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSThisDayDesignations;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSThousandsSeparator;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSTimeDateFormatString;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSTimeFormatString;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSUbiquitousUserDefaultsCompletedInitialSyncNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSUbiquitousUserDefaultsDidChangeAccountsNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSUbiquitousUserDefaultsNoCloudAccountNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSUserDefaultsDidChangeNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSUserDefaultsSizeLimitExceededNotification;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSWeekDayNameArray;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserDefaults::NSYearMonthWeekDesignations;
        pub use self::__NSUserNotification::NSUserNotificationActivationType;
        pub use self::__NSUserNotification::NSUserNotificationCenterDelegate;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSUserNotification::NSUserNotificationDefaultSoundName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSValueTransformer::NSIsNilTransformerName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSValueTransformer::NSIsNotNilTransformerName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSValueTransformer::NSKeyedUnarchiveFromDataTransformerName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSValueTransformer::NSNegateBooleanTransformerName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSValueTransformer::NSSecureUnarchiveFromDataTransformerName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSValueTransformer::NSUnarchiveFromDataTransformerName;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSValueTransformer::NSValueTransformerName;
        pub use self::__NSXMLDTDNode::NSXMLDTDNodeKind;
        pub use self::__NSXMLDocument::NSXMLDocumentContentKind;
        pub use self::__NSXMLNode::NSXMLNodeKind;
        pub use self::__NSXMLNodeOptions::NSXMLNodeOptions;
        pub use self::__NSXMLParser::NSXMLParserDelegate;
        pub use self::__NSXMLParser::NSXMLParserError;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSXMLParser::NSXMLParserErrorDomain;
        pub use self::__NSXMLParser::NSXMLParserExternalEntityResolvingPolicy;
        pub use self::__NSXPCConnection::NSXPCConnectionOptions;
        pub use self::__NSXPCConnection::NSXPCListenerDelegate;
        pub use self::__NSXPCConnection::NSXPCProxyCreating;
        pub use self::__NSZone::NSAllocateCollectable;
        pub use self::__NSZone::NSAllocateMemoryPages;
        pub use self::__NSZone::NSCollectorDisabledOption;
        pub use self::__NSZone::NSCopyMemoryPages;
        pub use self::__NSZone::NSCreateZone;
        pub use self::__NSZone::NSDeallocateMemoryPages;
        pub use self::__NSZone::NSDefaultMallocZone;
        pub use self::__NSZone::NSLogPageSize;
        pub use self::__NSZone::NSPageSize;
        pub use self::__NSZone::NSRealMemoryAvailable;
        pub use self::__NSZone::NSReallocateCollectable;
        pub use self::__NSZone::NSRecycleZone;
        pub use self::__NSZone::NSRoundDownToMultipleOfPageSize;
        pub use self::__NSZone::NSRoundUpToMultipleOfPageSize;
        pub use self::__NSZone::NSScannedOption;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSZone::NSSetZoneName;
        pub use self::__NSZone::NSZoneCalloc;
        pub use self::__NSZone::NSZoneFree;
        pub use self::__NSZone::NSZoneFromPointer;
        pub use self::__NSZone::NSZoneMalloc;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSZone::NSZoneName;
        pub use self::__NSZone::NSZoneRealloc;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSThumbnail1024x1024SizeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLAddedToDirectoryDateKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLApplicationIsScriptableKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLAttributeModificationDateKey;
        pub use self::__NSURL::NSURLBookmarkCreationOptions;
        pub use self::__NSURL::NSURLBookmarkFileCreationOptions;
        pub use self::__NSURL::NSURLBookmarkResolutionOptions;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLCanonicalPathKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLContentAccessDateKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLContentModificationDateKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLContentTypeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLCreationDateKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLCustomIconKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLDirectoryEntryCountKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLDocumentIdentifierKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLEffectiveIconKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileAllocatedSizeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileContentIdentifierKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileIdentifierKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileProtectionComplete;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileProtectionCompleteUnlessOpen;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileProtectionCompleteUntilFirstUserAuthentication;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileProtectionCompleteWhenUserInactive;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileProtectionKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileProtectionNone;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileProtectionType;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileResourceIdentifierKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileResourceType;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileResourceTypeBlockSpecial;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileResourceTypeCharacterSpecial;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileResourceTypeDirectory;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileResourceTypeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileResourceTypeNamedPipe;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileResourceTypeRegular;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileResourceTypeSocket;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileResourceTypeSymbolicLink;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileResourceTypeUnknown;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileScheme;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileSecurityKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLFileSizeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLGenerationIdentifierKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLHasHiddenExtensionKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLIsAliasFileKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLIsApplicationKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLIsDirectoryKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLIsExcludedFromBackupKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLIsExecutableKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLIsHiddenKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLIsMountTriggerKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLIsPackageKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLIsPurgeableKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLIsReadableKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLIsRegularFileKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLIsSparseKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLIsSymbolicLinkKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLIsSystemImmutableKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLIsUbiquitousItemKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLIsUserImmutableKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLIsVolumeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLIsWritableKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLKeysOfUnsetValuesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLLabelColorKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLLabelNumberKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLLinkCountKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLLocalizedLabelKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLLocalizedNameKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLLocalizedTypeDescriptionKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLMayHaveExtendedAttributesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLMayShareFileContentKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLNameKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLParentDirectoryURLKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLPathKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLPreferredIOBlockSizeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLQuarantinePropertiesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLResourceKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLTagNamesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLThumbnailDictionaryItem;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLThumbnailDictionaryKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLThumbnailKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLTotalFileAllocatedSizeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLTotalFileSizeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLTypeIdentifierKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousItemContainerDisplayNameKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousItemDownloadRequestedKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousItemDownloadingErrorKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousItemDownloadingStatus;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousItemDownloadingStatusCurrent;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousItemDownloadingStatusDownloaded;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousItemDownloadingStatusKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousItemDownloadingStatusNotDownloaded;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousItemHasUnresolvedConflictsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousItemIsDownloadedKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousItemIsDownloadingKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousItemIsExcludedFromSyncKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousItemIsSharedKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousItemIsUploadedKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousItemIsUploadingKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousItemPercentDownloadedKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousItemPercentUploadedKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousItemUploadingErrorKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousSharedItemCurrentUserPermissionsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousSharedItemCurrentUserRoleKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousSharedItemMostRecentEditorNameComponentsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousSharedItemOwnerNameComponentsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousSharedItemPermissions;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousSharedItemPermissionsReadOnly;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousSharedItemPermissionsReadWrite;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousSharedItemRole;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousSharedItemRoleOwner;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLUbiquitousSharedItemRoleParticipant;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeAvailableCapacityForImportantUsageKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeAvailableCapacityForOpportunisticUsageKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeAvailableCapacityKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeCreationDateKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeIdentifierKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeIsAutomountedKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeIsBrowsableKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeIsEjectableKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeIsEncryptedKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeIsInternalKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeIsJournalingKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeIsLocalKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeIsReadOnlyKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeIsRemovableKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeIsRootFileSystemKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeLocalizedFormatDescriptionKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeLocalizedNameKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeMaximumFileSizeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeMountFromLocationKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeNameKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeResourceCountKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeSubtypeKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeSupportsAccessPermissionsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeSupportsAdvisoryFileLockingKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeSupportsCasePreservedNamesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeSupportsCaseSensitiveNamesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeSupportsCompressionKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeSupportsExclusiveRenamingKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeSupportsExtendedSecurityKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeSupportsFileCloningKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeSupportsFileProtectionKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeSupportsHardLinksKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeSupportsImmutableFilesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeSupportsJournalingKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeSupportsPersistentIDsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeSupportsRenamingKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeSupportsRootDirectoryDatesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeSupportsSparseFilesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeSupportsSwapRenamingKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeSupportsSymbolicLinksKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeSupportsVolumeSizesKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeSupportsZeroRunsKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeTotalCapacityKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeTypeNameKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeURLForRemountingKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeURLKey;
        #[cfg(feature = "Foundation_NSString")]
        pub use self::__NSURL::NSURLVolumeUUIDStringKey;
    }
}
#[cfg(feature = "Foundation")]
pub use self::additions::Foundation;
